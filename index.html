<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statistical Research Analyzer (SRA)</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="graphics/favicon.svg">

    <!-- Local library imports (these files must be downloaded to the /lib folder) -->
    <script src="lib/papaparse.min.js"></script>
    <script src="lib/chart.umd.js"></script>
    <script src="lib/jstat.min.js"></script>
    <script src="lib/html2canvas.min.js"></script>

    <style>
        /**
         * Main CSS Stylesheet
         * This includes all the styling for the application components
         */

        /* Variables for consistent theming - dark theme */
        :root {
            --primary-color: #5a9fd4;
            --primary-hover: #4a8fc4;
            --secondary-color: #52a373;
            --secondary-hover: #429363;
            --accent-color: #7a8b99;
            --accent-hover: #6a7b89;
            --danger-color: #c85450;
            --danger-hover: #b84440;
            --success-color: #52a373;
            --warning-color: #d4a25a;
            --dark-color: #0f1419;
            --light-color: #1c2127;
            --border-color: #2d3339;
            --text-color: #e1e8ed;
            --text-light: #8b98a5;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            --transition-speed: 0.2s;
            --background-dark: #0f1419;
            --background-medium: #1c2127;
            --background-light: #22272e;
            --card-background: #1c2127;
            --input-background: #22272e;
            --hover-background: rgba(90, 159, 212, 0.1);
        }

        /* Base styling */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            width: 100%;
            overflow-x: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-dark);
            padding: 20px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--background-medium);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
            transition: background var(--transition-speed);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #3d4349;
        }

        /* Container to hold application content */
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header styling */
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .header-title h1 {
            color: var(--text-color);
            margin-bottom: 5px;
            font-weight: 600;
        }

        .header-title p {
            color: var(--text-light);
            font-size: 14px;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        /* Card component for sections */
        .card {
            background: var(--card-background);
            border-radius: 12px;
            box-shadow: var(--box-shadow);
            padding: 24px;
            margin-bottom: 24px;
            border: 1px solid var(--border-color);
        }

        /* Section headers */
        h2,
        h3,
        h4 {
            color: var(--text-color);
            margin-bottom: 16px;
            font-weight: 600;
        }

        h2 {
            font-size: 20px;
        }

        h3 {
            font-size: 18px;
        }

        h4 {
            font-size: 16px;
        }

        /* File upload area */
        .file-input {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            text-align: center;
            transition: all var(--transition-speed) ease;
            background-color: var(--background-light);
        }

        .file-input:hover {
            border-color: var(--primary-color);
            background-color: var(--hover-background);
        }

        .file-input.dragover {
            border-color: var(--primary-color);
            background-color: var(--hover-background);
            transform: scale(1.02);
        }

        .file-input input {
            display: none;
        }

        .file-input label {
            padding: 10px 24px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            transition: all var(--transition-speed);
            font-weight: 500;
        }

        .file-input label:hover {
            background-color: var(--primary-hover);
            transform: translateY(-1px);
        }

        /* Data preview table */
        .data-preview {
            overflow-x: auto;
            max-height: 400px;
            margin-top: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--background-light);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        table th,
        table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }

        table th {
            background-color: var(--background-medium);
            position: sticky;
            top: 0;
            z-index: 10;
            font-weight: 600;
            color: var(--text-color);
        }

        table tbody tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.02);
        }

        table tbody tr:hover {
            background-color: var(--hover-background);
        }

        /* Data pagination */
        .pagination {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            gap: 4px;
        }

        .pagination button {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            background-color: var(--background-light);
            color: var(--text-color);
            cursor: pointer;
            transition: all var(--transition-speed);
            border-radius: 6px;
            font-size: 14px;
        }

        .pagination button:hover:not(:disabled) {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        .pagination button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Group parameter definitions */
        .parameter-groups {
            margin-bottom: 20px;
        }

        .parameter-group {
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            background-color: var(--background-light);
            position: relative;
            transition: all var(--transition-speed);
        }

        .parameter-group:hover {
            border-color: #3d4349;
        }

        .parameter-group.excluded {
            opacity: 0.6;
            border-color: var(--border-color);
        }

        .parameter-group-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        /* Group controls section */
        .group-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .group-color-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .color-preset-selector {
            padding: 6px 12px;
            background-color: var(--input-background);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-color);
            font-size: 14px;
            transition: all var(--transition-speed);
        }

        .color-preset-selector:hover {
            border-color: var(--primary-color);
        }

        .color-preview {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .color-preview:hover {
            transform: scale(1.1);
        }

        .custom-color-input {
            width: 100px;
            padding: 6px 12px;
            background-color: var(--input-background);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-color);
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 13px;
            transition: all var(--transition-speed);
        }

        .custom-color-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* Editable group name styling */
        .group-name-input {
            font-size: 18px;
            font-weight: 600;
            border: 1px solid transparent;
            background: transparent;
            padding: 6px 12px;
            border-radius: 6px;
            color: var(--text-color);
            transition: all var(--transition-speed);
            min-width: 200px;
        }

        .group-name-input:hover {
            background-color: var(--hover-background);
        }

        .group-name-input:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: var(--input-background);
        }

        .parameter-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-bottom: 16px;
        }

        .parameter-control {
            flex: 1;
            min-width: 320px;
            padding: 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--background-medium);
            position: relative;
            transition: all var(--transition-speed);
        }

        .parameter-control:hover {
            border-color: #3d4349;
        }

        .parameter-control label {
            font-weight: 500;
            margin-bottom: 8px;
            display: block;
            color: var(--text-color);
            font-size: 14px;
        }

        .condition-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 12px;
        }

        /* Form elements */
        select,
        input[type="number"],
        input[type="text"] {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--input-background);
            color: var(--text-color);
            font-family: inherit;
            font-size: 14px;
            transition: all var(--transition-speed);
        }

        select:hover,
        input[type="number"]:hover,
        input[type="text"]:hover {
            border-color: #3d4349;
        }

        select:focus,
        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        select {
            min-width: 140px;
            cursor: pointer;
        }

        input[type="number"] {
            width: 120px;
        }

        /* Parameter info display */
        .parameter-info {
            font-size: 13px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
            color: var(--text-light);
            line-height: 1.5;
        }

        /* Group distribution statistics */
        .group-distribution {
            background-color: var(--background-dark);
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
            font-size: 13px;
            border: 1px solid var(--border-color);
        }

        .distribution-bar {
            height: 8px;
            background-color: var(--background-medium);
            border-radius: 4px;
            margin: 8px 0;
            overflow: hidden;
        }

        .distribution-fill {
            height: 100%;
            background-color: var(--primary-color);
            transition: width var(--transition-speed);
            border-radius: 4px;
        }

        /* Tab navigation */
        .tabs {
            margin-top: 24px;
        }

        .tab-buttons {
            display: flex;
            overflow-x: auto;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 24px;
            background-color: var(--background-medium);
            border-radius: 12px 12px 0 0;
            padding: 4px;
        }

        .tab-button {
            padding: 10px 20px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            font-weight: 500;
            border-radius: 8px;
            margin-right: 4px;
            white-space: nowrap;
            transition: all var(--transition-speed) ease;
            color: var(--text-light);
            font-size: 14px;
        }

        .tab-button:hover {
            background-color: var(--hover-background);
            color: var(--text-color);
        }

        .tab-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        .tab-content {
            display: none;
            animation: fadeIn var(--transition-speed) ease-in;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Chart containers */
        .chart-container {
            height: 400px;
            margin-bottom: 24px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--background-medium);
        }

        .chart-container.small {
            height: 300px;
        }

        /* Flexible grid layouts */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stats-card {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            background-color: var(--background-medium);
            transition: all var(--transition-speed);
        }

        .stats-card:hover {
            border-color: #3d4349;
        }

        .stats-card h4 {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 12px;
            margin-bottom: 16px;
            color: var(--text-color);
        }

        /* Group badges */
        .group-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 16px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            margin-right: 8px;
        }

        /* Buttons */
        .btn {
            padding: 8px 20px;
            border: 1px solid transparent;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            margin: 4px;
            font-size: 14px;
            background-color: transparent;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .btn-primary:hover {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
        }

        .btn-secondary {
            background-color: transparent;
            border-color: var(--secondary-color);
            color: var(--secondary-color);
        }

        .btn-secondary:hover {
            background-color: var(--secondary-color);
            color: white;
        }

        .btn-accent {
            background-color: transparent;
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        .btn-accent:hover {
            background-color: var(--accent-color);
            color: white;
        }

        .btn-danger {
            background-color: transparent;
            border-color: var(--danger-color);
            color: var(--danger-color);
        }

        .btn-danger:hover {
            background-color: var(--danger-color);
            color: white;
        }

        .btn-small {
            padding: 4px 12px;
            font-size: 12px;
        }

        /* Flexible container */
        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .flex-item {
            flex: 1;
            min-width: 300px;
        }

        /* Loading indicator */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            font-size: 16px;
            color: var(--primary-color);
        }

        .loading::after {
            content: "";
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary-color);
            border-top: 2px solid transparent;
            border-radius: 50%;
            margin-left: 12px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Message boxes */
        .error {
            color: var(--danger-color);
            font-weight: 500;
            padding: 16px;
            border: 1px solid var(--danger-color);
            border-radius: 8px;
            background-color: rgba(200, 84, 80, 0.1);
            margin-bottom: 20px;
        }

        .success {
            color: var(--success-color);
            font-weight: 500;
            padding: 16px;
            border: 1px solid var(--success-color);
            border-radius: 8px;
            background-color: rgba(82, 163, 115, 0.1);
            margin-bottom: 20px;
        }

        /* Significance test results */
        .significance-result {
            margin-top: 16px;
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid;
            position: relative;
            background-color: var(--background-medium);
        }

        .significance-result.significant {
            background-color: rgba(82, 163, 115, 0.1);
            border-left-color: var(--secondary-color);
        }

        .significance-result.not-significant {
            background-color: rgba(200, 84, 80, 0.1);
            border-left-color: var(--danger-color);
        }

        /* Test prerequisites section */
        .test-prerequisites {
            background-color: var(--background-medium);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .prerequisite-result {
            margin: 12px 0;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
        }

        .prerequisite-result.pass {
            background-color: rgba(82, 163, 115, 0.1);
            border: 1px solid rgba(82, 163, 115, 0.3);
        }

        .prerequisite-result.fail {
            background-color: rgba(200, 84, 80, 0.1);
            border: 1px solid rgba(200, 84, 80, 0.3);
        }

        /* Warning box for test override */
        .warning-box {
            background-color: rgba(212, 162, 90, 0.1);
            border: 1px solid rgba(212, 162, 90, 0.3);
            border-radius: 6px;
            padding: 12px;
            margin: 12px 0;
            font-size: 14px;
        }

        .warning-box strong {
            color: var(--warning-color);
        }

        /* Test violation warning */
        .test-violation-warning {
            background-color: rgba(200, 84, 80, 0.1);
            border: 1px solid rgba(200, 84, 80, 0.3);
            border-radius: 6px;
            padding: 16px;
            margin: 16px 0;
        }

        .test-violation-warning h5 {
            color: var(--danger-color);
            margin-bottom: 12px;
        }

        .test-violation-warning ul {
            margin-left: 20px;
            margin-top: 12px;
        }

        .test-violation-warning li {
            margin-bottom: 6px;
        }

        /* Checkbox styling */
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--primary-color);
        }

        /* Parameter selector */
        .parameter-selector {
            margin-bottom: 20px;
            padding: 16px;
            background-color: var(--background-medium);
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            border: 1px solid var(--border-color);
        }

        .parameter-selector label {
            font-weight: 500;
            margin-right: 8px;
            color: var(--text-color);
            font-size: 14px;
        }

        .parameter-selector select {
            padding: 8px 12px;
            min-width: 240px;
        }

        /* Statistics table */
        .stats-table-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        /* Clear button for results */
        .clear-results {
            display: block;
            margin: 12px 0;
            padding: 6px 12px;
            background-color: var(--background-light);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-color);
            transition: all var(--transition-speed);
        }

        .clear-results:hover {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        /* Help tooltips */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            margin-left: 6px;
            font-size: 14px;
            color: var(--primary-color);
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 260px;
            background-color: var(--background-light);
            color: var(--text-color);
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            margin-left: -130px;
            opacity: 0;
            transition: opacity var(--transition-speed);
            font-size: 12px;
            font-weight: normal;
            line-height: 1.5;
            border: 1px solid var(--border-color);
            box-shadow: var(--box-shadow);
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Test info box */
        .test-info {
            background-color: rgba(90, 159, 212, 0.1);
            border: 1px solid rgba(90, 159, 212, 0.3);
            border-radius: 6px;
            padding: 12px;
            margin: 12px 0;
            font-size: 14px;
        }

        /* Regression controls */
        .regression-controls {
            margin-bottom: 16px;
            padding: 12px;
            background-color: var(--background-medium);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        /* Regression type selector */
        .regression-type-container {
            margin-bottom: 12px;
        }

        .regression-type-container label {
            font-weight: 500;
            margin-right: 10px;
            color: var(--text-color);
            font-size: 14px;
        }

        /* Regression significance info */
        .regression-significance {
            margin-top: 12px;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
        }

        .regression-significance.significant {
            background-color: rgba(82, 163, 115, 0.1);
            border: 1px solid rgba(82, 163, 115, 0.3);
        }

        .regression-significance.not-significant {
            background-color: rgba(200, 84, 80, 0.1);
            border: 1px solid rgba(200, 84, 80, 0.3);
        }

        /* Scale type badges */
        .scale-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
            text-transform: uppercase;
        }

        .scale-badge.nominal {
            background-color: #3d4349;
            color: var(--text-light);
        }

        .scale-badge.ordinal {
            background-color: #4d5359;
            color: var(--text-light);
        }

        .scale-badge.interval {
            background-color: #5d6369;
            color: var(--text-color);
        }

        .scale-badge.ratio {
            background-color: #6d7379;
            color: var(--text-color);
        }

        /* Parameter constellation styles */
        .parameter-constellations {
            margin-bottom: 24px;
            padding: 20px;
            background-color: var(--background-medium);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .parameter-constellations h3 {
            margin-bottom: 8px;
        }

        .parameter-constellations>p {
            color: var(--text-light);
            font-size: 14px;
            margin-bottom: 16px;
        }

        .constellation-item {
            padding: 16px;
            margin-bottom: 16px;
            background-color: var(--background-light);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: all var(--transition-speed);
        }

        .constellation-item:hover {
            border-color: #3d4349;
        }

        .constellation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .constellation-name {
            font-weight: 600;
            color: var(--primary-color);
            background-color: transparent;
            border: 1px solid transparent;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all var(--transition-speed);
            font-size: 16px;
            min-width: 200px;
        }

        .constellation-name:hover {
            background-color: var(--hover-background);
        }

        .constellation-name:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: var(--input-background);
        }

        .constellation-conditions {
            font-size: 14px;
            color: var(--text-light);
        }

        /* Constellation reference in groups */
        .constellation-reference {
            background-color: var(--background-dark) !important;
            border: 1px solid var(--primary-color) !important;
        }

        .constellation-reference.negated {
            background-color: rgba(200, 84, 80, 0.1) !important;
            border-color: var(--danger-color) !important;
        }

        .negation-checkbox {
            margin-right: 8px;
            accent-color: var(--danger-color);
        }

        /* Group condition selector */
        .group-conditions {
            margin-bottom: 16px;
        }

        .condition-type-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .condition-type-selector button {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--border-color);
            background-color: var(--background-light);
            color: var(--text-color);
            cursor: pointer;
            transition: all var(--transition-speed);
            border-radius: 6px;
            font-weight: 500;
            font-size: 14px;
        }

        .condition-type-selector button:hover {
            background-color: var(--hover-background);
            border-color: var(--primary-color);
        }

        .condition-type-selector button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Not in previous group checkbox */
        .not-in-previous-checkbox {
            margin: 16px 0;
            padding: 12px;
            background-color: rgba(212, 162, 90, 0.1);
            border: 1px solid rgba(212, 162, 90, 0.3);
            border-radius: 6px;
        }

        /* Fourfold table styles */
        .fourfold-table {
            margin: 20px 0;
        }

        .fourfold-selector {
            margin-bottom: 24px;
            padding: 20px;
            background-color: var(--background-medium);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .fourfold-selector-item {
            margin-bottom: 16px;
        }

        .fourfold-selector-item label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color);
            font-size: 14px;
        }

        .fourfold-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .fourfold-grid {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 12px;
            margin-bottom: 24px;
        }

        .fourfold-cell {
            padding: 16px;
            border: 1px solid var(--border-color);
            text-align: center;
            background-color: var(--background-medium);
            border-radius: 6px;
        }

        .fourfold-header {
            background-color: var(--background-light);
            font-weight: 600;
        }

        .fourfold-value {
            font-size: 1.5em;
            font-weight: 700;
            color: var(--primary-color);
        }

        .fourfold-statistics {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 16px;
            margin-top: 24px;
        }

        .fourfold-stat-card {
            padding: 16px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--background-medium);
            transition: all var(--transition-speed);
        }

        .fourfold-stat-card:hover {
            border-color: #3d4349;
        }

        .fourfold-stat-card h5 {
            margin-bottom: 8px;
            color: var(--text-color);
            font-size: 14px;
        }

        .fourfold-stat-value {
            font-size: 1.3em;
            font-weight: 700;
            color: var(--primary-color);
        }

        /* Data validation warnings */
        .validation-warnings {
            background-color: rgba(212, 162, 90, 0.1);
            border: 1px solid rgba(212, 162, 90, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .validation-warnings h4 {
            color: var(--warning-color);
            margin-bottom: 12px;
        }

        .validation-warnings ul {
            margin-left: 20px;
        }

        .validation-warnings li {
            margin-bottom: 6px;
            font-size: 14px;
        }

        /* About modal */
        #about-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        #about-modal>div {
            position: relative;
            width: 80%;
            max-width: 600px;
            margin: 80px auto;
            background-color: var(--card-background);
            padding: 32px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }

        #close-about {
            position: absolute;
            top: 16px;
            right: 16px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-light);
            transition: color var(--transition-speed);
        }

        #close-about:hover {
            color: var(--text-color);
        }

        /* Export results section */
        .export-section {
            margin-top: 24px;
            padding: 16px;
            background-color: var(--background-medium);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .export-section h5 {
            margin-bottom: 12px;
            color: var(--text-color);
            font-size: 14px;
        }

        /* Text center utility */
        .text-center {
            text-align: center;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .parameter-control {
                min-width: 100%;
            }

            .tab-button {
                padding: 8px 16px;
                font-size: 13px;
            }

            .flex-item {
                min-width: 100%;
            }

            .condition-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .group-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <div class="header-title">
                <h1>Statistical Research Analyzer (SRA)</h1>
                <p>A comprehensive tool for statistical analysis and visualization</p>
            </div>
            <div class="header-actions">
                <button id="about-btn" class="btn btn-accent">About</button>
            </div>
        </header>

        <!-- File Import Section -->
        <div class="card">
            <h2>Data Import</h2>
            <div class="file-input" id="file-input-area">
                <h3>Import CSV Data</h3>
                <p>Upload a CSV file with the following format:</p>
                <ul style="text-align: left; margin: 10px 0;">
                    <li><strong>Row 1:</strong> Column Headers</li>
                    <li><strong>Row 2:</strong> Data Types
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li><strong>k</strong> = Categorical (Nominal scale)</li>
                            <li><strong>o</strong> = Ordinal (Ordinal scale, e.g., 1-5 ratings)</li>
                            <li><strong>i</strong> = Interval (Interval scale, e.g., temperature)</li>
                            <li><strong>r</strong> = Ratio (Ratio scale, e.g., age, weight)</li>
                        </ul>
                    </li>
                    <li><strong>Row 3+:</strong> Data Rows</li>
                </ul>
                <p><em>Delimiter: Semicolon (;) or Comma (,) | Decimal: Comma (,) or Point (.)</em></p>
                <input type="file" id="csv-file" accept=".csv">
                <label for="csv-file">Select File or Drag & Drop</label>
            </div>

            <div id="loading" class="loading" style="display: none;">
                Processing data...
            </div>

            <div id="error-message" class="error" style="display: none;"></div>
            <div id="success-message" class="success" style="display: none;"></div>

            <div id="validation-warnings" class="validation-warnings" style="display: none;">
                <h4>⚠️ Data Validation Warnings</h4>
                <ul id="validation-warnings-list"></ul>
            </div>
        </div>

        <!-- Data Preview Section -->
        <div id="data-preview-container" class="card" style="display: none;">
            <h2>Data Preview</h2>
            <div id="data-summary" style="margin-bottom: 15px;"></div>

            <div class="data-preview">
                <table id="data-preview-table"></table>
            </div>

            <!-- Pagination Controls -->
            <div class="pagination" id="data-pagination"></div>

            <!-- Data Options -->
            <div class="flex-container" style="margin-top: 15px;">
                <div class="flex-item">
                    <label for="rows-per-page">Rows per page:</label>
                    <select id="rows-per-page" onchange="updateDataPagination()">
                        <option value="10">10</option>
                        <option value="25" selected>25</option>
                        <option value="50">50</option>
                        <option value="100">100</option>
                        <option value="200">200</option>
                    </select>
                </div>
                <div class="flex-item">
                    <button id="export-preview-csv" class="btn btn-accent">Export Preview as CSV</button>
                </div>
            </div>
        </div>

        <!-- Group Definition Section -->
        <div id="group-definition-container" class="card" style="display: none;">
            <h2>Define Subgroups</h2>

            <!-- Parameter Constellations Section -->
            <div class="parameter-constellations">
                <h3>Parameter Constellations</h3>
                <p>Define reusable parameter combinations that can be used in multiple groups (optional):</p>
                <div id="constellation-list"></div>
                <button id="add-constellation" class="btn btn-primary btn-small">Add New Constellation</button>
            </div>

            <p>Create subgroups by combining parameter constellations and/or individual conditions:</p>

            <div class="parameter-groups" id="parameter-groups">
                <!-- Dynamically populated -->
            </div>

            <div style="margin-top: 20px;">
                <button id="add-group" class="btn btn-primary">Add New Subgroup</button>
                <button id="apply-groups" class="btn btn-secondary">Apply Groups & Analyze</button>
                <button id="reset-groups" class="btn btn-danger">Reset</button>
                <button id="import-groups" class="btn btn-accent">Import Definition</button>
                <button id="export-groups" class="btn btn-accent">Export Definition</button>
            </div>
        </div>

        <!-- Analysis Results Section -->
        <div id="analysis-results" class="card" style="display: none;">
            <h2>Analysis Results</h2>

            <div class="tabs">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="overview">Overview</button>
                    <button class="tab-button" data-tab="detailed">Detailed Analysis</button>
                    <button class="tab-button" data-tab="significance">Significance Tests</button>
                    <button class="tab-button" data-tab="visualization">Visualization</button>
                    <button class="tab-button" data-tab="fourfold">Fourfold Table</button>
                    <button class="tab-button" data-tab="export">Export</button>
                </div>

                <!-- Overview Tab -->
                <div class="tab-content active" id="overview">
                    <h3>Group Overview</h3>
                    <div class="flex-container">
                        <div class="flex-item">
                            <div id="group-summary-table"></div>
                        </div>
                        <div class="flex-item">
                            <div class="chart-container small">
                                <canvas id="group-distribution-chart"></canvas>
                            </div>
                            <div class="text-center">
                                <button class="btn btn-small btn-accent"
                                    onclick="exportChartAsImage('group-distribution-chart')">Export Chart</button>
                            </div>
                        </div>
                    </div>

                    <h3>Statistical Metrics for All Parameters</h3>
                    <div class="stats-table-container">
                        <table id="overview-stats-table"></table>
                    </div>
                    <div class="text-center">
                        <button class="btn btn-small btn-accent"
                            onclick="exportTableAsCSV('overview-stats-table', 'overview-statistics')">Export Statistics
                        </button>
                    </div>

                    <div class="export-section">
                        <h5>Export Group Overview</h5>
                        <button class="btn btn-accent btn-small" onclick="exportGroupOverview()">Export Overview Report
                        </button>
                    </div>
                </div>

                <!-- Detailed Analysis Tab -->
                <div class="tab-content" id="detailed">
                    <h3>Detailed Parameter Analysis</h3>

                    <div class="parameter-selector">
                        <label for="detail-parameter-select">Select Parameter:</label>
                        <select id="detail-parameter-select">
                            <option value="">Please select a parameter</option>
                        </select>
                        <span class="tooltip">ⓘ
                            <span class="tooltip-text">Select a numeric parameter (ordinal, interval, or ratio scale) to
                                view detailed statistics across all groups</span>
                        </span>
                    </div>

                    <div id="detail-analysis-content">
                        <div class="flex-container">
                            <div class="flex-item">
                                <h4>Mean Values with Error Bars</h4>
                                <div class="chart-container">
                                    <canvas id="detail-mean-chart"></canvas>
                                </div>
                                <div class="text-center">
                                    <button class="btn btn-small btn-accent"
                                        onclick="exportChartAsImage('detail-mean-chart')">Export Chart</button>
                                </div>
                            </div>
                            <div class="flex-item">
                                <h4>Distribution Comparison</h4>
                                <div class="chart-container">
                                    <canvas id="detail-distribution-chart"></canvas>
                                </div>
                                <div class="text-center">
                                    <button class="btn btn-small btn-accent"
                                        onclick="exportChartAsImage('detail-distribution-chart')">Export Chart</button>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 30px;">
                            <h4>Data Distribution Analysis</h4>

                            <!-- Add group selection controls -->
                            <div
                                style="margin-bottom: 15px; padding: 15px; background-color: var(--background-medium); border-radius: 8px; border: 1px solid var(--border-color);">
                                <div style="margin-bottom: 10px;">
                                    <strong>Select Groups to Display:</strong>
                                    <button id="histogram-select-all" class="btn btn-small btn-primary"
                                        style="margin-left: 10px;">Select All</button>
                                    <button id="histogram-select-none" class="btn btn-small btn-accent">Select
                                        None</button>
                                </div>
                                <div id="histogram-group-selection" style="display: flex; flex-wrap: wrap; gap: 10px;">
                                    <!-- Group checkboxes will be inserted here -->
                                </div>
                            </div>

                            <div class="chart-container">
                                <canvas id="detail-histogram-chart"></canvas>
                            </div>
                            <div class="text-center">
                                <button class="btn btn-small btn-accent"
                                    onclick="exportChartAsImage('detail-histogram-chart')">Export Chart</button>
                            </div>
                        </div>

                        <h4>Detailed Statistics</h4>
                        <div class="stats-table-container">
                            <table id="detail-stats-table"></table>
                        </div>
                        <div class="text-center">
                            <button class="btn btn-small btn-accent"
                                onclick="exportTableAsCSV('detail-stats-table', 'detailed-statistics')">Export
                                Statistics
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Significance Tests Tab -->
                <div class="tab-content" id="significance">
                    <h3>Statistical Significance Tests</h3>

                    <!-- Test Prerequisites Section -->
                    <div class="test-prerequisites">
                        <h4>Test Prerequisites</h4>
                        <div class="flex-container">
                            <div class="flex-item">
                                <button id="check-normality" class="btn btn-primary btn-small">Check Normality</button>
                                <span class="tooltip">ⓘ
                                    <span class="tooltip-text">Shapiro-Wilk test for samples n ≤ 50. Tests if data
                                        follows normal distribution. Required for parametric tests like t-test and
                                        ANOVA.</span>
                                </span>
                            </div>
                            <div class="flex-item">
                                <button id="check-variance" class="btn btn-primary btn-small">Check Variance Homogeneity
                                </button>
                                <span class="tooltip">ⓘ
                                    <span class="tooltip-text">F-test for 2 groups. Tests if groups have equal
                                        variances. Important for choosing between standard t-test and Welch's
                                        t-test.</span>
                                </span>
                            </div>
                        </div>
                        <div id="prerequisite-results"></div>
                    </div>

                    <div class="flex-container" style="margin-bottom: 20px;">
                        <div class="flex-item">
                            <label for="sig-parameter-select">Parameter for Testing:</label>
                            <select id="sig-parameter-select" style="width: 100%; margin-top: 5px;">
                                <option value="">Select parameter</option>
                            </select>
                        </div>
                        <div class="flex-item">
                            <label for="sig-test-type">Test Method:</label>
                            <select id="sig-test-type" style="width: 100%; margin-top: 5px;">
                                <option value="auto">Auto-select (Recommended)</option>
                                <optgroup label="Parametric Tests">
                                    <option value="ttest">t-Test (2 groups, normal distribution)</option>
                                    <option value="welch">Welch's t-Test (2 groups, unequal variances)</option>
                                    <option value="anova">ANOVA (>2 groups, normal distribution)</option>
                                </optgroup>
                                <optgroup label="Non-Parametric Tests">
                                    <option value="mann-whitney">Mann-Whitney U (2 groups, non-normal)</option>
                                    <option value="wilcoxon">Wilcoxon Signed-Rank (paired samples)</option>
                                    <option value="kruskal-wallis">Kruskal-Wallis (>2 groups, non-normal)</option>
                                </optgroup>
                                <optgroup label="Categorical Tests">
                                    <option value="chi-square">Chi-Square (categorical data)</option>
                                    <option value="fisher">Fisher's Exact (2x2 tables, small samples)</option>
                                </optgroup>
                                <optgroup label="Correlation Tests">
                                    <option value="pearson">Pearson Correlation (linear, normal)</option>
                                    <option value="spearman">Spearman Correlation (monotonic, non-normal)</option>
                                </optgroup>
                            </select>
                        </div>
                    </div>

                    <div class="test-info" id="test-info" style="display: none;"></div>

                    <div class="flex-container" style="margin-bottom: 20px;">
                        <div class="flex-item">
                            <label for="sig-alpha">Significance Level (α):</label>
                            <select id="sig-alpha" style="width: 100%; margin-top: 5px;">
                                <option value="0.05">0.05 (5%)</option>
                                <option value="0.01">0.01 (1%)</option>
                                <option value="0.1">0.10 (10%)</option>
                                <option value="custom">Custom</option>
                            </select>
                            <input type="number" id="sig-custom-alpha"
                                style="width: 100%; margin-top: 5px; display: none;" min="0.001" max="0.5" step="0.001"
                                value="0.05" placeholder="Enter custom alpha (0.001-0.5)">
                        </div>
                        <div class="flex-item">
                            <label for="sig-direction">Test Direction:</label>
                            <select id="sig-direction" style="width: 100%; margin-top: 5px;">
                                <option value="two-sided">Two-sided (≠)</option>
                                <option value="left">Left-sided (
                                    <)< /option>
                                <option value="right">Right-sided (>)</option>
                            </select>
                            <div style="margin-top: 5px;">
                                <span class="tooltip">ⓘ
                                    <span class="tooltip-text">
                                        Two-sided: Tests if groups are different<br>
                                        Left-sided: Tests if Group 1 < Group 2<br>
                                            Right-sided: Tests if Group 1 > Group 2<br>
                                            Note: Only applicable for certain tests
                                    </span>
                                </span>
                            </div>
                        </div>
                    </div>

                    <div class="checkbox-container">
                        <input type="checkbox" id="force-test-execution">
                        <label for="force-test-execution">Force test execution even if prerequisites are not met</label>
                        <span class="tooltip">ⓘ
                            <span class="tooltip-text">Enable this to run tests even when assumptions are violated.
                                Results will include warnings about which assumptions were not met.</span>
                        </span>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4>Select Groups for Comparison:</h4>
                        <div id="sig-group-selection" class="flex-container" style="margin-top: 10px;"></div>
                    </div>

                    <button id="run-significance-test" class="btn btn-primary">Run Significance Test</button>
                    <button id="clear-significance-results" class="btn btn-danger">Clear Results</button>

                    <div id="significance-results"></div>

                    <div class="export-section">
                        <h5>Export Test Results</h5>
                        <button class="btn btn-accent btn-small" onclick="exportSignificanceTests()">Export All Test
                            Results
                        </button>
                    </div>
                </div>

                <!-- Visualization Tab -->
                <div class="tab-content" id="visualization">
                    <h3>Custom Visualization</h3>

                    <div class="flex-container" style="margin-bottom: 20px;">
                        <div class="flex-item">
                            <label for="viz-parameter-x">X-Axis Parameter:</label>
                            <select id="viz-parameter-x" style="width: 100%; margin-top: 5px;"></select>
                        </div>
                        <div class="flex-item">
                            <label for="viz-parameter-y">Y-Axis Parameter:</label>
                            <select id="viz-parameter-y" style="width: 100%; margin-top: 5px;"></select>
                        </div>
                        <div class="flex-item">
                            <label for="viz-chart-type">Chart Type:</label>
                            <select id="viz-chart-type" style="width: 100%; margin-top: 5px;">
                                <option value="scatter">Scatter Plot</option>
                                <option value="bar">Bar Chart</option>
                                <option value="line">Line Chart</option>
                            </select>
                        </div>
                    </div>

                    <!-- Regression Controls -->
                    <div class="regression-controls" id="regression-controls" style="display: none;">
                        <div class="regression-type-container">
                            <label for="regression-type">Regression Type:</label>
                            <select id="regression-type">
                                <option value="linear">Linear</option>
                                <option value="polynomial2">Polynomial (2nd order)</option>
                                <option value="polynomial3">Polynomial (3rd order)</option>
                                <option value="logarithmic">Logarithmic</option>
                                <option value="exponential">Exponential</option>
                            </select>
                            <span class="tooltip">ⓘ
                                <span class="tooltip-text">
                                    Linear: y = ax + b<br>
                                    Polynomial: y = ax² + bx + c<br>
                                    Logarithmic: y = a·ln(x) + b<br>
                                    Exponential: y = a·e^(bx)
                                </span>
                            </span>
                        </div>
                        <div class="checkbox-container">
                            <input type="checkbox" id="show-regression" checked>
                            <label for="show-regression">Show regression line</label>
                        </div>
                        <div class="regression-type-container" style="margin-top: 10px;">
                            <label for="regression-alpha">Significance Level:</label>
                            <select id="regression-alpha">
                                <option value="0.05">0.05 (95% confidence)</option>
                                <option value="0.01">0.01 (99% confidence)</option>
                            </select>
                        </div>
                        <div id="regression-info" style="margin-top: 10px; font-size: 0.9em; color: var(--text-light);">
                        </div>
                    </div>

                    <button id="generate-visualization" class="btn btn-primary">Generate Chart</button>

                    <div class="chart-container">
                        <canvas id="custom-visualization-chart"></canvas>
                    </div>

                    <div class="text-center">
                        <button class="btn btn-accent" onclick="exportChartAsImage('custom-visualization-chart')">Export
                            Chart
                        </button>
                    </div>
                </div>

                <!-- Fourfold Table Tab -->
                <div class="tab-content" id="fourfold">
                    <h3>Fourfold Table Analysis</h3>

                    <div class="fourfold-selector">
                        <p>Select two parameter constellations for comparison:</p>
                        <div class="fourfold-selector-item">
                            <label for="fourfold-constellation-1">Test Constellation (what is being tested):</label>
                            <div class="fourfold-controls">
                                <input type="checkbox" id="fourfold-not-1" class="negation-checkbox">
                                <label for="fourfold-not-1">NOT</label>
                                <select id="fourfold-constellation-1" style="flex: 1;">
                                    <option value="">Select test constellation</option>
                                </select>
                            </div>
                        </div>
                        <div class="fourfold-selector-item">
                            <label for="fourfold-constellation-2">True Condition Constellation (gold standard):</label>
                            <div class="fourfold-controls">
                                <input type="checkbox" id="fourfold-not-2" class="negation-checkbox">
                                <label for="fourfold-not-2">NOT</label>
                                <select id="fourfold-constellation-2" style="flex: 1;">
                                    <option value="">Select true condition constellation</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <button id="generate-fourfold" class="btn btn-primary">Generate Fourfold Table</button>

                    <div id="fourfold-results" style="margin-top: 20px;"></div>

                    <div class="export-section" id="fourfold-export" style="display: none;">
                        <h5>Export Fourfold Table</h5>
                        <button class="btn btn-accent btn-small" onclick="exportFourfoldTable()">Export Fourfold
                            Analysis
                        </button>
                    </div>
                </div>

                <!-- Export Tab -->
                <div class="tab-content" id="export">
                    <h3>Export Data</h3>

                    <div class="flex-container">
                        <div class="flex-item">
                            <h4>Data Export</h4>
                            <p>Export the grouped analysis as a CSV file:</p>
                            <div style="margin: 15px 0;">
                                <div class="checkbox-container">
                                    <input type="checkbox" id="export-raw-data" checked>
                                    <label for="export-raw-data">Raw data with grouping</label>
                                </div>
                                <div class="checkbox-container">
                                    <input type="checkbox" id="export-statistics" checked>
                                    <label for="export-statistics">Statistical metrics</label>
                                </div>
                                <div class="checkbox-container">
                                    <input type="checkbox" id="export-group-definitions" checked>
                                    <label for="export-group-definitions">Group definitions</label>
                                </div>
                            </div>
                            <button id="export-csv-data" class="btn btn-secondary">Export as CSV</button>
                        </div>

                        <div class="flex-item">
                            <h4>Comprehensive Report</h4>
                            <p>Export all analysis results in a single report:</p>
                            <div style="margin: 15px 0;">
                                <div class="checkbox-container">
                                    <input type="checkbox" id="export-report-overview" checked>
                                    <label for="export-report-overview">Group overview</label>
                                </div>
                                <div class="checkbox-container">
                                    <input type="checkbox" id="export-report-statistics" checked>
                                    <label for="export-report-statistics">Detailed statistics</label>
                                </div>
                                <div class="checkbox-container">
                                    <input type="checkbox" id="export-report-tests" checked>
                                    <label for="export-report-tests">Significance tests</label>
                                </div>
                                <div class="checkbox-container">
                                    <input type="checkbox" id="export-report-fourfold" checked>
                                    <label for="export-report-fourfold">Fourfold tables</label>
                                </div>
                            </div>
                            <button id="export-comprehensive-report" class="btn btn-secondary">Export Comprehensive
                                Report
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- About Modal -->
        <div id="about-modal">
            <div>
                <button id="close-about">×</button>
                <h2>About Statistical Research Analyzer</h2>
                <p style="margin: 15px 0;">
                    This application is designed for statistical analysis of research data, allowing for subgroup
                    definition, statistical testing, and visualization of results. All processing is done locally in
                    your browser - no data is sent to any server.
                </p>
                <h4>Features:</h4>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Support for multiple scale types (nominal, ordinal, interval, ratio)</li>
                    <li>Prerequisite testing (normality, variance homogeneity)</li>
                    <li>Multiple parametric and non-parametric tests</li>
                    <li>Multiple visualization options</li>
                    <li>Multiple regression analysis types with significance testing</li>
                </ul>
                <p><strong>Privacy:</strong> All data processing happens locally in your browser. No data is transmitted
                    to any server.</p>
                <p>Version 1.0</p>
            </div>
        </div>
    </div>

    <script>
        /**
         * Statistical Research Analyzer (SRA) - Version 1.0
         * 
         * A comprehensive client-side statistical analysis tool for research data.
         * All processing is done locally for data privacy.
         */

        /**
         * Global State Management
         */
        const globalState = {
            // Data related properties
            rawData: [],                // Original data from CSV
            columnTypes: {},            // Data types for each column
            columnNames: [],            // Column names from CSV header
            processedData: {},          // Data organized by groups
            csvDelimiter: ';',         // CSV delimiter detected from import
            decimalSeparator: '.',     // Decimal separator detected from import

            // Group related properties
            groupDefinitions: [],       // User defined group criteria
            currentGroups: {},          // Current active groups
            parameterConstellations: [], // Reusable parameter combinations

            // UI state
            charts: {},                 // References to all created charts
            isProcessing: false,        // Processing state flag
            currentPage: 1,             // Current page for data pagination
            rowsPerPage: 25,            // Number of rows per page

            // Analysis state
            selectedParameter: null,    // Currently selected parameter for analysis
            significanceResults: [],    // Stored significance test results
            prerequisiteResults: {},    // Stored prerequisite test results
            recordAssignments: [],      // Track which groups each record belongs to
            fourfoldResults: null       // Store fourfold table results for export
        };

        /**
         * Color Palette for Groups - dark theme colors
         */
        const groupColors = [
            { bg: 'rgba(90, 159, 212, 0.7)', border: 'rgba(90, 159, 212, 1)', name: 'Blue' },
            { bg: 'rgba(122, 139, 153, 0.7)', border: 'rgba(122, 139, 153, 1)', name: 'Gray' },
            { bg: 'rgba(82, 163, 115, 0.7)', border: 'rgba(82, 163, 115, 1)', name: 'Green' },
            { bg: 'rgba(91, 192, 222, 0.7)', border: 'rgba(91, 192, 222, 1)', name: 'Light Blue' },
            { bg: 'rgba(212, 162, 90, 0.7)', border: 'rgba(212, 162, 90, 1)', name: 'Orange' },
            { bg: 'rgba(200, 84, 80, 0.7)', border: 'rgba(200, 84, 80, 1)', name: 'Red' },
            { bg: 'rgba(160, 160, 160, 0.7)', border: 'rgba(160, 160, 160, 1)', name: 'Light Gray' },
            { bg: 'rgba(100, 100, 100, 0.7)', border: 'rgba(100, 100, 100, 1)', name: 'Dark Gray' },
            { bg: 'rgba(156, 117, 181, 0.7)', border: 'rgba(156, 117, 181, 1)', name: 'Purple' },
            { bg: 'rgba(255, 193, 7, 0.7)', border: 'rgba(255, 193, 7, 1)', name: 'Amber' },
            { bg: 'rgba(0, 188, 212, 0.7)', border: 'rgba(0, 188, 212, 1)', name: 'Cyan' },
            { bg: 'rgba(233, 30, 99, 0.7)', border: 'rgba(233, 30, 99, 1)', name: 'Pink' },
            { bg: 'rgba(139, 195, 74, 0.7)', border: 'rgba(139, 195, 74, 1)', name: 'Light Green' },
            { bg: 'rgba(255, 152, 0, 0.7)', border: 'rgba(255, 152, 0, 1)', name: 'Deep Orange' },
            { bg: 'rgba(96, 125, 139, 0.7)', border: 'rgba(96, 125, 139, 1)', name: 'Blue Gray' },
            { bg: 'rgba(121, 85, 72, 0.7)', border: 'rgba(121, 85, 72, 1)', name: 'Brown' },
            { bg: 'rgba(0, 150, 136, 0.7)', border: 'rgba(0, 150, 136, 1)', name: 'Teal' },
            { bg: 'rgba(103, 58, 183, 0.7)', border: 'rgba(103, 58, 183, 1)', name: 'Deep Purple' }
        ];

        /**
         * Scale Type Definitions
         */
        const scaleTypes = {
            'k': {
                name: 'Nominal',
                description: 'Categories without order (e.g., gender, color)',
                allowedStats: ['mode', 'frequency'],
                allowedTests: ['chi-square', 'fisher'],
                numeric: false
            },
            'o': {
                name: 'Ordinal',
                description: 'Ordered categories (e.g., ratings 1-5, education level)',
                allowedStats: ['median', 'mode', 'quartiles', 'range'],
                allowedTests: ['mann-whitney', 'wilcoxon', 'kruskal-wallis', 'spearman'],
                numeric: true
            },
            'i': {
                name: 'Interval',
                description: 'Equal intervals, no true zero (e.g., temperature in °C)',
                allowedStats: ['mean', 'median', 'mode', 'std', 'quartiles', 'range'],
                allowedTests: ['ttest', 'welch', 'anova', 'mann-whitney', 'kruskal-wallis', 'pearson', 'spearman'],
                numeric: true
            },
            'r': {
                name: 'Ratio',
                description: 'Equal intervals with true zero (e.g., age, weight)',
                allowedStats: ['mean', 'median', 'mode', 'std', 'quartiles', 'range', 'cv'],
                allowedTests: ['ttest', 'welch', 'anova', 'mann-whitney', 'kruskal-wallis', 'pearson', 'spearman'],
                numeric: true
            }
        };

        /**
         * Test Information
         */
        const testInfo = {
            'auto': {
                name: 'Auto-select',
                description: 'Automatically selects the most appropriate test based on data type, scale level, and distribution'
            },
            'ttest': {
                name: 't-Test',
                description: 'Compares means of two groups. Requires normal distribution and equal variances.',
                requirements: 'Normal distribution, equal variances, interval/ratio scale'
            },
            'welch': {
                name: "Welch's t-Test",
                description: 'Modified t-test for two groups with unequal variances. More robust than standard t-test.',
                requirements: 'Normal distribution, interval/ratio scale'
            },
            'anova': {
                name: 'ANOVA',
                description: 'Compares means across multiple groups. Extension of t-test for >2 groups.',
                requirements: 'Normal distribution, equal variances, interval/ratio scale'
            },
            'mann-whitney': {
                name: 'Mann-Whitney U Test',
                description: 'Non-parametric alternative to t-test. Compares distributions of two independent groups.',
                requirements: 'Ordinal, interval, or ratio scale. No normality assumption.'
            },
            'wilcoxon': {
                name: 'Wilcoxon Signed-Rank Test',
                description: 'Non-parametric test for paired samples. Alternative to paired t-test.',
                requirements: 'Paired data, ordinal/interval/ratio scale'
            },
            'kruskal-wallis': {
                name: 'Kruskal-Wallis Test',
                description: 'Non-parametric alternative to ANOVA. Compares distributions across multiple groups.',
                requirements: 'Ordinal, interval, or ratio scale. No normality assumption.'
            },
            'chi-square': {
                name: 'Chi-Square Test',
                description: 'Tests association between categorical variables.',
                requirements: 'Nominal or ordinal scale, expected frequencies ≥ 5'
            },
            'fisher': {
                name: "Fisher's Exact Test",
                description: 'Exact test for 2x2 contingency tables. Used when sample sizes are small.',
                requirements: 'Nominal scale, 2x2 table, small sample sizes'
            },
            'pearson': {
                name: 'Pearson Correlation',
                description: 'Measures linear relationship between two continuous variables.',
                requirements: 'Interval/ratio scale, normal distribution, linear relationship'
            },
            'spearman': {
                name: 'Spearman Correlation',
                description: 'Measures monotonic relationship. Non-parametric alternative to Pearson.',
                requirements: 'Ordinal, interval, or ratio scale. No normality assumption.'
            }
        };

        /**
         * Regression Types Configuration
         */
        const regressionTypes = {
            linear: {
                name: 'Linear',
                equation: 'y = ax + b',
                minPoints: 2,
                transform: null,
                inverseTransform: null
            },
            polynomial2: {
                name: 'Polynomial (2nd order)',
                equation: 'y = ax² + bx + c',
                minPoints: 3,
                transform: null,
                inverseTransform: null
            },
            polynomial3: {
                name: 'Polynomial (3rd order)',
                equation: 'y = ax³ + bx² + cx + d',
                minPoints: 4,
                transform: null,
                inverseTransform: null
            },
            logarithmic: {
                name: 'Logarithmic',
                equation: 'y = a·ln(x) + b',
                minPoints: 2,
                transform: (x) => Math.log(x),
                inverseTransform: (x) => Math.exp(x),
                validate: (points) => points.every(p => p.x > 0)
            },
            exponential: {
                name: 'Exponential',
                equation: 'y = a·e^(bx)',
                minPoints: 2,
                transform: (y) => Math.log(y),
                inverseTransform: (y) => Math.exp(y),
                validate: (points) => points.every(p => p.y > 0)
            }
        };

        /**
         * Utility Functions
         */
        const utils = {
            /**
             * Parse a numeric value from various formats
             */
            parseNumericValue(value) {
                if (value === null || value === undefined || value === '') {
                    return NaN;
                }

                if (typeof value === 'number') {
                    return isNaN(value) ? NaN : value;
                }

                let stringValue = String(value).trim();
                if (stringValue === '') return NaN;

                // Replace comma with period for parseFloat
                stringValue = stringValue.replace(',', '.');

                const parsed = parseFloat(stringValue);
                return isNaN(parsed) ? NaN : parsed;
            },

            /**
             * Numeric comparison with epsilon
             */
            compareNumbers(a, b, operator) {
                const epsilon = this.calculateEpsilon(a, b);

                switch (operator) {
    case '=':
        return Math.abs(a - b) < epsilon;
    case '!=':
        return Math.abs(a - b) >= epsilon;
    case '<':
        return a < (b - epsilon);
    case '<=':
        return a <= (b + epsilon);
    case '>':
        return a > (b + epsilon);
    case '>=':
        return a >= (b - epsilon);
    default:
        return false;
}
            },

            /**
             * Calculate Y-axis range with scale type awareness
             */
            calculateYAxisRange(values, scaleType = 'r') {
                const validValues = values.filter(v => !isNaN(v) && isFinite(v));
                if (validValues.length === 0) {
                    return { min: 0, max: 10 };
                }

                let min = Math.min(...validValues);
                let max = Math.max(...validValues);

                // Only include 0 for ratio scales
                if (scaleType === 'r') {
                    if (min > 0) min = 0;
                    if (max < 0) max = 0;
                }

                // Handle case where all values are the same
                if (min === max) {
                    if (min === 0) {
                        return { min: 0, max: 1 };
                    } else if (min > 0) {
                        return { min: scaleType === 'r' ? 0 : min * 0.9, max: min * 1.1 };
                    } else {
                        return { min: min * 1.1, max: scaleType === 'r' ? 0 : min * 0.9 };
                    }
                }

                // Add small padding
                const range = max - min;
                const padding = range * 0.05;

                if (min < 0 || scaleType !== 'r') min = min - padding;
                if (max > 0 || scaleType !== 'r') max = max + padding;

                return { min, max };
            },

            /**
             * CSV delimiter detection
             */
            detectDelimiter(firstLines) {
                // Count occurrences outside of quotes
                const semicolons = (firstLines.match(/;(?=(?:[^"]*"[^"]*")*[^"]*$)/g) || []).length;
                const commas = (firstLines.match(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/g) || []).length;

                // Check for thousands separator pattern (e.g., "1,234")
                const hasThousandsSeparator = firstLines.match(/\d{1,3},\d{3}/);

                // If we have thousands separators and semicolons, use semicolon as delimiter
                if (hasThousandsSeparator && semicolons > 0) {
                    return ';';
                }

                // Check consistency across lines
                const lines = firstLines.split('\n').slice(0, 5);
                const semicolonCounts = lines.map(line => (line.match(/;(?=(?:[^"]*"[^"]*")*[^"]*$)/g) || []).length);
                const commaCounts = lines.map(line => (line.match(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/g) || []).length);

                // Check consistency
                const semicolonConsistent = semicolonCounts.every(count => count === semicolonCounts[0] && count > 0);
                const commaConsistent = commaCounts.every(count => count === commaCounts[0] && count > 0);

                if (semicolonConsistent && !commaConsistent) return ';';
                if (commaConsistent && !semicolonConsistent) return ',';

                // Default to the one with more occurrences
                return semicolons > commas ? ';' : ',';
            },

            /**
             * Run statistical test with error handling
             */
            runStatisticalTest(testFunction, ...args) {
                try {
                    // Bind the function to the statistics object to maintain context
                    const boundFunction = testFunction.bind(statistics);
                    const result = boundFunction(...args);
                    if (!result || result.error) {
                        throw new Error(result?.error || 'Test failed');
                    }
                    return result;
                } catch (error) {
                    console.error('Statistical test error:', error);
                    return null;
                }
            },

            /**
             * Display error message to the user
             */
            showError(message) {
                const errorElement = document.getElementById('error-message');
                const successElement = document.getElementById('success-message');

                successElement.style.display = 'none';
                errorElement.textContent = message;
                errorElement.style.display = 'block';

                console.error('Error:', message);

                // Auto-hide after 10 seconds
                setTimeout(() => {
                    errorElement.style.display = 'none';
                }, 10000);
            },

            /**
             * Display success message to the user
             */
            showSuccess(message) {
                const errorElement = document.getElementById('error-message');
                const successElement = document.getElementById('success-message');

                errorElement.style.display = 'none';
                successElement.textContent = message;
                successElement.style.display = 'block';

                // Auto-hide after 5 seconds
                setTimeout(() => {
                    successElement.style.display = 'none';
                }, 5000);
            },

            /**
             * Safely destroy a chart instance
             */
            destroyChart(chartId) {
                if (globalState.charts[chartId]) {
                    try {
                        globalState.charts[chartId].destroy();
                    } catch (e) {
                        console.warn('Error destroying chart:', chartId, e);
                    }
                    delete globalState.charts[chartId];
                }
            },

            /**
             * Destroy all chart instances
             */
            destroyAllCharts() {
                Object.keys(globalState.charts).forEach(chartId => {
                    this.destroyChart(chartId);
                });
            },

            /**
             * Set application loading state
             */
            setLoading(isLoading) {
                globalState.isProcessing = isLoading;
                const loadingElement = document.getElementById('loading');
                loadingElement.style.display = isLoading ? 'flex' : 'none';
            },

            /**
             * Format a number with thousands separators and fixed decimals
             */
            formatNumber(value, decimals = 2) {
                if (value === null || value === undefined || isNaN(value)) {
                    return '-';
                }

                return value.toFixed(decimals);
            },

            /**
             * Format number for CSV export using detected decimal separator
             */
            formatNumberForCSV(value, decimals = 4) {
                if (value === null || value === undefined || isNaN(value)) {
                    return '';
                }

                const formatted = value.toFixed(decimals);

                if (globalState.decimalSeparator === ',') {
                    return formatted.replace('.', ',');
                }
                return formatted;
            },

            /**
             * Export a table to CSV format
             */
            exportTableToCSV(tableId, filename) {
                const table = document.getElementById(tableId);
                if (!table) return;

                let csv = '\uFEFF'; // UTF-8 BOM for Excel

                // Get headers
                const headers = Array.from(table.querySelectorAll('thead th'))
                    .map(th => th.textContent.trim());
                csv += headers.join(globalState.csvDelimiter) + '\n';

                // Get rows
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const cells = Array.from(row.querySelectorAll('td'))
                        .map(cell => {
                            let content = cell.textContent.trim();
                            if (content.includes(globalState.csvDelimiter) || content.includes('"')) {
                                content = '"' + content.replace(/"/g, '""') + '"';
                            }
                            return content;
                        });
                    csv += cells.join(globalState.csvDelimiter) + '\n';
                });

                // Create download with timestamp
                const timestamp = this.getTimestamp();
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);

                link.setAttribute('href', url);
                link.setAttribute('download', `sra-${timestamp}-${filename}.csv`);
                link.style.visibility = 'hidden';

                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                URL.revokeObjectURL(url);
            },

            /**
             * Get timestamp for file naming
             */
            getTimestamp() {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');

                return `${year}${month}${day}-${hours}${minutes}${seconds}`;
            },

            /**
             * Generate a text representation of a group definition
             */
            groupDefinitionToText(group) {
                let text = `[${group.name}]\n`;

                // Export color (both custom and preset)
                if (group.customColor) {
                    text += `Color: ${group.customColor}\n`;
                } else if (group.colorIndex !== undefined) {
                    text += `ColorIndex: ${group.colorIndex}\n`;
                }

                // Export inclusion state
                text += `IncludeInAnalysis: ${group.includeInAnalysis !== false}\n`;

                // Export individual conditions
                if (group.conditions && group.conditions.length > 0) {
                    group.conditions.forEach((condition, index) => {
                        let conditionText = `Condition_${index + 1}: `;

                        // Always quote parameter names for consistency
                        conditionText += `"${condition.parameter}" `;
                        conditionText += `${condition.operator} `;

                        // Quote string values if they contain spaces
                        if (typeof condition.value === 'string' && condition.value.includes(' ')) {
                            conditionText += `"${condition.value}"`;
                        } else {
                            conditionText += condition.value;
                        }

                        text += conditionText + '\n';
                    });
                }

                // Export constellation references
                if (group.constellations && group.constellations.length > 0) {
                    group.constellations.forEach((constellation, index) => {
                        text += `Constellation_${index + 1}: ${constellation.name}`;
                        if (constellation.negated) {
                            text += ' [NOT]';
                        }
                        text += '\n';
                    });
                }

                // Export not-in-previous flag
                if (group.notInPrevious !== undefined) {
                    text += `NotInPrevious: ${group.notInPrevious}\n`;
                }

                text += '\n';
                return text;
            },

            /**
             * Generate text representation of a parameter constellation
             */
            constellationToText(constellation) {
                let text = `[CONSTELLATION:${constellation.name}]\n`;

                constellation.conditions.forEach((condition, index) => {
                    let conditionText = `Condition_${index + 1}: `;
                    conditionText += `"${condition.parameter}" ${condition.operator} `;

                    if (typeof condition.value === 'string' && condition.value.includes(' ')) {
                        conditionText += `"${condition.value}"`;
                    } else {
                        conditionText += condition.value;
                    }

                    text += conditionText + '\n';
                });

                text += '\n';
                return text;
            },

            /**
             * Calculate relative epsilon for floating-point comparison
             */
            calculateEpsilon(a, b) {
                const magnitude = Math.max(Math.abs(a), Math.abs(b), 1);
                return magnitude * Number.EPSILON * 100;
            },

            /**
             * Get scale type name and badge class
             */
            getScaleInfo(scaleCode) {
                const scale = scaleTypes[scaleCode];
                if (!scale) return { name: 'Unknown', class: '' };

                const classMap = {
                    'k': 'nominal',
                    'o': 'ordinal',
                    'i': 'interval',
                    'r': 'ratio'
                };

                return {
                    name: scale.name,
                    class: classMap[scaleCode] || ''
                };
            }
        };

        /**
         * Statistical Functions
         */
        const statistics = {
            /**
             * Calculate comprehensive statistical metrics for a set of values
             */
            calculate(values) {
                const validValues = values.filter(v => !isNaN(v) && isFinite(v));

                if (validValues.length === 0) {
                    return {
                        count: 0,
                        min: null,
                        max: null,
                        mean: null,
                        median: null,
                        stdDev: null,
                        variance: null,
                        q1: null,
                        q3: null,
                        iqr: null,
                        range: null,
                        sum: null,
                        cv: null
                    };
                }

                const sorted = [...validValues].sort((a, b) => a - b);
                const n = sorted.length;

                // Basic statistics
                const min = sorted[0];
                const max = sorted[n - 1];
                const range = max - min;
                const sum = validValues.reduce((acc, val) => acc + val, 0);
                const mean = sum / n;

                // Median
                let median;
                if (n % 2 === 0) {
                    median = (sorted[Math.floor(n / 2) - 1] + sorted[Math.floor(n / 2)]) / 2;
                } else {
                    median = sorted[Math.floor(n / 2)];
                }

                // Variance and standard deviation
                let variance = 0;
                let stdDev = 0;
                if (n > 1) {
                    variance = validValues.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / (n - 1);
                    stdDev = Math.sqrt(variance);
                }

                // Quartiles and IQR
                const q1 = this.quantile(sorted, 0.25);
                const q3 = this.quantile(sorted, 0.75);
                const iqr = q3 - q1;

                // Coefficient of variation (only for ratio scale with all positive values)
                let cv = null;
                // Check if all values are positive first
                const allPositive = validValues.every(v => v > 0);
                if (allPositive && mean > 0) {
                    cv = (stdDev / mean) * 100;
                }

                return {
                    count: n,
                    min: min,
                    max: max,
                    mean: mean,
                    median: median,
                    stdDev: stdDev,
                    variance: variance,
                    q1: q1,
                    q3: q3,
                    iqr: iqr,
                    range: range,
                    sum: sum,
                    cv: cv
                };
            },

            /**
             * Calculate a specific quantile from sorted data
             */
            quantile(sortedArray, q) {
                if (sortedArray.length === 0) return null;

                const pos = (sortedArray.length - 1) * q;
                const base = Math.floor(pos);
                const rest = pos - base;

                if (sortedArray[base + 1] !== undefined) {
                    return sortedArray[base] + rest * (sortedArray[base + 1] - sortedArray[base]);
                } else {
                    return sortedArray[base];
                }
            },

            /**
             * Shapiro-Wilk test for normality
             */
            shapiroWilkTest(data) {
                const validData = data.filter(v => !isNaN(v) && isFinite(v));
                const n = validData.length;

                if (n < 3) {
                    return {
                        W: null,
                        pValue: null,
                        error: 'Shapiro-Wilk test requires at least 3 observations'
                    };
                }

                if (n > 50) {
                    return {
                        W: null,
                        pValue: null,
                        error: 'Shapiro-Wilk test is designed for samples with n ≤ 50. Consider using other normality tests for larger samples.'
                    };
                }

                // Sort data
                const sorted = [...validData].sort((a, b) => a - b);

                // Calculate mean
                const mean = sorted.reduce((sum, val) => sum + val, 0) / n;

                // Calculate expected normal order statistics
                const m = [];
                for (let i = 1; i <= n; i++) {
                    const p = (i - 0.375) / (n + 0.25);
                    m.push(jStat.normal.inv(p, 0, 1));
                }

                // Calculate coefficients
                const mSum = m.reduce((sum, mi) => sum + mi * mi, 0);
                const a = m.map(mi => mi / Math.sqrt(mSum));

                // Calculate W statistic
                let num = 0;
                for (let i = 0; i < Math.floor(n / 2); i++) {
                    num += a[n - 1 - i] * (sorted[n - 1 - i] - sorted[i]);
                }

                const denom = sorted.reduce((sum, xi) => sum + Math.pow(xi - mean, 2), 0);
                const W = Math.pow(num, 2) / denom;

                // p-value approximation using Royston's method
                let z, pValue;

                if (n <= 11) {
                    // Small sample approximation
                    const gamma = -2.273 + 0.459 * Math.log(n);
                    const mu = 0.5440 - 0.39978 * Math.log(n) + 0.025054 * Math.pow(Math.log(n), 2) - 0.0006714 * Math.pow(Math.log(n), 3);
                    const sigma = Math.exp(1.3822 - 0.77857 * Math.log(n) + 0.062767 * Math.pow(Math.log(n), 2) - 0.0020322 * Math.pow(Math.log(n), 3));

                    const logW = Math.log(1 - W);
                    z = (logW - mu) / sigma;
                } else {
                    // Larger sample approximation
                    const mu = -1.5861 - 0.31082 * Math.log(n) - 0.083751 * Math.pow(Math.log(n), 2) + 0.0038915 * Math.pow(Math.log(n), 3);
                    const sigma = Math.exp(-0.4803 - 0.082676 * Math.log(n) + 0.0030302 * Math.pow(Math.log(n), 2));

                    const logW = Math.log(1 - W);
                    z = (logW - mu) / sigma;
                }

                pValue = 1 - jStat.normal.cdf(z, 0, 1);

                return {
                    W: W,
                    pValue: pValue,
                    n: n,
                    normal: pValue > 0.05
                };
            },

            /**
             * F-test for equality of variances between two groups
             */
            fTest(group1, group2) {
                const stats1 = this.calculate(group1);
                const stats2 = this.calculate(group2);

                if (stats1.count < 2 || stats2.count < 2) {
                    return {
                        F: null,
                        pValue: null,
                        error: 'F-test requires at least 2 observations in each group'
                    };
                }

                // F-statistic is ratio of larger variance to smaller variance
                const F = stats1.variance > stats2.variance ?
                    stats1.variance / stats2.variance :
                    stats2.variance / stats1.variance;

                // Degrees of freedom
                const df1 = stats1.variance > stats2.variance ? stats1.count - 1 : stats2.count - 1;
                const df2 = stats1.variance > stats2.variance ? stats2.count - 1 : stats1.count - 1;

                // Two-tailed p-value
                const pValue = 2 * Math.min(
                    jStat.centralF.cdf(F, df1, df2),
                    1 - jStat.centralF.cdf(F, df1, df2)
                );

                return {
                    F: F,
                    pValue: pValue,
                    df1: df1,
                    df2: df2,
                    equalVariances: pValue > 0.05,
                    variance1: stats1.variance,
                    variance2: stats2.variance
                };
            },

            /**
             * Mann-Whitney U test with tie correction
             */
            mannWhitneyU(group1, group2, options = {}) {
                const validGroup1 = group1.filter(v => !isNaN(v) && isFinite(v));
                const validGroup2 = group2.filter(v => !isNaN(v) && isFinite(v));

                const n1 = validGroup1.length;
                const n2 = validGroup2.length;
                const alpha = options.alpha || 0.05;

                if (n1 < 1 || n2 < 1) {
                    return {
                        error: 'Mann-Whitney U test requires at least 1 observation in each group'
                    };
                }

                // Combine and rank all observations
                const combined = [];
                validGroup1.forEach(val => combined.push({ value: val, group: 1 }));
                validGroup2.forEach(val => combined.push({ value: val, group: 2 }));

                // Sort by value
                combined.sort((a, b) => a.value - b.value);

                // Assign ranks (handle ties)
                const ranks = new Array(combined.length);
                let i = 0;
                let tieCorrection = 0;

                while (i < combined.length) {
                    let j = i;
                    let sumRanks = 0;

                    // Find all tied values
                    while (j < combined.length && combined[j].value === combined[i].value) {
                        sumRanks += j + 1; // Ranks start at 1
                        j++;
                    }

                    // Calculate tie correction factor
                    const t = j - i;
                    if (t > 1) {
                        tieCorrection += (t * t * t - t);
                    }

                    // Assign average rank to all tied values
                    const avgRank = sumRanks / t;
                    for (let k = i; k < j; k++) {
                        ranks[k] = avgRank;
                    }

                    i = j;
                }

                // Calculate rank sums
                let R1 = 0, R2 = 0;
                for (let i = 0; i < combined.length; i++) {
                    if (combined[i].group === 1) {
                        R1 += ranks[i];
                    } else {
                        R2 += ranks[i];
                    }
                }

                // Calculate U statistics
                const U1 = n1 * n2 + n1 * (n1 + 1) / 2 - R1;
                const U2 = n1 * n2 + n2 * (n2 + 1) / 2 - R2;
                const U = Math.min(U1, U2);

                // For large samples, use normal approximation
                let pValue;
                let z;
                const meanU = n1 * n2 / 2;
                const N = n1 + n2;

                // Standard deviation with tie correction
                const sdU = Math.sqrt(n1 * n2 * (N + 1 - tieCorrection / (N * (N - 1))) / 12);

                if (n1 >= 20 && n2 >= 20) {
                    // Calculate z-score with continuity correction
                    if (options.direction === 'two-sided' || !options.direction) {
                        // For two-sided test, use smaller U with continuity correction
                        z = (Math.abs(U - meanU) - 0.5) / sdU;
                        pValue = 2 * (1 - jStat.normal.cdf(Math.abs(z), 0, 1));
                    } else if (options.direction === 'left') {
                        // Left-tailed: testing if group1 < group2
                        // When group1 < group2, group1 has smaller ranks, so U1 is smaller
                        z = (U1 - meanU + 0.5) / sdU;
                        pValue = jStat.normal.cdf(z, 0, 1);
                    } else if (options.direction === 'right') {
                        // Right-tailed: testing if group1 > group2  
                        // When group1 > group2, group1 has larger ranks, so U1 is larger
                        // Use negative continuity correction for right tail
                        z = (U1 - meanU - 0.5) / sdU;
                        pValue = 1 - jStat.normal.cdf(z, 0, 1);
                    }
                } else {
                    // For small samples, use exact calculation (simplified)
                    const criticalU = this.getMannWhitneyCriticalValue(n1, n2, alpha);
                    pValue = U <= criticalU ? alpha : 1 - alpha;
                }

                // Calculate effect size (r = Z / sqrt(N))
                // For effect size, always use two-tailed z-score
                const zTwoTailed = (U - n1 * n2 / 2) / sdU;
                const effectSize = Math.abs(zTwoTailed) / Math.sqrt(N);

                return {
                    test: 'Mann-Whitney U',
                    U: U,
                    U1: U1,
                    U2: U2,
                    pValue: pValue,
                    significant: pValue < alpha,
                    alpha: alpha,
                    n1: n1,
                    n2: n2,
                    rankSum1: R1,
                    rankSum2: R2,
                    effectSize: effectSize,
                    direction: options.direction || 'two-sided',
                    tieCorrection: tieCorrection > 0
                };
            },

            /**
             * Get critical value for Mann-Whitney U test (simplified)
             */
            getMannWhitneyCriticalValue(n1, n2, alpha) {
                // This is a simplified approximation
                const meanU = n1 * n2 / 2;
                const sdU = Math.sqrt(n1 * n2 * (n1 + n2 + 1) / 12);
                const z = jStat.normal.inv(alpha / 2, 0, 1);
                return Math.floor(meanU + z * sdU);
            },

            /**
             * Kruskal-Wallis test for multiple independent samples
             */
            kruskalWallis(groups, options = {}) {
                const alpha = options.alpha || 0.05;

                // Filter and validate groups
                const validGroups = groups.map(group =>
                    group.filter(v => !isNaN(v) && isFinite(v))
                ).filter(group => group.length > 0);

                if (validGroups.length < 2) {
                    return {
                        error: 'Kruskal-Wallis test requires at least 2 groups'
                    };
                }

                // Combine all observations with group labels
                const combined = [];
                validGroups.forEach((group, groupIndex) => {
                    group.forEach(val => {
                        combined.push({ value: val, group: groupIndex });
                    });
                });

                const N = combined.length;

                // Sort and assign ranks
                combined.sort((a, b) => a.value - b.value);

                // Assign ranks (handle ties)
                const ranks = new Array(N);
                let i = 0;
                let tieCorrection = 0;

                while (i < N) {
                    let j = i;
                    let sumRanks = 0;

                    // Find all tied values
                    while (j < N && combined[j].value === combined[i].value) {
                        sumRanks += j + 1;
                        j++;
                    }

                    // Calculate tie correction
                    const t = j - i;
                    if (t > 1) {
                        tieCorrection += (t * t * t - t);
                    }

                    // Assign average rank
                    const avgRank = sumRanks / t;
                    for (let k = i; k < j; k++) {
                        ranks[k] = avgRank;
                    }

                    i = j;
                }

                // Calculate rank sums for each group
                const groupRankSums = new Array(validGroups.length).fill(0);
                const groupSizes = validGroups.map(g => g.length);

                for (let i = 0; i < N; i++) {
                    groupRankSums[combined[i].group] += ranks[i];
                }

                // Calculate H statistic
                let H = 0;
                for (let i = 0; i < validGroups.length; i++) {
                    H += (groupRankSums[i] * groupRankSums[i]) / groupSizes[i];
                }
                H = (12 / (N * (N + 1))) * H - 3 * (N + 1);

                // Apply tie correction
                if (tieCorrection > 0) {
                    H = H / (1 - tieCorrection / (N * N * N - N));
                }

                // Degrees of freedom
                const df = validGroups.length - 1;

                // P-value from chi-square distribution
                const pValue = 1 - jStat.chisquare.cdf(H, df);

                // Effect size (eta-squared)
                const etaSquared = (H - df) / (N - df);

                return {
                    test: 'Kruskal-Wallis',
                    H: H,
                    pValue: pValue,
                    df: df,
                    significant: pValue < alpha,
                    alpha: alpha,
                    groupSizes: groupSizes,
                    groupRankSums: groupRankSums,
                    etaSquared: etaSquared > 0 ? etaSquared : 0,
                    N: N,
                    tieCorrection: tieCorrection > 0
                };
            },

            /**
             * Spearman rank correlation
             */
            spearmanCorrelation(x, y, options = {}) {
                const alpha = options.alpha || 0.05;

                // Pair up values and filter out pairs with any invalid values
                const pairs = [];
                for (let i = 0; i < Math.min(x.length, y.length); i++) {
                    if (!isNaN(x[i]) && !isNaN(y[i]) && isFinite(x[i]) && isFinite(y[i])) {
                        pairs.push({ x: x[i], y: y[i] });
                    }
                }

                const n = pairs.length;

                if (n < 3) {
                    return {
                        error: 'Spearman correlation requires at least 3 paired observations'
                    };
                }

                // Rank x values
                const xRanks = this.getRanks(pairs.map(p => p.x));
                const yRanks = this.getRanks(pairs.map(p => p.y));

                // Calculate rank differences
                let sumD2 = 0;
                for (let i = 0; i < n; i++) {
                    const d = xRanks[i] - yRanks[i];
                    sumD2 += d * d;
                }

                // Spearman's rho
                const rho = 1 - (6 * sumD2) / (n * (n * n - 1));

                // Test significance using t-distribution
                const t = rho * Math.sqrt((n - 2) / (1 - rho * rho));
                const df = n - 2;
                const pValue = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df));

                // Calculate power
                const power = this.calculateCorrelationPower(rho, n, alpha);

                return {
                    test: 'Spearman Correlation',
                    rho: rho,
                    pValue: pValue,
                    significant: pValue < alpha,
                    alpha: alpha,
                    n: n,
                    interpretation: this.interpretCorrelation(rho),
                    power: power
                };
            },

            /**
             * Helper function to calculate ranks for an array
             */
            getRanks(values) {
                const n = values.length;
                const indexed = values.map((val, idx) => ({ value: val, index: idx }));
                indexed.sort((a, b) => a.value - b.value);

                const ranks = new Array(n);
                let i = 0;

                while (i < n) {
                    let j = i;
                    let sumRanks = 0;

                    // Find all tied values
                    while (j < n && indexed[j].value === indexed[i].value) {
                        sumRanks += j + 1;
                        j++;
                    }

                    // Assign average rank
                    const avgRank = sumRanks / (j - i);
                    for (let k = i; k < j; k++) {
                        ranks[indexed[k].index] = avgRank;
                    }

                    i = j;
                }

                return ranks;
            },

            /**
             * Interpret correlation coefficient
             */
            interpretCorrelation(r) {
                const absR = Math.abs(r);
                let strength;

                if (absR < 0.1) strength = 'negligible';
                else if (absR < 0.3) strength = 'weak';
                else if (absR < 0.5) strength = 'moderate';
                else if (absR < 0.7) strength = 'strong';
                else strength = 'very strong';

                const direction = r > 0 ? 'positive' : 'negative';

                return `${strength} ${direction} correlation`;
            },

            /**
             * Welch's t-test for two groups with unequal variances
             */
            welchTTest(group1, group2, options = {}) {
                const stats1 = this.calculate(group1);
                const stats2 = this.calculate(group2);

                const alpha = options.alpha || 0.05;
                const direction = options.direction || 'two-sided';

                if (stats1.count < 2 || stats2.count < 2) {
                    return {
                        error: "Welch's t-test requires at least 2 observations in each group"
                    };
                }

                // Welch's t-statistic
                const se = Math.sqrt(stats1.variance / stats1.count + stats2.variance / stats2.count);
                const t = (stats1.mean - stats2.mean) / se;

                // Welch-Satterthwaite degrees of freedom
                const num = Math.pow(stats1.variance / stats1.count + stats2.variance / stats2.count, 2);
                const denom = Math.pow(stats1.variance / stats1.count, 2) / (stats1.count - 1) +
                    Math.pow(stats2.variance / stats2.count, 2) / (stats2.count - 1);
                const df = num / denom;

                // Calculate p-value
                let pValue;
                if (direction === 'two-sided') {
                    pValue = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df));
                } else if (direction === 'left') {
                    pValue = jStat.studentt.cdf(t, df);
                } else if (direction === 'right') {
                    pValue = 1 - jStat.studentt.cdf(t, df);
                }

                // Effect size (Cohen's d using pooled standard deviation)
                const pooledSD = Math.sqrt((stats1.variance + stats2.variance) / 2);
                const effectSize = Math.abs(stats1.mean - stats2.mean) / pooledSD;

                // Confidence interval
                const criticalT = jStat.studentt.inv(1 - alpha / 2, df);
                const meanDiff = stats1.mean - stats2.mean;
                const ciLower = meanDiff - criticalT * se;
                const ciUpper = meanDiff + criticalT * se;

                // Calculate power
                const power = this.calculatePowerNumerical(effectSize, stats1.count, stats2.count, alpha, 'welch');

                return {
                    test: "Welch's t-Test",
                    statistic: t,
                    pValue: pValue,
                    df: df,
                    significant: pValue < alpha,
                    alpha: alpha,
                    direction: direction,
                    group1Stats: stats1,
                    group2Stats: stats2,
                    effectSize: effectSize,
                    meanDifference: meanDiff,
                    confidenceInterval: [ciLower, ciUpper],
                    confidenceLevel: 1 - alpha,
                    power: power
                };
            },

            /**
             * Fisher's exact test for 2x2 contingency tables
             */
            fisherExactTest(table, options = {}) {
                const alpha = options.alpha || 0.05;

                if (table.length !== 2 || table[0].length !== 2 || table[1].length !== 2) {
                    return {
                        error: "Fisher's exact test requires a 2x2 contingency table"
                    };
                }

                const a = table[0][0];
                const b = table[0][1];
                const c = table[1][0];
                const d = table[1][1];

                // Validate table values are non-negative
                if (a < 0 || b < 0 || c < 0 || d < 0) {
                    return {
                        error: "Table values must be non-negative"
                    };
                }

                // Check for large sample size
                const n = a + b + c + d;

                if (n > 200) {
                    return {
                        error: "Fisher's exact test is not recommended for n > 200. Use Chi-square test instead."
                    };
                }

                // Calculate hypergeometric probability for observed table
                const pObserved = this.hypergeometricProbability(a, b, c, d);

                // Calculate two-tailed p-value
                // Sum probabilities of all tables as extreme or more extreme
                let pValue = 0;
                const rowSum1 = a + b;
                const colSum1 = a + c;

                for (let i = 0; i <= Math.min(rowSum1, colSum1); i++) {
                    const prob = this.hypergeometricProbability(
                        i,
                        rowSum1 - i,
                        colSum1 - i,
                        n - rowSum1 - colSum1 + i
                    );

                    if (prob <= pObserved + 1e-10) { // Small epsilon for floating point comparison
                        pValue += prob;
                    }
                }

                // Odds ratio
                const oddsRatio = (a * d) / (b * c);

                return {
                    test: "Fisher's Exact Test",
                    pValue: pValue,
                    significant: pValue < alpha,
                    alpha: alpha,
                    oddsRatio: oddsRatio,
                    table: [[a, b], [c, d]]
                };
            },

            /**
             * Calculate hypergeometric probability for Fisher's exact test
             */
            hypergeometricProbability(a, b, c, d) {
                const n = a + b + c + d;

                // Use logarithms to avoid overflow
                const logProb =
                    this.logFactorial(a + b) +
                    this.logFactorial(c + d) +
                    this.logFactorial(a + c) +
                    this.logFactorial(b + d) -
                    this.logFactorial(n) -
                    this.logFactorial(a) -
                    this.logFactorial(b) -
                    this.logFactorial(c) -
                    this.logFactorial(d);

                return Math.exp(logProb);
            },

            /**
             * Calculate log factorial
             */
            logFactorial(n) {
                if (n <= 1) return 0;
                let sum = 0;
                for (let i = 2; i <= n; i++) {
                    sum += Math.log(i);
                }
                return sum;
            },

            /**
             * Calculate linear regression for a set of x,y points
             */
            linearRegression(points) {
                const validPoints = points.filter(p => !isNaN(p.x) && !isNaN(p.y) && isFinite(p.x) && isFinite(p.y));

                if (validPoints.length < 2) {
                    return null;
                }

                const n = validPoints.length;
                const sumX = validPoints.reduce((sum, p) => sum + p.x, 0);
                const sumY = validPoints.reduce((sum, p) => sum + p.y, 0);
                const sumXY = validPoints.reduce((sum, p) => sum + (p.x * p.y), 0);
                const sumXX = validPoints.reduce((sum, p) => sum + (p.x * p.x), 0);
                const sumYY = validPoints.reduce((sum, p) => sum + (p.y * p.y), 0);

                const meanX = sumX / n;
                const meanY = sumY / n;

                // Calculate slope and intercept
                const numerator = sumXY - (sumX * sumY / n);
                const denominator = sumXX - (sumX * sumX / n);

                if (Math.abs(denominator) < Number.EPSILON) {
                    // Vertical line case
                    return null;
                }

                const slope = numerator / denominator;
                const intercept = meanY - slope * meanX;

                // Calculate correlation coefficient (r)
                const numeratorR = n * sumXY - sumX * sumY;
                const denominatorR = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));

                let r = 0;
                if (Math.abs(denominatorR) > Number.EPSILON) {
                    r = numeratorR / denominatorR;
                }

                const r2 = r * r;

                // Calculate standard error of estimate
                let standardError = 0;
                if (n > 2) {
                    const residualSumSquares = validPoints.reduce((sum, p) => {
                        const predicted = slope * p.x + intercept;
                        return sum + Math.pow(p.y - predicted, 2);
                    }, 0);
                    standardError = Math.sqrt(residualSumSquares / (n - 2));
                }

                return {
                    slope: slope,
                    intercept: intercept,
                    r: r,
                    r2: r2,
                    n: n,
                    standardError: standardError,
                    equation: `y = ${slope.toFixed(4)}x + ${intercept.toFixed(4)}`,
                    points: validPoints,
                    predict: (x) => slope * x + intercept
                };
            },

            /**
             * Calculate polynomial regression with stability checking
             */
            polynomialRegression(points, order) {
                const validPoints = points.filter(p => !isNaN(p.x) && !isNaN(p.y) && isFinite(p.x) && isFinite(p.y));

                if (validPoints.length < order + 1) {
                    return null;
                }

                // Create matrices for least squares
                const n = validPoints.length;
                const matrix = [];
                const vector = [];

                for (let i = 0; i <= order; i++) {
                    matrix[i] = [];
                    vector[i] = 0;

                    for (let j = 0; j <= order; j++) {
                        matrix[i][j] = 0;
                        validPoints.forEach(p => {
                            matrix[i][j] += Math.pow(p.x, i + j);
                        });
                    }

                    validPoints.forEach(p => {
                        vector[i] += p.y * Math.pow(p.x, i);
                    });
                }

                // Check matrix condition
                const condition = this.checkMatrixCondition(matrix);
                if (!condition.stable) {
                    console.warn('Polynomial regression matrix is ill-conditioned:', condition.message);
                }

                // Solve using Gaussian elimination
                const coefficients = this.gaussianElimination(matrix, vector);

                if (!coefficients) {
                    return null;
                }

                // Calculate R²
                const meanY = validPoints.reduce((sum, p) => sum + p.y, 0) / n;
                let ssTotal = 0;
                let ssResidual = 0;

                validPoints.forEach(p => {
                    let predicted = 0;
                    for (let i = 0; i <= order; i++) {
                        predicted += coefficients[i] * Math.pow(p.x, i);
                    }

                    ssTotal += Math.pow(p.y - meanY, 2);
                    ssResidual += Math.pow(p.y - predicted, 2);
                });

                const r2 = 1 - (ssResidual / ssTotal);

                // Generate equation string
                let equation = 'y = ';
                const terms = [];

                for (let i = order; i >= 0; i--) {
                    const coef = coefficients[i];
                    if (Math.abs(coef) < 0.0001) continue;

                    let term = '';

                    if (terms.length > 0) {
                        term += coef >= 0 ? ' + ' : ' - ';
                        term += Math.abs(coef).toFixed(4);
                    } else {
                        term += coef.toFixed(4);
                    }

                    if (i > 1) {
                        term += `x^${i}`;
                    } else if (i === 1) {
                        term += 'x';
                    }

                    terms.push(term);
                }

                equation += terms.join('');

                return {
                    coefficients: coefficients,
                    r2: r2,
                    n: n,
                    order: order,
                    equation: equation,
                    points: validPoints,
                    conditionNumber: condition.conditionNumber,
                    predict: (x) => {
                        let y = 0;
                        for (let i = 0; i <= order; i++) {
                            y += coefficients[i] * Math.pow(x, i);
                        }
                        return y;
                    }
                };
            },

            /**
             * Check matrix condition number
             */
            checkMatrixCondition(matrix) {
                const n = matrix.length;
                let maxRowSum = 0;
                let minRowSum = Infinity;

                for (let i = 0; i < n; i++) {
                    let rowSum = 0;
                    for (let j = 0; j < n; j++) {
                        rowSum += Math.abs(matrix[i][j]);
                    }
                    maxRowSum = Math.max(maxRowSum, rowSum);
                    minRowSum = Math.min(minRowSum, rowSum);
                }

                const conditionNumber = minRowSum > 0 ? maxRowSum / minRowSum : Infinity;

                if (conditionNumber > 30) {
                    return {
                        stable: false,
                        conditionNumber: conditionNumber,
                        message: 'Matrix is ill-conditioned, results may be unreliable'
                    };
                }

                return { stable: true, conditionNumber: conditionNumber };
            },

            /**
             * Gaussian elimination for solving linear equations
             */
            gaussianElimination(matrix, vector) {
                const n = matrix.length;
                const augmented = matrix.map((row, i) => [...row, vector[i]]);

                // Forward elimination with partial pivoting
                for (let i = 0; i < n; i++) {
                    // Find pivot
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                            maxRow = k;
                        }
                    }

                    // Swap rows
                    [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

                    // Check for zero pivot
                    if (Math.abs(augmented[i][i]) < Number.EPSILON) {
                        return null;
                    }

                    // Make all rows below this one 0 in current column
                    for (let k = i + 1; k < n; k++) {
                        const factor = augmented[k][i] / augmented[i][i];
                        for (let j = i; j <= n; j++) {
                            augmented[k][j] -= factor * augmented[i][j];
                        }
                    }
                }

                // Back substitution
                const solution = new Array(n);
                for (let i = n - 1; i >= 0; i--) {
                    solution[i] = augmented[i][n];
                    for (let j = i + 1; j < n; j++) {
                        solution[i] -= augmented[i][j] * solution[j];
                    }
                    solution[i] /= augmented[i][i];
                }

                return solution;
            },

            /**
             * Calculate logarithmic regression
             */
            logarithmicRegression(points) {
                // Filter valid points and ensure x > 0 for logarithm
                const validPoints = points.filter(p =>
                    !isNaN(p.x) && !isNaN(p.y) && isFinite(p.x) && isFinite(p.y) && p.x > 0
                );

                if (validPoints.length < 2) {
                    return null;
                }

                // Transform x values to ln(x)
                const transformedPoints = validPoints.map(p => ({
                    x: Math.log(p.x),
                    y: p.y
                }));

                // Perform linear regression on transformed data
                const linear = this.linearRegression(transformedPoints);

                if (!linear) {
                    return null;
                }

                const a = linear.slope;
                const b = linear.intercept;

                return {
                    a: a,
                    b: b,
                    r2: linear.r2,
                    n: linear.n,
                    equation: `y = ${a.toFixed(4)}·ln(x) + ${b.toFixed(4)}`,
                    points: validPoints,
                    predict: (x) => a * Math.log(x) + b
                };
            },

            /**
             * Calculate exponential regression
             */
            exponentialRegression(points) {
                // Filter valid points and ensure y > 0 for logarithm
                const validPoints = points.filter(p =>
                    !isNaN(p.x) && !isNaN(p.y) && isFinite(p.x) && isFinite(p.y) && p.y > 0
                );

                if (validPoints.length < 2) {
                    return null;
                }

                // Transform y values to ln(y)
                const transformedPoints = validPoints.map(p => ({
                    x: p.x,
                    y: Math.log(p.y)
                }));

                // Perform linear regression on transformed data
                const linear = this.linearRegression(transformedPoints);

                if (!linear) {
                    return null;
                }

                const b = linear.slope;
                const lnA = linear.intercept;
                const a = Math.exp(lnA);

                // Calculate R² on original scale
                const meanY = validPoints.reduce((sum, p) => sum + p.y, 0) / validPoints.length;
                let ssTotal = 0;
                let ssResidual = 0;

                validPoints.forEach(p => {
                    const predicted = a * Math.exp(b * p.x);
                    ssTotal += Math.pow(p.y - meanY, 2);
                    ssResidual += Math.pow(p.y - predicted, 2);
                });

                const r2 = 1 - (ssResidual / ssTotal);

                return {
                    a: a,
                    b: b,
                    r2: r2,
                    n: linear.n,
                    equation: `y = ${a.toFixed(4)}·e^(${b.toFixed(4)}x)`,
                    points: validPoints,
                    predict: (x) => a * Math.exp(b * x)
                };
            },

            /**
             * Test regression significance
             */
            testRegressionSignificance(regression, type, alpha = 0.05) {
                if (!regression || !regression.n || regression.n < 3) {
                    return {
                        significant: false,
                        error: 'Insufficient data for significance testing'
                    };
                }

                let result = {
                    significant: false,
                    alpha: alpha,
                    n: regression.n
                };

                if (type === 'linear' || type === 'logarithmic' || type === 'exponential') {
                    // For simple regression, test if slope is significantly different from 0
                    const df = regression.n - 2;

                    // Use R² to calculate F-statistic
                    const fStat = (regression.r2 / (1 - regression.r2)) * df;
                    const pValue = 1 - jStat.centralF.cdf(fStat, 1, df);

                    result.fStatistic = fStat;
                    result.pValue = pValue;
                    result.significant = pValue < alpha;
                    result.df1 = 1;
                    result.df2 = df;

                } else if (type === 'polynomial2' || type === 'polynomial3') {
                    // For polynomial regression, use F-test
                    const k = regression.order; // number of predictors
                    const df1 = k;
                    const df2 = regression.n - k - 1;

                    // Calculate F-statistic from R²
                    const fStat = (regression.r2 / df1) / ((1 - regression.r2) / df2);
                    const pValue = 1 - jStat.centralF.cdf(fStat, df1, df2);

                    result.fStatistic = fStat;
                    result.pValue = pValue;
                    result.significant = pValue < alpha;
                    result.df1 = df1;
                    result.df2 = df2;
                }

                return result;
            },

            /**
             * Perform Student's t-test between two groups
             */
            tTest(group1, group2, options = {}) {
                const stats1 = this.calculate(group1);
                const stats2 = this.calculate(group2);

                const alpha = options.alpha || 0.05;
                const direction = options.direction || 'two-sided';

                if (stats1.count < 2 || stats2.count < 2) {
                    return null;
                }

                // Calculate pooled variance
                const pooledVariance = ((stats1.count - 1) * stats1.variance + (stats2.count - 1) * stats2.variance)
                    / (stats1.count + stats2.count - 2);

                // Calculate t-statistic
                const t = (stats1.mean - stats2.mean) /
                    Math.sqrt(pooledVariance * (1 / stats1.count + 1 / stats2.count));

                // Degrees of freedom
                const df = stats1.count + stats2.count - 2;

                // Calculate p-value based on test direction
                let pValue;

                if (direction === 'two-sided') {
                    pValue = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df));
                } else if (direction === 'left') {
                    pValue = jStat.studentt.cdf(t, df);
                } else if (direction === 'right') {
                    pValue = 1 - jStat.studentt.cdf(t, df);
                } else {
                    pValue = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df));
                }

                // Calculate effect size (Cohen's d)
                const effectSize = Math.abs(stats1.mean - stats2.mean) / Math.sqrt(pooledVariance);

                // Calculate confidence intervals
                const criticalT = jStat.studentt.inv(1 - alpha / 2, df);
                const se = Math.sqrt(pooledVariance * (1 / stats1.count + 1 / stats2.count));
                const meanDiff = stats1.mean - stats2.mean;
                const ciLower = meanDiff - criticalT * se;
                const ciUpper = meanDiff + criticalT * se;

                // Calculate power
                const power = this.calculatePowerNumerical(effectSize, stats1.count, stats2.count, alpha, 'ttest');

                return {
                    test: 't-Test',
                    statistic: t,
                    pValue: pValue,
                    df: df,
                    significant: pValue < alpha,
                    alpha: alpha,
                    direction: direction,
                    group1Stats: stats1,
                    group2Stats: stats2,
                    effectSize: effectSize,
                    meanDifference: meanDiff,
                    confidenceInterval: [ciLower, ciUpper],
                    confidenceLevel: 1 - alpha,
                    power: power
                };
            },

            /**
             * Perform Analysis of Variance (ANOVA) across multiple groups
             */
            anova(groups, options = {}) {
                const validGroups = groups.filter(group => group.length > 0);
                const alpha = options.alpha || 0.05;

                if (validGroups.length < 2) return null;

                // Combine all values for overall statistics
                const allValues = [].concat(...validGroups);
                const overallMean = allValues.reduce((sum, val) => sum + val, 0) / allValues.length;

                // Calculate sum of squares
                let ssb = 0; // Sum of squares between groups
                let ssw = 0; // Sum of squares within groups

                // Group means and counts
                const groupStats = validGroups.map(group => {
                    const mean = group.reduce((sum, val) => sum + val, 0) / group.length;
                    return {
                        n: group.length,
                        mean: mean
                    };
                });

                // Calculate sum of squares
                validGroups.forEach((group, i) => {
                    const groupMean = groupStats[i].mean;

                    // Between groups
                    ssb += group.length * Math.pow(groupMean - overallMean, 2);

                    // Within groups
                    group.forEach(val => {
                        ssw += Math.pow(val - groupMean, 2);
                    });
                });

                // Degrees of freedom
                const dfb = validGroups.length - 1;
                const dfw = allValues.length - validGroups.length;

                // Mean squares
                const msb = ssb / dfb;
                const msw = ssw / dfw;

                // F statistic
                const f = msb / msw;

                // P-value
                const pValue = 1 - jStat.centralF.cdf(f, dfb, dfw);

                // Effect size (eta-squared)
                const etaSquared = ssb / (ssb + ssw);

                // Calculate power
                const power = this.calculateANOVAPower(etaSquared, validGroups.length, allValues.length, alpha);

                return {
                    test: 'ANOVA',
                    statistic: f,
                    pValue: pValue,
                    dfBetween: dfb,
                    dfWithin: dfw,
                    significant: pValue < alpha,
                    alpha: alpha,
                    ssb: ssb,
                    ssw: ssw,
                    msb: msb,
                    msw: msw,
                    etaSquared: etaSquared,
                    groupStats: groupStats,
                    power: power
                };
            },

            /**
             * Calculate power for ANOVA test
             */
            calculateANOVAPower(etaSquared, k, n, alpha) {
                // Convert eta-squared to Cohen's f
                const f = Math.sqrt(etaSquared / (1 - etaSquared));

                // Non-centrality parameter
                const lambda = f * f * n;

                // Degrees of freedom
                const df1 = k - 1;
                const df2 = n - k;

                // Critical F value
                const criticalF = jStat.centralF.inv(1 - alpha, df1, df2);

                // Power approximation using non-central F distribution
                let power = 1 - jStat.centralF.cdf(criticalF - lambda / df1, df1, df2);

                // Ensure power is between 0 and 1
                power = Math.max(0, Math.min(1, power));

                return power;
            },

            /**
             * Power calculation using numerical integration
             */
            calculatePowerNumerical(effectSize, n1, n2, alpha, testType) {
                const df = n1 + n2 - 2;
                // Correct non-centrality parameter
                const ncp = effectSize * Math.sqrt(n1 * n2 / (n1 + n2));
                const criticalT = jStat.studentt.inv(1 - alpha / 2, df);

                // Numerical integration using Simpson's rule
                const steps = 100;
                const range = 10;
                const h = 2 * range / steps;

                let power = 0;
                for (let i = 0; i <= steps; i++) {
                    const t = -range + i * h;
                    const weight = (i === 0 || i === steps) ? 1 : (i % 2 === 0 ? 2 : 4);

                    // Approximate non-central t density
                    const shift = t - ncp;
                    const density = jStat.studentt.pdf(shift, df);

                    if (Math.abs(t) > criticalT) {
                        power += weight * density;
                    }
                }

                power = power * h / 3; // Simpson's rule factor
                return Math.min(0.999, Math.max(0.001, power));
            },

            /**
             * Calculate power for correlation test
             */
            calculateCorrelationPower(r, n, alpha) {
                // Fisher's z transformation
                const z = 0.5 * Math.log((1 + r) / (1 - r));

                // Standard error of z
                const seZ = 1 / Math.sqrt(n - 3);

                // Critical z value
                const zCritical = jStat.normal.inv(1 - alpha / 2, 0, 1);

                // Power calculation
                const power = 1 - jStat.normal.cdf(zCritical - Math.abs(z) / seZ, 0, 1) +
                    jStat.normal.cdf(-zCritical - Math.abs(z) / seZ, 0, 1);

                return Math.max(0, Math.min(1, power));
            },

            /**
             * Perform Chi-Square Test for categorical data
             */
            chiSquareTest(paramName, groupData, options = {}) {
                const alpha = options.alpha || 0.05;

                // Get unique categories for the parameter
                const categories = [...new Set(globalState.rawData
                    .map(row => row[paramName])
                    .filter(val => val !== null && val !== undefined && val !== ''))];

                // Get group IDs
                const groupIds = Object.keys(groupData);

                // Need at least 2 categories and 1 group for the test
                if (categories.length < 2 || groupIds.length < 1) {
                    return {
                        error: "Chi-Square test requires at least 2 categories and 1 group"
                    };
                }

                // Create contingency table
                const observed = [];
                const rowTotals = [];
                const colTotals = Array(groupIds.length).fill(0);
                let totalCount = 0;

                // Build observed frequencies table
                categories.forEach(category => {
                    const row = [];
                    let rowTotal = 0;

                    groupIds.forEach((groupId, colIndex) => {
                        const count = groupData[groupId].filter(record =>
                            String(record[paramName]) === String(category)
                        ).length;

                        row.push(count);
                        rowTotal += count;
                        colTotals[colIndex] += count;
                        totalCount += count;
                    });

                    observed.push(row);
                    rowTotals.push(rowTotal);
                });

                // Calculate expected frequencies
                const expected = [];
                for (let i = 0; i < categories.length; i++) {
                    const expectRow = [];
                    for (let j = 0; j < groupIds.length; j++) {
                        expectRow.push((rowTotals[i] * colTotals[j]) / totalCount);
                    }
                    expected.push(expectRow);
                }

                // Check if we have any expected frequencies less than 5
                let hasLowExpected = false;
                for (let i = 0; i < expected.length; i++) {
                    for (let j = 0; j < expected[i].length; j++) {
                        if (expected[i][j] < 5) {
                            hasLowExpected = true;
                            break;
                        }
                    }
                    if (hasLowExpected) break;
                }

                // Calculate chi-square statistic
                let chiSquare = 0;
                let hasZeroExpected = false;
                for (let i = 0; i < observed.length; i++) {
                    for (let j = 0; j < observed[i].length; j++) {
                        const o = observed[i][j];
                        const e = expected[i][j];

                        if (e === 0) {
                            hasZeroExpected = true;
                            // Cannot compute chi-square with zero expected
                            // Use a small value to avoid division by zero
                            chiSquare += Math.pow(o - e, 2) / 0.0001;
                        } else {
                            chiSquare += Math.pow(o - e, 2) / e;
                        }
                    }
                }

                // Add warning if zero expected values
                if (hasZeroExpected) {
                    hasLowExpected = true;
                }

                // Degrees of freedom
                const df = (categories.length - 1) * (groupIds.length - 1);

                // Calculate p-value
                const pValue = 1 - jStat.chisquare.cdf(chiSquare, df);

                // Calculate Cramer's V (effect size)
                const minDim = Math.min(categories.length - 1, groupIds.length - 1);
                const cramersV = Math.sqrt(chiSquare / (totalCount * minDim));

                // Calculate power
                const power = this.calculateChiSquarePower(chiSquare, df, totalCount, alpha);

                return {
                    test: 'Chi-Square',
                    statistic: chiSquare,
                    pValue: pValue,
                    df: df,
                    significant: pValue < alpha,
                    alpha: alpha,
                    cramersV: cramersV,
                    observed: observed,
                    expected: expected,
                    categories: categories,
                    groups: groupIds.map(id => globalState.currentGroups[id].name),
                    warning: hasLowExpected ? 'Some expected frequencies are less than 5, consider using Fisher\'s exact test.' : null,
                    power: power
                };
            },

            /**
             * Calculate power for chi-square test
             */
            calculateChiSquarePower(chiSquare, df, n, alpha) {
                // Non-centrality parameter
                const lambda = chiSquare;

                // Critical chi-square value
                const criticalChi = jStat.chisquare.inv(1 - alpha, df);

                // Power approximation
                let power = 1 - jStat.chisquare.cdf(criticalChi - lambda, df);

                // Ensure power is between 0 and 1
                power = Math.max(0, Math.min(1, power));

                return power;
            },

            /**
             * Perform Pearson correlation test
             */
            pearsonCorrelation(x, y, options = {}) {
                const alpha = options.alpha || 0.05;

                // Create regression points
                const points = [];
                for (let i = 0; i < Math.min(x.length, y.length); i++) {
                    if (!isNaN(x[i]) && !isNaN(y[i]) && isFinite(x[i]) && isFinite(y[i])) {
                        points.push({ x: x[i], y: y[i] });
                    }
                }

                if (points.length < 3) {
                    return {
                        error: 'Pearson correlation requires at least 3 paired observations'
                    };
                }

                // Use linear regression to get correlation
                const regression = this.linearRegression(points);

                if (!regression) {
                    return {
                        error: 'Unable to calculate correlation'
                    };
                }

                const r = regression.r;
                const n = regression.n;

                // Test significance using t-distribution
                const t = r * Math.sqrt((n - 2) / (1 - r * r));
                const df = n - 2;
                const pValue = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df));

                // Calculate power for correlation
                const power = this.calculateCorrelationPower(r, n, alpha);

                return {
                    test: 'Pearson Correlation',
                    r: r,
                    r2: r * r,
                    pValue: pValue,
                    significant: pValue < alpha,
                    alpha: alpha,
                    n: n,
                    interpretation: this.interpretCorrelation(r),
                    power: power
                };
            },

            /**
             * Calculate fourfold table statistics
             */
            calculateFourfoldStatistics(table) {
                const a = table[0][0];
                const b = table[0][1];
                const c = table[1][0];
                const d = table[1][1];
                const n = a + b + c + d;

                // Basic proportions
                const p1 = (a + b) / n;
                const p2 = (c + d) / n;
                const q1 = (a + c) / n;
                const q2 = (b + d) / n;

                // Risk measures
                const risk1 = a / (a + b);
                const risk2 = c / (c + d);
                const riskRatio = risk1 / risk2;
                const riskDifference = risk1 - risk2;

                // Odds ratio with zero handling
                let oddsRatio;
                if (b === 0 || c === 0) {
                    if (a > 0 && d > 0 && b === 0 && c === 0) {
                        oddsRatio = Infinity;
                    } else if (a === 0 && d === 0) {
                        oddsRatio = NaN;
                    } else {
                        // Add 0.5 to all cells (Haldane correction)
                        oddsRatio = ((a + 0.5) * (d + 0.5)) / ((b + 0.5) * (c + 0.5));
                    }
                } else {
                    oddsRatio = (a * d) / (b * c);
                }
                const logOddsRatio = Math.log(oddsRatio);

                // Standard errors
                const seLogOR = Math.sqrt(1 / a + 1 / b + 1 / c + 1 / d);
                const seRiskDiff = Math.sqrt(risk1 * (1 - risk1) / (a + b) + risk2 * (1 - risk2) / (c + d));

                // Confidence intervals (95%)
                const z = 1.96;
                const orCI = [
                    Math.exp(logOddsRatio - z * seLogOR),
                    Math.exp(logOddsRatio + z * seLogOR)
                ];
                const rdCI = [
                    riskDifference - z * seRiskDiff,
                    riskDifference + z * seRiskDiff
                ];

                // Chi-square test
                const expected = [
                    [(a + b) * (a + c) / n, (a + b) * (b + d) / n],
                    [(c + d) * (a + c) / n, (c + d) * (b + d) / n]
                ];

                let chiSquare = 0;
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 2; j++) {
                        const o = table[i][j];
                        const e = expected[i][j];
                        chiSquare += Math.pow(o - e, 2) / e;
                    }
                }

                // Yates' continuity correction
                const chiSquareYates = Math.pow(Math.abs(a * d - b * c) - n / 2, 2) * n /
                    ((a + b) * (c + d) * (a + c) * (b + d));

                // P-values
                const pValueChi = 1 - jStat.chisquare.cdf(chiSquare, 1);
                const pValueYates = 1 - jStat.chisquare.cdf(chiSquareYates, 1);

                // Phi coefficient (effect size)
                const phi = Math.sqrt(chiSquare / n);

                // Number needed to treat (NNT)
                const nnt = Math.abs(1 / riskDifference);

                return {
                    table: [[a, b], [c, d]],
                    n: n,
                    proportions: { p1, p2, q1, q2 },
                    risk: {
                        risk1: risk1,
                        risk2: risk2,
                        riskRatio: riskRatio,
                        riskDifference: riskDifference,
                        riskDifferenceCI: rdCI,
                        nnt: nnt
                    },
                    odds: {
                        oddsRatio: oddsRatio,
                        logOddsRatio: logOddsRatio,
                        oddsRatioCI: orCI
                    },
                    chiSquare: {
                        statistic: chiSquare,
                        statisticYates: chiSquareYates,
                        pValue: pValueChi,
                        pValueYates: pValueYates,
                        df: 1
                    },
                    phi: phi,
                    fisherExact: this.fisherExactTest(table)
                };
            },

            /**
             * Calculate diagnostic test metrics
             */
            calculateDiagnosticMetrics(table) {
                const a = table[0][0]; // True Positive
                const b = table[0][1]; // False Positive
                const c = table[1][0]; // False Negative
                const d = table[1][1]; // True Negative

                const n = a + b + c + d;

                // Basic metrics with edge case handling
                const sensitivity = (a + c) > 0 ? a / (a + c) : NaN;
                const specificity = (b + d) > 0 ? d / (b + d) : NaN;
                const ppv = (a + b) > 0 ? a / (a + b) : NaN;
                const npv = (c + d) > 0 ? d / (c + d) : NaN;
                const accuracy = n > 0 ? (a + d) / n : NaN;

                // Likelihood ratios with edge case handling
                let lrPositive = NaN;
                let lrNegative = NaN;

                if (!isNaN(sensitivity) && !isNaN(specificity)) {
                    if (specificity < 1) {
                        lrPositive = sensitivity / (1 - specificity);
                    } else {
                        lrPositive = Infinity; // Perfect specificity
                    }

                    if (specificity > 0) {
                        lrNegative = (1 - sensitivity) / specificity;
                    } else {
                        lrNegative = Infinity; // Zero specificity
                    }
                }

                // Diagnostic Odds Ratio
                let dor = NaN;
                if (b > 0 && c > 0) {
                    dor = (a * d) / (b * c);
                } else if (a > 0 && d > 0 && b === 0 && c === 0) {
                    dor = Infinity; // Perfect test
                }

                // Youden's Index
                const youdenIndex = (!isNaN(sensitivity) && !isNaN(specificity)) ?
                    sensitivity + specificity - 1 : NaN;

                // Matthews Correlation Coefficient
                let mcc = NaN;
                const denominator = Math.sqrt((a + b) * (a + c) * (b + d) * (c + d));
                if (denominator > 0) {
                    mcc = (a * d - b * c) / denominator;
                }

                // F1 Score
                const f1Score = (2 * a + b + c) > 0 ? 2 * a / (2 * a + b + c) : NaN;

                // Confidence intervals (only calculate if valid)
                const z = 1.96; // 95% confidence

                const sensitivityCI = !isNaN(sensitivity) ? this.wilsonScoreInterval(a, a + c, z) : [NaN, NaN];
                const specificityCI = !isNaN(specificity) ? this.wilsonScoreInterval(d, b + d, z) : [NaN, NaN];
                const ppvCI = !isNaN(ppv) ? this.wilsonScoreInterval(a, a + b, z) : [NaN, NaN];
                const npvCI = !isNaN(npv) ? this.wilsonScoreInterval(d, c + d, z) : [NaN, NaN];

                return {
                    sensitivity: sensitivity,
                    specificity: specificity,
                    ppv: ppv,
                    npv: npv,
                    accuracy: accuracy,
                    lrPositive: lrPositive,
                    lrNegative: lrNegative,
                    dor: dor,
                    youdenIndex: youdenIndex,
                    mcc: mcc,
                    f1Score: f1Score,
                    sensitivityCI: sensitivityCI,
                    specificityCI: specificityCI,
                    ppvCI: ppvCI,
                    npvCI: npvCI,
                    prevalence: n > 0 ? (a + c) / n : NaN
                };
            },

            /**
             * Validate if fourfold table is suitable for diagnostic test analysis
             */
            validateDiagnosticTestData(table) {
                const a = table[0][0]; // True Positive
                const b = table[0][1]; // False Positive
                const c = table[1][0]; // False Negative
                const d = table[1][1]; // True Negative

                const validation = {
                    isValid: true,
                    warnings: [],
                    errors: []
                };

                // Check for empty cells that make metrics undefined
                if (a + c === 0) {
                    validation.errors.push("No positive cases in true condition - sensitivity cannot be calculated");
                    validation.isValid = false;
                }

                if (b + d === 0) {
                    validation.errors.push("No negative cases in true condition - specificity cannot be calculated");
                    validation.isValid = false;
                }

                if (a + b === 0) {
                    validation.errors.push("No positive test results - PPV cannot be calculated");
                    validation.isValid = false;
                }

                if (c + d === 0) {
                    validation.errors.push("No negative test results - NPV cannot be calculated");
                    validation.isValid = false;
                }

                // Check for extreme imbalances (warnings)
                const n = a + b + c + d;
                const prevalence = (a + c) / n;

                if (prevalence < 0.01 || prevalence > 0.99) {
                    validation.warnings.push(`Extreme prevalence (${(prevalence * 100).toFixed(1)}%) - results may be unreliable`);
                }

                if (prevalence < 0.05 || prevalence > 0.95) {
                    validation.warnings.push("Consider using likelihood ratios instead of predictive values due to prevalence");
                }

                // Check for small sample sizes
                if (n < 30) {
                    validation.warnings.push(`Small sample size (n=${n}) - confidence intervals may be unreliable`);
                }

                // Check for zero cells (perfect test scenarios)
                if (b === 0 && c === 0) {
                    validation.warnings.push("Perfect agreement between test and true condition - verify data correctness");
                }

                if (a === 0 && d === 0) {
                    validation.warnings.push("Perfect disagreement between test and true condition - verify data correctness");
                }

                // Check minimum cell frequencies for chi-square validity
                const minExpected = Math.min(
                    (a + b) * (a + c) / n,
                    (a + b) * (b + d) / n,
                    (c + d) * (a + c) / n,
                    (c + d) * (b + d) / n
                );

                if (minExpected < 5) {
                    validation.warnings.push("Low expected frequencies - Fisher's exact test is more appropriate than Chi-square");
                }

                return validation;
            },

            /**
             * Wilson score interval for proportions
             */
            wilsonScoreInterval(successes, trials, z) {
                if (trials === 0) return [0, 0];

                const p = successes / trials;
                const denominator = 1 + z * z / trials;
                const centre = (p + z * z / (2 * trials)) / denominator;
                const halfWidth = z * Math.sqrt(p * (1 - p) / trials + z * z / (4 * trials * trials)) / denominator;

                return [
                    Math.max(0, centre - halfWidth),
                    Math.min(1, centre + halfWidth)
                ];
            }

        };

        /**
         * Event Handlers & Initialization
         */
        document.addEventListener('DOMContentLoaded', function () {
            setupEventListeners();
            setupDragAndDrop();
            setupTabs();
            setupAboutModal();
            setupSignificanceTestOptions();
            setupTestInfoDisplay();
        });

        /**
         * Set up all event listeners for the application
         */
        function setupEventListeners() {
            // File upload
            document.getElementById('csv-file').addEventListener('change', handleFileUpload);

            // Data pagination
            document.getElementById('rows-per-page').addEventListener('change', updateDataPagination);
            document.getElementById('export-preview-csv').addEventListener('click', exportDataPreview);

            // Parameter constellations
            document.getElementById('add-constellation').addEventListener('click', addNewConstellation);

            // Group management
            document.getElementById('add-group').addEventListener('click', addNewGroup);
            document.getElementById('apply-groups').addEventListener('click', applyGroupsAndAnalyze);
            document.getElementById('reset-groups').addEventListener('click', resetGroups);
            document.getElementById('import-groups').addEventListener('click', importGroupDefinitions);
            document.getElementById('export-groups').addEventListener('click', exportGroupDefinitions);

            // Analysis tabs
            document.getElementById('detail-parameter-select').addEventListener('change', updateDetailAnalysis);
            document.getElementById('run-significance-test').addEventListener('click', runSignificanceTest);
            document.getElementById('clear-significance-results').addEventListener('click', clearSignificanceResults);
            document.getElementById('generate-visualization').addEventListener('click', generateCustomVisualization);

            // Prerequisite tests
            document.getElementById('check-normality').addEventListener('click', checkNormality);
            document.getElementById('check-variance').addEventListener('click', checkVarianceHomogeneity);

            // Visualization controls
            document.getElementById('viz-chart-type').addEventListener('change', updateVisualizationControls);
            document.getElementById('viz-parameter-x').addEventListener('change', updateVisualizationControls);
            document.getElementById('viz-parameter-y').addEventListener('change', updateVisualizationControls);

            // Regression controls
            document.getElementById('regression-type').addEventListener('change', updateRegressionInfo);
            document.getElementById('show-regression').addEventListener('change', updateRegressionInfo);

            // Fourfold table
            document.getElementById('generate-fourfold').addEventListener('click', generateFourfoldTable);

            // Export functionality
            document.getElementById('export-csv-data').addEventListener('click', exportAnalysisResults);
            document.getElementById('export-comprehensive-report').addEventListener('click', exportComprehensiveReport);

            document.getElementById('fourfold-constellation-1').addEventListener('focus', updateConstellationState);
            document.getElementById('fourfold-constellation-2').addEventListener('focus', updateConstellationState);

        }

        /**
         * Set up drag and drop functionality for file upload
         */
        function setupDragAndDrop() {
            const fileInputArea = document.getElementById('file-input-area');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                fileInputArea.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                fileInputArea.addEventListener(eventName, () => {
                    fileInputArea.classList.add('dragover');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                fileInputArea.addEventListener(eventName, () => {
                    fileInputArea.classList.remove('dragover');
                }, false);
            });

            fileInputArea.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    document.getElementById('csv-file').files = files;
                    handleFileUpload({ target: { files: files } });
                }
            }, false);
        }

        /**
         * Set up tab navigation
         */
        function setupTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Deactivate all tabs
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

                    // Activate selected tab
                    button.classList.add('active');
                    const tabId = button.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');

                    // Resize charts in active tab
                    setTimeout(() => {
                        Object.keys(globalState.charts).forEach(chartId => {
                            if (globalState.charts[chartId] && document.getElementById(chartId)) {
                                try {
                                    globalState.charts[chartId].resize();
                                } catch (e) {
                                    console.warn('Chart resize error:', e);
                                }
                            }
                        });
                    }, 100);
                });
            });
        }

        /**
         * Set up the about modal
         */
        function setupAboutModal() {
            const aboutBtn = document.getElementById('about-btn');
            const aboutModal = document.getElementById('about-modal');
            const closeAbout = document.getElementById('close-about');

            aboutBtn.addEventListener('click', () => {
                aboutModal.style.display = 'block';
            });

            closeAbout.addEventListener('click', () => {
                aboutModal.style.display = 'none';
            });

            window.addEventListener('click', (e) => {
                if (e.target === aboutModal) {
                    aboutModal.style.display = 'none';
                }
            });
        }

        /**
         * Set up significance test option interactions
         */
        function setupSignificanceTestOptions() {
            const alphaSelect = document.getElementById('sig-alpha');
            const customAlphaInput = document.getElementById('sig-custom-alpha');

            alphaSelect.addEventListener('change', () => {
                if (alphaSelect.value === 'custom') {
                    customAlphaInput.style.display = 'block';
                } else {
                    customAlphaInput.style.display = 'none';
                }
            });
        }

        /**
         * Set up test info display
         */
        function setupTestInfoDisplay() {
            const testTypeSelect = document.getElementById('sig-test-type');
            const testInfoDiv = document.getElementById('test-info');

            testTypeSelect.addEventListener('change', () => {
                const selectedTest = testTypeSelect.value;
                if (selectedTest && testInfo[selectedTest]) {
                    const info = testInfo[selectedTest];
                    testInfoDiv.innerHTML = `
                        <strong>${info.name}</strong><br>
                        ${info.description}<br>
                        ${info.requirements ? `<em>Requirements: ${info.requirements}</em>` : ''}
                    `;
                    testInfoDiv.style.display = 'block';
                } else {
                    testInfoDiv.style.display = 'none';
                }
            });
        }

        /**
         * Update visualization controls based on chart type and selected parameters
         */
        function updateVisualizationControls() {
            const chartType = document.getElementById('viz-chart-type').value;
            const regressionControls = document.getElementById('regression-controls');
            const paramX = document.getElementById('viz-parameter-x').value;
            const paramY = document.getElementById('viz-parameter-y').value;

            // Only show regression controls for scatter plots with numeric parameters on both axes
            if (chartType === 'scatter' &&
                paramX && paramY &&
                scaleTypes[globalState.columnTypes[paramX]].numeric &&
                scaleTypes[globalState.columnTypes[paramY]].numeric) {
                regressionControls.style.display = 'block';
            } else {
                regressionControls.style.display = 'none';
            }
        }

        /**
         * Update regression info display
         */
        function updateRegressionInfo() {
            // This will be called when regression type changes
            // The actual update happens when the chart is generated
        }

        /**
         * Check normality for selected parameter and groups
         */
        function checkNormality() {
            const paramName = document.getElementById('sig-parameter-select').value;
            if (!paramName) {
                utils.showError("Please select a parameter first.");
                return;
            }

            const paramType = globalState.columnTypes[paramName];
            if (!scaleTypes[paramType].numeric) {
                utils.showError("Normality test requires a numeric parameter (ordinal, interval, or ratio scale).");
                return;
            }

            // Get selected groups
            const selectedGroups = [];
            document.querySelectorAll('#sig-group-selection input:checked').forEach(checkbox => {
                selectedGroups.push(checkbox.value);
            });

            if (selectedGroups.length === 0) {
                utils.showError("Please select at least one group.");
                return;
            }

            // Clear previous results
            const resultsContainer = document.getElementById('prerequisite-results');
            resultsContainer.innerHTML = '';

            // Store results
            if (!globalState.prerequisiteResults[paramName]) {
                globalState.prerequisiteResults[paramName] = {};
            }

            // Test each group
            selectedGroups.forEach(groupId => {
                const groupData = globalState.processedData[groupId]
                    .map(row => utils.parseNumericValue(row[paramName]))
                    .filter(val => !isNaN(val));

                const result = statistics.shapiroWilkTest(groupData);
                const groupName = globalState.currentGroups[groupId].name;

                // Store result
                globalState.prerequisiteResults[paramName][groupId] = {
                    normality: result
                };

                // Display result
                const resultDiv = document.createElement('div');
                resultDiv.className = `prerequisite-result ${result.normal ? 'pass' : 'fail'}`;

                if (result.error) {
                    resultDiv.innerHTML = `
                        <strong>${groupName}:</strong> ${result.error}
                    `;
                } else {
                    resultDiv.innerHTML = `
                        <strong>${groupName}:</strong> 
                        Shapiro-Wilk W = ${utils.formatNumber(result.W, 4)}, 
                        p = ${utils.formatNumber(result.pValue, 4)}
                        ${result.normal ?
                            ' ✓ Normal distribution (p > 0.05)' :
                            ' ✗ Not normally distributed (p ≤ 0.05)'}
                    `;
                }

                resultsContainer.appendChild(resultDiv);
            });
        }

        /**
         * Check variance homogeneity between groups
         */
        function checkVarianceHomogeneity() {
            const paramName = document.getElementById('sig-parameter-select').value;
            if (!paramName) {
                utils.showError("Please select a parameter first.");
                return;
            }

            const paramType = globalState.columnTypes[paramName];
            if (!scaleTypes[paramType].numeric) {
                utils.showError("Variance test requires a numeric parameter (ordinal, interval, or ratio scale).");
                return;
            }

            // Get selected groups
            const selectedGroups = [];
            document.querySelectorAll('#sig-group-selection input:checked').forEach(checkbox => {
                selectedGroups.push(checkbox.value);
            });

            if (selectedGroups.length !== 2) {
                utils.showError("Variance homogeneity test requires exactly 2 groups.");
                return;
            }

            // Get data for both groups
            const group1Data = globalState.processedData[selectedGroups[0]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            const group2Data = globalState.processedData[selectedGroups[1]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            const result = statistics.fTest(group1Data, group2Data);

            // Store result
            if (!globalState.prerequisiteResults[paramName]) {
                globalState.prerequisiteResults[paramName] = {};
            }
            globalState.prerequisiteResults[paramName].varianceTest = result;

            // Display result
            const resultsContainer = document.getElementById('prerequisite-results');
            const resultDiv = document.createElement('div');
            resultDiv.className = `prerequisite-result ${result.equalVariances ? 'pass' : 'fail'}`;

            if (result.error) {
                resultDiv.innerHTML = `<strong>F-Test:</strong> ${result.error}`;
            } else {
                const group1Name = globalState.currentGroups[selectedGroups[0]].name;
                const group2Name = globalState.currentGroups[selectedGroups[1]].name;

                resultDiv.innerHTML = `
                    <strong>F-Test for Equal Variances:</strong><br>
                    ${group1Name} variance: ${utils.formatNumber(result.variance1, 4)}<br>
                    ${group2Name} variance: ${utils.formatNumber(result.variance2, 4)}<br>
                    F = ${utils.formatNumber(result.F, 4)}, p = ${utils.formatNumber(result.pValue, 4)}
                    ${result.equalVariances ?
                        ' ✓ Equal variances (p > 0.05)' :
                        ' ✗ Unequal variances (p ≤ 0.05) - Consider Welch\'s t-test'}
                `;
            }

            resultsContainer.appendChild(resultDiv);
        }

        /**
         * Handle file upload event
         */
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (globalState.isProcessing) {
                utils.showError("A file is already being processed. Please wait.");
                return;
            }

            utils.setLoading(true);
            utils.destroyAllCharts();

            const reader = new FileReader();

            reader.onload = function (e) {
                try {
                    // Detect delimiter and decimal separator
                    const firstLines = e.target.result.split('\n').slice(0, 5).join('\n');

                    // Use delimiter detection
                    globalState.csvDelimiter = utils.detectDelimiter(firstLines);

                    // Detect decimal separator by looking for numeric patterns
                    if (firstLines.match(/\d+,\d+/) && !firstLines.match(/\d+\.\d+/)) {
                        globalState.decimalSeparator = ',';
                    } else {
                        globalState.decimalSeparator = '.';
                    }

                    // Parse CSV with detected delimiter
                    Papa.parse(e.target.result, {
                        delimiter: globalState.csvDelimiter,
                        header: false,
                        skipEmptyLines: true,
                        complete: function (results) {
                            if (results.errors.length > 0) {
                                utils.showError("CSV parsing error: " + results.errors[0].message);
                                utils.setLoading(false);
                                return;
                            }

                            processCSVData(results.data);
                        },
                        error: function (error) {
                            utils.showError("Error reading CSV file: " + error.message);
                            utils.setLoading(false);
                        }
                    });
                } catch (error) {
                    utils.showError("Unexpected error processing file: " + error.message);
                    utils.setLoading(false);
                }
            };

            reader.onerror = function () {
                utils.showError("Error reading file");
                utils.setLoading(false);
            };

            reader.readAsText(file);
        }

        /**
         * Process CSV data after parsing with validation
         */
        function processCSVData(csvRows) {
            try {
                if (csvRows.length < 3) {
                    throw new Error("CSV file must contain at least 3 rows (header, types, data)");
                }

                // Extract header and types
                globalState.columnNames = csvRows[0];
                const typeRow = csvRows[1];

                // Map column types
                globalState.columnTypes = {};
                for (let i = 0; i < globalState.columnNames.length; i++) {
                    const columnName = globalState.columnNames[i];
                    const typeCode = typeRow[i] ? typeRow[i].toLowerCase().trim() : 'k';

                    if (['k', 'o', 'i', 'r'].includes(typeCode)) {
                        globalState.columnTypes[columnName] = typeCode;
                    } else {
                        globalState.columnTypes[columnName] = 'k'; // Default to nominal
                    }
                }

                // Process data rows
                globalState.rawData = [];
                for (let i = 2; i < csvRows.length; i++) {
                    const row = csvRows[i];
                    const dataRow = {};

                    for (let j = 0; j < globalState.columnNames.length; j++) {
                        const columnName = globalState.columnNames[j];
                        const cellValue = row[j] || '';
                        const columnType = globalState.columnTypes[columnName];

                        // Type-specific conversion
                        if (scaleTypes[columnType].numeric) {
                            dataRow[columnName] = utils.parseNumericValue(cellValue);
                        } else {
                            dataRow[columnName] = cellValue;
                        }
                    }

                    globalState.rawData.push(dataRow);
                }

                // Validate data consistency
                const validationIssues = validateDataConsistency();

                // Update UI
                displayDataPreview();
                initializeGroupDefinition();

                // Show containers
                document.getElementById('data-preview-container').style.display = 'block';
                document.getElementById('group-definition-container').style.display = 'block';

                // Show validation warnings if any
                if (validationIssues.length > 0) {
                    displayValidationWarnings(validationIssues);
                }

                utils.showSuccess(`File successfully loaded: ${globalState.rawData.length} records with ${globalState.columnNames.length} parameters.`);

            } catch (error) {
                utils.showError("Error processing CSV data: " + error.message);
            } finally {
                utils.setLoading(false);
            }
        }

        /**
         * Validate data consistency
         */
        function validateDataConsistency() {
            const issues = [];

            // Check column count consistency
            const expectedCount = globalState.columnNames.length;
            const inconsistentRows = [];

            globalState.rawData.forEach((row, index) => {
                const actualCount = Object.keys(row).length;
                if (actualCount !== expectedCount) {
                    inconsistentRows.push(index + 3);
                }
            });

            if (inconsistentRows.length > 0) {
                issues.push(`Inconsistent column count in rows: ${inconsistentRows.slice(0, 5).join(', ')}${inconsistentRows.length > 5 ? '...' : ''}`);
            }

            // Check data type consistency for numeric columns
            globalState.columnNames.forEach(colName => {
                const colType = globalState.columnTypes[colName];
                if (scaleTypes[colType].numeric) {
                    const invalidRows = [];
                    let validCount = 0;

                    globalState.rawData.forEach((row, index) => {
                        const value = row[colName];
                        if (value !== '' && value !== null && value !== undefined) {
                            if (isNaN(utils.parseNumericValue(value))) {
                                invalidRows.push(index + 3);
                            } else {
                                validCount++;
                            }
                        }
                    });

                    if (invalidRows.length > 0) {
                        issues.push(`Column "${colName}" (${scaleTypes[colType].name}) has non-numeric values in rows: ${invalidRows.slice(0, 5).join(', ')}${invalidRows.length > 5 ? '...' : ''}`);
                    }

                    if (validCount === 0) {
                        issues.push(`Column "${colName}" (${scaleTypes[colType].name}) contains no valid numeric data`);
                    }
                }
            });

            return issues;
        }

        /**
         * Display validation warnings
         */
        function displayValidationWarnings(issues) {
            const warningsDiv = document.getElementById('validation-warnings');
            const warningsList = document.getElementById('validation-warnings-list');

            warningsList.innerHTML = '';
            issues.forEach(issue => {
                const li = document.createElement('li');
                li.textContent = issue;
                warningsList.appendChild(li);
            });

            warningsDiv.style.display = 'block';
        }

        /**
         * Display data preview
         */
        function displayDataPreview() {
            const table = document.getElementById('data-preview-table');
            table.innerHTML = '';

            // Create header row
            const thead = document.createElement('thead');
            let headerRow = document.createElement('tr');

            globalState.columnNames.forEach(name => {
                const th = document.createElement('th');
                th.textContent = name;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            // Create type row
            headerRow = document.createElement('tr');
            globalState.columnNames.forEach(name => {
                const th = document.createElement('th');
                const type = globalState.columnTypes[name];
                const scaleInfo = utils.getScaleInfo(type);

                const typeSpan = document.createElement('span');
                typeSpan.textContent = scaleInfo.name;

                const badge = document.createElement('span');
                badge.className = `scale-badge ${scaleInfo.class}`;
                badge.textContent = type.toUpperCase();

                th.appendChild(typeSpan);
                th.appendChild(badge);
                th.style.fontStyle = 'italic';
                th.style.fontSize = '12px';
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create data rows (paginated)
            updateDataPagination();

            // Update summary
            const summary = document.getElementById('data-summary');
            const scaleTypeCounts = { k: 0, o: 0, i: 0, r: 0 };
            globalState.columnNames.forEach(name => {
                const type = globalState.columnTypes[name];
                if (scaleTypeCounts.hasOwnProperty(type)) {
                    scaleTypeCounts[type]++;
                }
            });

            let summaryText = `📊 <strong>${globalState.rawData.length}</strong> records with <strong>${globalState.columnNames.length}</strong> parameters loaded`;
            summaryText += ` (${scaleTypeCounts.k} nominal, ${scaleTypeCounts.o} ordinal, ${scaleTypeCounts.i} interval, ${scaleTypeCounts.r} ratio)`;

            summary.innerHTML = summaryText;
        }

        /**
         * Update data pagination
         */
        function updateDataPagination() {
            // Get pagination settings
            const rowsPerPage = parseInt(document.getElementById('rows-per-page').value);
            globalState.rowsPerPage = rowsPerPage;

            // Calculate total pages
            const totalPages = Math.ceil(globalState.rawData.length / rowsPerPage);

            // Ensure current page is valid
            if (globalState.currentPage > totalPages) {
                globalState.currentPage = totalPages;
            }
            if (globalState.currentPage < 1) {
                globalState.currentPage = 1;
            }

            // Update table content
            const table = document.getElementById('data-preview-table');
            const tbody = document.createElement('tbody');

            const startIndex = (globalState.currentPage - 1) * rowsPerPage;
            const endIndex = Math.min(startIndex + rowsPerPage, globalState.rawData.length);

            for (let i = startIndex; i < endIndex; i++) {
                const row = globalState.rawData[i];
                const tr = document.createElement('tr');

                globalState.columnNames.forEach(columnName => {
                    const td = document.createElement('td');
                    const cellValue = row[columnName];
                    const columnType = globalState.columnTypes[columnName];

                    if (scaleTypes[columnType].numeric && !isNaN(cellValue)) {
                        td.textContent = utils.formatNumber(cellValue, 2);
                    } else {
                        td.textContent = cellValue || '';
                    }

                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            }

            // Replace tbody if it exists, otherwise append new one
            const existingTbody = table.querySelector('tbody');
            if (existingTbody) {
                table.removeChild(existingTbody);
            }
            table.appendChild(tbody);

            // Update pagination controls
            updatePaginationControls(totalPages);
        }

        /**
         * Update pagination control buttons
         */
        function updatePaginationControls(totalPages) {
            const paginationContainer = document.getElementById('data-pagination');
            paginationContainer.innerHTML = '';

            // "First" and "Previous" buttons
            const firstBtn = document.createElement('button');
            firstBtn.textContent = '««';
            firstBtn.disabled = globalState.currentPage === 1;
            firstBtn.addEventListener('click', () => {
                globalState.currentPage = 1;
                updateDataPagination();
            });
            paginationContainer.appendChild(firstBtn);

            const prevBtn = document.createElement('button');
            prevBtn.textContent = '«';
            prevBtn.disabled = globalState.currentPage === 1;
            prevBtn.addEventListener('click', () => {
                globalState.currentPage--;
                updateDataPagination();
            });
            paginationContainer.appendChild(prevBtn);

            // Page number buttons
            const maxButtons = 5;
            let startPage = Math.max(1, globalState.currentPage - Math.floor(maxButtons / 2));
            let endPage = Math.min(totalPages, startPage + maxButtons - 1);

            // Adjust if we're near the end
            if (endPage - startPage + 1 < maxButtons && startPage > 1) {
                startPage = Math.max(1, endPage - maxButtons + 1);
            }

            for (let i = startPage; i <= endPage; i++) {
                const pageBtn = document.createElement('button');
                pageBtn.textContent = i;
                pageBtn.className = i === globalState.currentPage ? 'active' : '';
                pageBtn.addEventListener('click', () => {
                    globalState.currentPage = i;
                    updateDataPagination();
                });
                paginationContainer.appendChild(pageBtn);
            }

            // "Next" and "Last" buttons
            const nextBtn = document.createElement('button');
            nextBtn.textContent = '»';
            nextBtn.disabled = globalState.currentPage === totalPages;
            nextBtn.addEventListener('click', () => {
                globalState.currentPage++;
                updateDataPagination();
            });
            paginationContainer.appendChild(nextBtn);

            const lastBtn = document.createElement('button');
            lastBtn.textContent = '»»';
            lastBtn.disabled = globalState.currentPage === totalPages;
            lastBtn.addEventListener('click', () => {
                globalState.currentPage = totalPages;
                updateDataPagination();
            });
            paginationContainer.appendChild(lastBtn);

            // Page info
            const pageInfo = document.createElement('span');
            pageInfo.textContent = ` Page ${globalState.currentPage} of ${totalPages} `;
            pageInfo.style.margin = '0 10px';
            paginationContainer.appendChild(pageInfo);
        }

        /**
         * Export data preview as CSV
         */
        function exportDataPreview() {
            if (globalState.rawData.length === 0) {
                utils.showError("No data to export.");
                return;
            }

            let csvContent = '\uFEFF'; // UTF-8 BOM for Excel

            // Headers
            csvContent += globalState.columnNames.join(globalState.csvDelimiter) + '\n';

            // Type row
            csvContent += globalState.columnNames.map(name => globalState.columnTypes[name]).join(globalState.csvDelimiter) + '\n';

            // Data rows
            globalState.rawData.forEach(row => {
                let rowData = globalState.columnNames.map(columnName => {
                    let cellValue = '';
                    const value = row[columnName];
                    const columnType = globalState.columnTypes[columnName];

                    if (value !== undefined && value !== null) {
                        if (scaleTypes[columnType].numeric && !isNaN(value)) {
                            cellValue = utils.formatNumberForCSV(value);
                        } else {
                            cellValue = String(value);
                        }

                        // Escape delimiter in data
                        if (cellValue.includes(globalState.csvDelimiter) || cellValue.includes('"')) {
                            cellValue = `"${cellValue.replace(/"/g, '""')}"`;
                        }
                    }

                    return cellValue;
                }).join(globalState.csvDelimiter);

                csvContent += rowData + '\n';
            });

            // Create download with timestamp
            const timestamp = utils.getTimestamp();
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `sra-${timestamp}-data-export.csv`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            URL.revokeObjectURL(url);
            utils.showSuccess('Data successfully exported!');
        }

        /**
         * Initialize group definition interface
         */
        function initializeGroupDefinition() {
            const container = document.getElementById('parameter-groups');
            container.innerHTML = '';

            globalState.groupDefinitions = [];
            globalState.currentGroups = {};
            globalState.processedData = {};
            globalState.prerequisiteResults = {};
            globalState.parameterConstellations = [];

            // Clear constellation list
            document.getElementById('constellation-list').innerHTML = '';

            // Add first group
            addNewGroup();
        }

        /**
         * Add a new parameter constellation
         */
        function addNewConstellation() {
            const constellationList = document.getElementById('constellation-list');
            const constellationIndex = globalState.parameterConstellations.length;

            const constellationDiv = document.createElement('div');
            constellationDiv.className = 'constellation-item';
            constellationDiv.dataset.constellationIndex = constellationIndex;

            // Constellation header
            const header = document.createElement('div');
            header.className = 'constellation-header';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'constellation-name';
            nameInput.value = `Constellation ${constellationIndex + 1}`;
            nameInput.placeholder = 'Enter constellation name';

            // Add event listener to update state when name changes
            nameInput.addEventListener('input', () => {
                updateConstellationState();
            });

            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => {
                constellationList.removeChild(constellationDiv);
                updateConstellationIndices();
            });

            header.appendChild(nameInput);
            header.appendChild(removeBtn);
            constellationDiv.appendChild(header);

            // Parameter container
            const paramContainer = document.createElement('div');
            paramContainer.className = 'parameter-controls';
            constellationDiv.appendChild(paramContainer);

            // Add first parameter control with "All Data" selected
            addConstellationParameterControl(paramContainer, true);

            // Add parameter button
            const addParamBtn = document.createElement('button');
            addParamBtn.className = 'btn btn-accent btn-small';
            addParamBtn.textContent = 'Add Parameter';
            addParamBtn.addEventListener('click', () => {
                addConstellationParameterControl(paramContainer, false);
            });
            constellationDiv.appendChild(addParamBtn);

            constellationList.appendChild(constellationDiv);

            // Update constellation in state
            updateConstellationState();
        }

        /**
         * Add a parameter control to a constellation
         */
        function addConstellationParameterControl(container, selectAllData = false) {
            const controlDiv = document.createElement('div');
            controlDiv.className = 'parameter-control';

            // Parameter select
            const paramLabel = document.createElement('label');
            paramLabel.textContent = 'Parameter:';
            controlDiv.appendChild(paramLabel);

            const paramSelect = document.createElement('select');
            paramSelect.className = 'param-select';

            // Add "All Data" option
            const allDataOption = document.createElement('option');
            allDataOption.value = '__all_data__';
            allDataOption.textContent = 'All Data';
            if (selectAllData) {
                allDataOption.selected = true;
            }
            paramSelect.appendChild(allDataOption);

            // Default "no parameter" option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select parameter...';
            paramSelect.appendChild(defaultOption);

            // Add available parameters
            globalState.columnNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                const scaleInfo = utils.getScaleInfo(globalState.columnTypes[name]);
                option.textContent = `${name} (${scaleInfo.name})`;
                paramSelect.appendChild(option);
            });

            controlDiv.appendChild(paramSelect);

            // Condition container
            const conditionContainer = document.createElement('div');
            conditionContainer.className = 'condition-controls';
            controlDiv.appendChild(conditionContainer);

            // Distribution info container
            const groupDistribution = document.createElement('div');
            groupDistribution.className = 'group-distribution';
            groupDistribution.style.display = 'none';
            controlDiv.appendChild(groupDistribution);

            // Info container
            const infoDiv = document.createElement('div');
            infoDiv.className = 'parameter-info';
            controlDiv.appendChild(infoDiv);

            // Set up condition controls for "All Data" if selected
            if (selectAllData) {
                updateConditionControls(conditionContainer, infoDiv, groupDistribution, '__all_data__');
            }

            // Event listener for parameter change
            paramSelect.addEventListener('change', () => {
                const selectedParam = paramSelect.value;
                updateConditionControls(conditionContainer, infoDiv, groupDistribution, selectedParam);
                updateConstellationState(); // Update state when parameter changes
            });

            // Add change listeners to update constellation state when conditions change
            conditionContainer.addEventListener('change', () => {
                updateConstellationState();
            });

            conditionContainer.addEventListener('input', () => {
                updateConstellationState();
            });

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove Parameter';
            removeBtn.style.marginTop = '10px';
            removeBtn.addEventListener('click', () => {
                container.removeChild(controlDiv);
                updateConstellationState(); // Update state when parameter is removed
            });
            controlDiv.appendChild(removeBtn);

            container.appendChild(controlDiv);
        }

        /**
         * Update constellation indices after removal
         */
        function updateConstellationIndices() {
            const constellations = document.querySelectorAll('.constellation-item');
            constellations.forEach((constellation, index) => {
                constellation.dataset.constellationIndex = index;
                const nameInput = constellation.querySelector('.constellation-name');
                // Only update the name if it still has the default pattern
                if (nameInput.value.match(/^Constellation \d+$/)) {
                    nameInput.value = `Constellation ${index + 1}`;
                }
            });
            updateConstellationState();
        }

        /**
         * Update constellation state in global state
         */
        function updateConstellationState() {
            globalState.parameterConstellations = [];

            const constellations = document.querySelectorAll('.constellation-item');
            constellations.forEach(constellation => {
                // Get the actual user-entered name from the input field
                const nameInput = constellation.querySelector('.constellation-name');
                const userEnteredName = nameInput.value.trim();

                const conditions = [];

                constellation.querySelectorAll('.parameter-control').forEach(controlDiv => {
                    const paramSelect = controlDiv.querySelector('.param-select');
                    const operatorSelect = controlDiv.querySelector('.condition-operator');
                    const valueElement = controlDiv.querySelector('.condition-value');

                    if (paramSelect && paramSelect.value) {
                        const paramName = paramSelect.value;

                        // Handle "All Data" selection
                        if (paramName === '__all_data__') {
                            conditions.push({
                                parameter: '__all_data__',
                                operator: '=',
                                value: true,
                                type: 'special'
                            });
                        } else if (operatorSelect && valueElement) {
                            const paramType = globalState.columnTypes[paramName];
                            let value;

                            if (scaleTypes[paramType].numeric) {
                                value = utils.parseNumericValue(valueElement.value);
                            } else {
                                value = valueElement.value;
                            }

                            if (value !== undefined && value !== null && (typeof value === 'string' || !isNaN(value))) {
                                conditions.push({
                                    parameter: paramName,
                                    operator: operatorSelect.value,
                                    value: value,
                                    type: paramType
                                });
                            }
                        }
                    }
                });

                if (conditions.length > 0) {
                    globalState.parameterConstellations.push({
                        name: userEnteredName || `Constellation ${globalState.parameterConstellations.length + 1}`,
                        conditions: conditions
                    });
                }
            });

            // Update constellation selectors in groups and fourfold table
            updateConstellationSelectors();
        }

        /**
         * Update constellation selectors in groups and fourfold table
         */
        function updateConstellationSelectors() {
            // Update fourfold table selectors
            const fourfoldSelectors = ['fourfold-constellation-1', 'fourfold-constellation-2'];
            fourfoldSelectors.forEach(selectorId => {
                const selector = document.getElementById(selectorId);
                if (selector) {
                    const currentValue = selector.value;
                    selector.innerHTML = '<option value="">Select constellation</option>';

                    globalState.parameterConstellations.forEach((constellation) => {
                        const option = document.createElement('option');
                        option.value = constellation.name;
                        option.textContent = constellation.name;
                        selector.appendChild(option);
                    });

                    // Restore selection if still valid
                    if (currentValue && Array.from(selector.options).some(opt => opt.value === currentValue)) {
                        selector.value = currentValue;
                    }
                }
            });
        }

        /**
         * Add a new parameter group
         */
        function addNewGroup() {
            const container = document.getElementById('parameter-groups');
            const groupIndex = container.children.length;

            const groupDiv = document.createElement('div');
            groupDiv.className = 'parameter-group';
            groupDiv.dataset.groupIndex = groupIndex;

            // Group header
            const header = document.createElement('div');
            header.className = 'parameter-group-title';

            // Editable group name input
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'group-name-input';
            nameInput.value = `Subgroup ${groupIndex + 1}`;
            nameInput.placeholder = 'Enter group name';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => {
                if (container.children.length > 1) {
                    container.removeChild(groupDiv);
                    updateGroupNumbers();
                } else {
                    utils.showError("At least one subgroup must be defined.");
                }
            });

            header.appendChild(nameInput);
            header.appendChild(removeBtn);
            groupDiv.appendChild(header);

            // Group controls (color and inclusion)
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'group-controls';

            // Color control
            const colorControl = document.createElement('div');
            colorControl.className = 'group-color-control';

            const colorLabel = document.createElement('label');
            colorLabel.textContent = 'Color:';
            colorControl.appendChild(colorLabel);

            const colorSelect = document.createElement('select');
            colorSelect.className = 'color-preset-selector';

            // Add preset colors
            groupColors.forEach((color, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = color.name;
                colorSelect.appendChild(option);
            });

            // Add custom option
            const customOption = document.createElement('option');
            customOption.value = 'custom';
            customOption.textContent = 'Custom';
            colorSelect.appendChild(customOption);

            // Set default color based on group index
            colorSelect.value = groupIndex % groupColors.length;

            colorControl.appendChild(colorSelect);

            // Color preview
            const colorPreview = document.createElement('div');
            colorPreview.className = 'color-preview';
            colorPreview.style.backgroundColor = groupColors[groupIndex % groupColors.length].bg;
            colorControl.appendChild(colorPreview);

            // Custom color input
            const customColorInput = document.createElement('input');
            customColorInput.type = 'text';
            customColorInput.className = 'custom-color-input';
            customColorInput.placeholder = '#RRGGBB';
            customColorInput.style.display = 'none';
            colorControl.appendChild(customColorInput);

            // Color change handler
            colorSelect.addEventListener('change', () => {
                if (colorSelect.value === 'custom') {
                    customColorInput.style.display = 'block';
                    customColorInput.focus();
                } else {
                    customColorInput.style.display = 'none';
                    const colorIndex = parseInt(colorSelect.value);
                    colorPreview.style.backgroundColor = groupColors[colorIndex].bg;
                }
            });

            customColorInput.addEventListener('input', () => {
                const hexRegex = /^#[0-9A-F]{6}$/i;
                if (hexRegex.test(customColorInput.value)) {
                    colorPreview.style.backgroundColor = customColorInput.value + 'B3'; // Add transparency
                }
            });

            controlsDiv.appendChild(colorControl);

            // Include in analysis checkbox
            const includeCheckbox = document.createElement('input');
            includeCheckbox.type = 'checkbox';
            includeCheckbox.id = `include-group-${groupIndex}`;
            includeCheckbox.checked = true;
            includeCheckbox.addEventListener('change', () => {
                groupDiv.classList.toggle('excluded', !includeCheckbox.checked);
            });

            const includeLabel = document.createElement('label');
            includeLabel.htmlFor = `include-group-${groupIndex}`;
            includeLabel.textContent = 'Include in analysis';

            const includeContainer = document.createElement('div');
            includeContainer.className = 'checkbox-container';
            includeContainer.appendChild(includeCheckbox);
            includeContainer.appendChild(includeLabel);

            controlsDiv.appendChild(includeContainer);

            groupDiv.appendChild(controlsDiv);

            // Not in previous groups checkbox
            const notInPreviousDiv = document.createElement('div');
            notInPreviousDiv.className = 'not-in-previous-checkbox';

            const notInPreviousCheckbox = document.createElement('input');
            notInPreviousCheckbox.type = 'checkbox';
            notInPreviousCheckbox.id = `not-in-previous-${groupIndex}`;
            notInPreviousCheckbox.checked = groupIndex > 0;

            const notInPreviousLabel = document.createElement('label');
            notInPreviousLabel.htmlFor = `not-in-previous-${groupIndex}`;
            notInPreviousLabel.textContent = 'Exclude records that are in previous groups';

            notInPreviousDiv.appendChild(notInPreviousCheckbox);
            notInPreviousDiv.appendChild(notInPreviousLabel);

            if (groupIndex === 0) {
                notInPreviousDiv.style.display = 'none';
            }

            groupDiv.appendChild(notInPreviousDiv);

            // Condition type selector
            const conditionTypeDiv = document.createElement('div');
            conditionTypeDiv.className = 'condition-type-selector';

            const individualBtn = document.createElement('button');
            individualBtn.textContent = 'Add Individual Condition';
            individualBtn.className = 'active';
            individualBtn.addEventListener('click', () => {
                addParameterControl(paramContainer);
            });

            const constellationBtn = document.createElement('button');
            constellationBtn.textContent = 'Add Constellation';
            constellationBtn.addEventListener('click', () => {
                addConstellationToGroup(paramContainer);
            });

            conditionTypeDiv.appendChild(individualBtn);
            conditionTypeDiv.appendChild(constellationBtn);
            groupDiv.appendChild(conditionTypeDiv);

            // Parameter container
            const paramContainer = document.createElement('div');
            paramContainer.className = 'parameter-controls';
            groupDiv.appendChild(paramContainer);

            // Add first parameter control with "All Data" selected by default
            addParameterControl(paramContainer, true);

            container.appendChild(groupDiv);
        }

        /**
         * Add a constellation selector to a group
         */
        function addConstellationToGroup(container) {
            if (globalState.parameterConstellations.length === 0) {
                utils.showError("Please define at least one parameter constellation first.");
                return;
            }

            const controlDiv = document.createElement('div');
            controlDiv.className = 'parameter-control constellation-reference';

            const label = document.createElement('label');
            label.textContent = 'Constellation:';
            controlDiv.appendChild(label);

            // Negation checkbox
            const negationCheckbox = document.createElement('input');
            negationCheckbox.type = 'checkbox';
            negationCheckbox.className = 'negation-checkbox';
            negationCheckbox.addEventListener('change', () => {
                controlDiv.classList.toggle('negated', negationCheckbox.checked);
                updateConstellationDisplay();
            });

            const negationLabel = document.createElement('label');
            negationLabel.textContent = 'NOT';
            negationLabel.style.marginRight = '10px';

            const negationContainer = document.createElement('span');
            negationContainer.appendChild(negationCheckbox);
            negationContainer.appendChild(negationLabel);
            controlDiv.appendChild(negationContainer);

            const constellationSelect = document.createElement('select');
            constellationSelect.className = 'constellation-select';

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select constellation...';
            constellationSelect.appendChild(defaultOption);

            globalState.parameterConstellations.forEach((constellation, index) => {
                const option = document.createElement('option');
                option.value = constellation.name;
                option.textContent = constellation.name;
                constellationSelect.appendChild(option);
            });

            controlDiv.appendChild(constellationSelect);

            // Display constellation conditions
            const conditionsDisplay = document.createElement('div');
            conditionsDisplay.className = 'constellation-conditions';
            conditionsDisplay.style.marginTop = '10px';
            conditionsDisplay.style.fontSize = '0.9em';
            conditionsDisplay.style.color = '#666';
            controlDiv.appendChild(conditionsDisplay);

            const updateConstellationDisplay = () => {
                const selectedConstellation = globalState.parameterConstellations.find(
                    c => c.name === constellationSelect.value
                );

                if (selectedConstellation) {
                    const conditionsText = selectedConstellation.conditions.map(c => {
                        if (c.parameter === '__all_data__') {
                            return 'All Data';
                        }
                        return `${c.parameter} ${c.operator} ${c.value}`;
                    }).join(' AND ');

                    const prefix = negationCheckbox.checked ? '<strong>NOT</strong> (' : '';
                    const suffix = negationCheckbox.checked ? ')' : '';
                    conditionsDisplay.innerHTML = `<strong>Conditions:</strong> ${prefix}${conditionsText}${suffix}`;
                } else {
                    conditionsDisplay.innerHTML = '';
                }
            };

            constellationSelect.addEventListener('change', updateConstellationDisplay);

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove Constellation';
            removeBtn.style.marginTop = '10px';
            removeBtn.addEventListener('click', () => {
                container.removeChild(controlDiv);
            });
            controlDiv.appendChild(removeBtn);

            container.appendChild(controlDiv);
        }

        /**
         * Add a parameter control to a group
         */
        function addParameterControl(container, selectAllData = false) {
            const controlDiv = document.createElement('div');
            controlDiv.className = 'parameter-control';

            // Parameter select
            const paramLabel = document.createElement('label');
            paramLabel.textContent = 'Parameter:';
            controlDiv.appendChild(paramLabel);

            const paramSelect = document.createElement('select');
            paramSelect.className = 'param-select';

            // Add "All Data" option
            const allDataOption = document.createElement('option');
            allDataOption.value = '__all_data__';
            allDataOption.textContent = 'All Data';
            if (selectAllData) {
                allDataOption.selected = true;
            }
            paramSelect.appendChild(allDataOption);

            // Default "no parameter" option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select parameter...';
            paramSelect.appendChild(defaultOption);

            // Add available parameters
            globalState.columnNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                const scaleInfo = utils.getScaleInfo(globalState.columnTypes[name]);
                option.textContent = `${name} (${scaleInfo.name})`;
                paramSelect.appendChild(option);
            });

            controlDiv.appendChild(paramSelect);

            // Condition container
            const conditionContainer = document.createElement('div');
            conditionContainer.className = 'condition-controls';
            controlDiv.appendChild(conditionContainer);

            // Distribution info container
            const groupDistribution = document.createElement('div');
            groupDistribution.className = 'group-distribution';
            groupDistribution.style.display = 'none';
            controlDiv.appendChild(groupDistribution);

            // Info container
            const infoDiv = document.createElement('div');
            infoDiv.className = 'parameter-info';
            controlDiv.appendChild(infoDiv);

            // Set up condition controls for "All Data" if selected
            if (selectAllData) {
                updateConditionControls(conditionContainer, infoDiv, groupDistribution, '__all_data__');
            }

            // Event listener for parameter change
            paramSelect.addEventListener('change', () => {
                const selectedParam = paramSelect.value;
                updateConditionControls(conditionContainer, infoDiv, groupDistribution, selectedParam);
            });

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove Parameter';
            removeBtn.style.marginTop = '10px';
            removeBtn.addEventListener('click', () => {
                container.removeChild(controlDiv);
            });
            controlDiv.appendChild(removeBtn);

            container.appendChild(controlDiv);
        }

        /**
         * Update condition controls based on selected parameter
         */
        function updateConditionControls(container, infoDiv, distributionDiv, paramName) {
            container.innerHTML = '';
            infoDiv.innerHTML = '';
            distributionDiv.innerHTML = '';
            distributionDiv.style.display = 'none';

            if (!paramName) return;

            // Handle "All Data" selection
            if (paramName === '__all_data__') {
                infoDiv.innerHTML = '<strong>All Data Selected:</strong><br>This condition will include all records in the dataset.';
                distributionDiv.innerHTML = `
                    <div><strong>Distribution:</strong></div>
                    <div>All records: ${globalState.rawData.length} (100%)</div>
                    <div class="distribution-bar">
                        <div class="distribution-fill" style="width: 100%"></div>
                    </div>
                `;
                distributionDiv.style.display = 'block';
                return;
            }

            const paramType = globalState.columnTypes[paramName];
            const scaleInfo = scaleTypes[paramType];

            if (scaleInfo.numeric) {
                // Numeric parameter
                const operatorSelect = document.createElement('select');
                operatorSelect.className = 'condition-operator';

                ['<', '<=', '=', '>=', '>', '!='].forEach(op => {
                    const option = document.createElement('option');
                    option.value = op;
                    option.textContent = op;
                    operatorSelect.appendChild(option);
                });

                const valueInput = document.createElement('input');
                valueInput.type = 'number';
                valueInput.className = 'condition-value';
                valueInput.step = 'any';
                valueInput.placeholder = 'Enter value';

                container.appendChild(operatorSelect);
                container.appendChild(valueInput);

                // Calculate statistics and show info
                const values = globalState.rawData
                    .map(row => utils.parseNumericValue(row[paramName]))
                    .filter(val => !isNaN(val));

                if (values.length > 0) {
                    const stats = statistics.calculate(values);

                    // Set median as default value
                    if (paramType === 'o') {
                        valueInput.value = Math.round(stats.median);
                    } else {
                        valueInput.value = stats.median.toFixed(2);
                    }

                    let infoText = `<strong>Statistics for ${paramName} (${scaleInfo.name}):</strong><br>`;

                    if (paramType === 'o') {
                        infoText += `Min: ${stats.min} | Max: ${stats.max}<br>`;
                        infoText += `Median: ${stats.median.toFixed(2)}`;
                    } else {
                        infoText += `Min: ${stats.min.toFixed(2)} | Max: ${stats.max.toFixed(2)}<br>`;
                        infoText += `Median: ${stats.median.toFixed(2)} | Mean: ${stats.mean.toFixed(2)}`;
                        if (paramType === 'r' && stats.cv !== null) {
                            infoText += ` | CV: ${stats.cv.toFixed(1)}%`;
                        }
                    }

                    infoDiv.innerHTML = infoText;

                    // Setup threshold distribution update
                    valueInput.addEventListener('input', () => {
                        updateNumericDistribution(paramName, operatorSelect.value, utils.parseNumericValue(valueInput.value), distributionDiv);
                    });

                    operatorSelect.addEventListener('change', () => {
                        updateNumericDistribution(paramName, operatorSelect.value, utils.parseNumericValue(valueInput.value), distributionDiv);
                    });

                    // Initial distribution update
                    updateNumericDistribution(paramName, operatorSelect.value, utils.parseNumericValue(valueInput.value), distributionDiv);
                }
            } else if (paramType === 'k') {
                // Categorical parameter
                const operatorSelect = document.createElement('select');
                operatorSelect.className = 'condition-operator';

                const equalOption = document.createElement('option');
                equalOption.value = '=';
                equalOption.textContent = 'is';
                operatorSelect.appendChild(equalOption);

                const notEqualOption = document.createElement('option');
                notEqualOption.value = '!=';
                notEqualOption.textContent = 'is not';
                operatorSelect.appendChild(notEqualOption);

                const valueSelect = document.createElement('select');
                valueSelect.className = 'condition-value';

                // Collect unique values
                const uniqueValues = [...new Set(globalState.rawData
                    .map(row => row[paramName])
                    .filter(val => val !== null && val !== undefined && val !== ''))];

                uniqueValues.sort().forEach(value => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    valueSelect.appendChild(option);
                });

                container.appendChild(operatorSelect);
                container.appendChild(valueSelect);

                infoDiv.innerHTML = `
                    <strong>Categories for ${paramName} (${scaleInfo.name}):</strong><br>
                    ${uniqueValues.length} unique values: ${uniqueValues.slice(0, 5).join(', ')}${uniqueValues.length > 5 ? '...' : ''}
                `;

                // Setup category distribution update
                valueSelect.addEventListener('change', () => {
                    updateCategoryDistribution(paramName, operatorSelect.value, valueSelect.value, distributionDiv);
                });

                operatorSelect.addEventListener('change', () => {
                    updateCategoryDistribution(paramName, operatorSelect.value, valueSelect.value, distributionDiv);
                });

                // Initial distribution update
                if (uniqueValues.length > 0) {
                    updateCategoryDistribution(paramName, operatorSelect.value, uniqueValues[0], distributionDiv);
                }
            }
        }

        /**
         * Update distribution info for numeric parameter
         */
        function updateNumericDistribution(paramName, operator, threshold, container) {
            if (isNaN(threshold)) {
                container.style.display = 'none';
                return;
            }

            const values = globalState.rawData
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            if (values.length === 0) {
                container.style.display = 'none';
                return;
            }

            // Count values matching the condition
            let matchCount = 0;

            values.forEach(v => {
                if (utils.compareNumbers(v, threshold, operator)) {
                    matchCount++;
                }
            });

            const totalCount = values.length;
            const matchPercent = (matchCount / totalCount * 100).toFixed(1);
            const inversePercent = (100 - parseFloat(matchPercent)).toFixed(1);

            container.innerHTML = `
                <div><strong>Distribution for ${paramName} ${operator} ${threshold}:</strong></div>
                <div>Matching: ${matchCount} records (${matchPercent}%)</div>
                <div class="distribution-bar">
                    <div class="distribution-fill" style="width: ${matchPercent}%"></div>
                </div>
                <div>Non-matching: ${totalCount - matchCount} records (${inversePercent}%)</div>
            `;

            container.style.display = 'block';
        }

        /**
         * Update distribution info for categorical parameter
         */
        function updateCategoryDistribution(paramName, operator, category, container) {
            if (!category) {
                container.style.display = 'none';
                return;
            }

            const values = globalState.rawData
                .map(row => row[paramName])
                .filter(val => val !== null && val !== undefined);

            if (values.length === 0) {
                container.style.display = 'none';
                return;
            }

            // Count values matching the condition
            let matchCount = 0;

            switch (operator) {
                case '=': matchCount = values.filter(v => String(v) === String(category)).length; break;
                case '!=': matchCount = values.filter(v => String(v) !== String(category)).length; break;
            }

            const totalCount = values.length;
            const matchPercent = (matchCount / totalCount * 100).toFixed(1);
            const inversePercent = (100 - parseFloat(matchPercent)).toFixed(1);

            container.innerHTML = `
                <div><strong>Distribution for ${paramName} ${operator} "${category}":</strong></div>
                <div>Matching: ${matchCount} records (${matchPercent}%)</div>
                <div class="distribution-bar">
                    <div class="distribution-fill" style="width: ${matchPercent}%"></div>
                </div>
                <div>Non-matching: ${totalCount - matchCount} records (${inversePercent}%)</div>
            `;

            container.style.display = 'block';
        }

        /**
         * Update group numbers after removing a group
         */
        function updateGroupNumbers() {
            const groups = document.querySelectorAll('.parameter-group');
            groups.forEach((group, index) => {
                group.dataset.groupIndex = index;
                const nameInput = group.querySelector('.group-name-input');
                // Only update if it still has the default name pattern
                if (nameInput.value.match(/^Subgroup \d+$/)) {
                    nameInput.value = `Subgroup ${index + 1}`;
                }

                // Update not-in-previous checkbox
                const notInPreviousDiv = group.querySelector('.not-in-previous-checkbox');
                const notInPreviousCheckbox = group.querySelector('input[type="checkbox"][id^="not-in-previous"]');
                if (notInPreviousCheckbox) {
                    notInPreviousCheckbox.id = `not-in-previous-${index}`;
                }
                if (notInPreviousDiv) {
                    notInPreviousDiv.style.display = index === 0 ? 'none' : 'block';
                }

                // Update include checkbox
                const includeCheckbox = group.querySelector('input[type="checkbox"][id^="include-group"]');
                if (includeCheckbox) {
                    includeCheckbox.id = `include-group-${index}`;
                    const includeLabel = group.querySelector(`label[for^="include-group"]`);
                    if (includeLabel) {
                        includeLabel.htmlFor = `include-group-${index}`;
                    }
                }
            });
        }

        /**
         * Apply groups and analyze data
         */
        function applyGroupsAndAnalyze() {
            if (globalState.isProcessing) {
                utils.showError("An analysis is already in progress. Please wait.");
                return;
            }

            utils.setLoading(true);

            setTimeout(() => {
                try {
                    // Collect group definitions
                    collectGroupDefinitions();

                    if (globalState.groupDefinitions.length === 0) {
                        throw new Error("Please define at least one group with at least one parameter or constellation.");
                    }

                    // Filter data into groups
                    filterDataIntoGroups();

                    // Update analysis results
                    updateAnalysisResults();

                    // Show results
                    document.getElementById('analysis-results').style.display = 'block';

                    utils.showSuccess(`Analysis complete! ${Object.keys(globalState.currentGroups).length} groups created.`);

                    // Scroll to results
                    document.getElementById('analysis-results').scrollIntoView({ behavior: 'smooth' });

                } catch (error) {
                    utils.showError("Error in group analysis: " + error.message);
                } finally {
                    utils.setLoading(false);
                }
            }, 100);
        }

        /**
         * Collect group definitions from the UI
         */
        function collectGroupDefinitions() {
            globalState.groupDefinitions = [];

            const groups = document.querySelectorAll('.parameter-group');

            groups.forEach((groupElement, index) => {
                const nameInput = groupElement.querySelector('.group-name-input');
                const groupName = nameInput.value.trim() || `Group ${index + 1}`;

                const notInPreviousCheckbox = groupElement.querySelector('input[type="checkbox"][id^="not-in-previous"]');
                const notInPrevious = notInPreviousCheckbox ? notInPreviousCheckbox.checked : false;

                const includeCheckbox = groupElement.querySelector('input[type="checkbox"][id^="include-group"]');
                const includeInAnalysis = includeCheckbox ? includeCheckbox.checked : true;

                // Get color settings
                const colorSelect = groupElement.querySelector('.color-preset-selector');
                const customColorInput = groupElement.querySelector('.custom-color-input');
                let customColor = null;

                if (colorSelect.value === 'custom' && customColorInput.value) {
                    customColor = customColorInput.value;
                    if (!customColor.includes('rgba')) {
                        customColor += 'B3'; // Add transparency
                    }
                }

                const conditions = [];
                const constellations = [];

                // Collect individual conditions
                const paramControls = groupElement.querySelectorAll('.parameter-control:not(.constellation-reference)');
                paramControls.forEach(control => {
                    const paramSelect = control.querySelector('.param-select');
                    const operatorSelect = control.querySelector('.condition-operator');

                    if (!paramSelect || !paramSelect.value) return;

                    const paramName = paramSelect.value;

                    // Handle "All Data" selection
                    if (paramName === '__all_data__') {
                        conditions.push({
                            parameter: '__all_data__',
                            operator: '=',
                            value: true,
                            type: 'special'
                        });
                        return;
                    }

                    if (!operatorSelect) return;

                    const operator = operatorSelect.value;
                    const paramType = globalState.columnTypes[paramName];

                    let conditionValue;

                    const valueElement = control.querySelector('.condition-value');
                    if (valueElement) {
                        if (scaleTypes[paramType].numeric) {
                            conditionValue = utils.parseNumericValue(valueElement.value);
                        } else {
                            conditionValue = valueElement.value;
                        }
                    }

                    if (conditionValue !== undefined && conditionValue !== null && (typeof conditionValue === 'string' || !isNaN(conditionValue))) {
                        conditions.push({
                            parameter: paramName,
                            operator: operator,
                            value: conditionValue,
                            type: paramType
                        });
                    }
                });

                // Collect constellation references
                const constellationControls = groupElement.querySelectorAll('.parameter-control.constellation-reference');
                constellationControls.forEach(control => {
                    const constellationSelect = control.querySelector('.constellation-select');
                    const negationCheckbox = control.querySelector('.negation-checkbox');

                    if (constellationSelect && constellationSelect.value) {
                        constellations.push({
                            name: constellationSelect.value,
                            negated: negationCheckbox ? negationCheckbox.checked : false
                        });
                    }
                });

                if (conditions.length > 0 || constellations.length > 0) {
            globalState.groupDefinitions.push({
                id: `group_${index}`,
                name: groupName,
                conditions: conditions,
                constellations: constellations,
                notInPrevious: notInPrevious,
                includeInAnalysis: includeInAnalysis,
                customColor: customColor,
                colorIndex: colorSelect.value !== 'custom' ? parseInt(colorSelect.value) : index % groupColors.length
            });
        }
    });

    // ADD THIS VALIDATION CODE HERE:
    // Validate group definitions
    globalState.groupDefinitions.forEach(group => {
        if (group.conditions.length === 0 && group.constellations.length === 0) {
            console.warn(`Group "${group.name}" has no conditions or constellations`);
        }
        
        // Check if referenced constellations exist
        group.constellations.forEach(constRef => {
            const exists = globalState.parameterConstellations.find(c => c.name === constRef.name);
            if (!exists) {
                console.error(`Group "${group.name}" references non-existent constellation "${constRef.name}"`);
            }
        });
    });
}

        /**
         * Filter data into defined groups
         */
        function filterDataIntoGroups() {
            globalState.processedData = {};
            globalState.currentGroups = {};

            // Initialize record assignments tracking
    globalState.recordAssignments = new Array(globalState.rawData.length).fill(null).map(() => []);

            // Initialize groups (only those included in analysis)
            globalState.groupDefinitions.forEach(group => {
                if (group.includeInAnalysis) {
                    globalState.processedData[group.id] = [];
                    globalState.currentGroups[group.id] = {
                        name: group.name,
                        count: 0,
                        customColor: group.customColor,
                        colorIndex: group.colorIndex
                    };
                }
            });

            // Process each group in order
            globalState.groupDefinitions.forEach((group, groupIndex) => {
                if (!group.includeInAnalysis) return;

                globalState.rawData.forEach((row, rowIndex) => {
    // Check if record should be excluded based on previous group membership
    if (group.notInPrevious && globalState.recordAssignments[rowIndex].length > 0) {
        return;
    }

    // Check if row matches group criteria
    if (checkRowAgainstGroupDefinition(row, group)) {
        globalState.processedData[group.id].push(row);
        globalState.recordAssignments[rowIndex].push(group.id);
    }
});
            });

            // Update group counts
            Object.keys(globalState.currentGroups).forEach(groupId => {
                globalState.currentGroups[groupId].count = globalState.processedData[groupId].length;
            });

        }

        /**
         * Check if a row matches a group definition
         */
        function checkRowAgainstGroupDefinition(row, group) {
    // 1. Check individual conditions
    const individualMatch = group.conditions.length === 0 ? true : 
        checkRowAgainstConditions(row, group.conditions);
    
    // 2. Check positive constellations
    const positiveConstellations = group.constellations
        .filter(c => !c.negated)
        .map(c => globalState.parameterConstellations.find(con => con.name === c.name))
        .filter(c => c);
    
    const positiveConstellationMatch = positiveConstellations.length === 0 ? true :
        positiveConstellations.every(constellation => 
            checkRowAgainstConditions(row, constellation.conditions)
        );
    
    // 3. Check negated constellations
    const negatedConstellations = group.constellations
        .filter(c => c.negated)
        .map(c => globalState.parameterConstellations.find(con => con.name === c.name))
        .filter(c => c);
    
    const negatedConstellationMatch = negatedConstellations.length === 0 ? true :
        negatedConstellations.every(constellation => 
            !checkRowAgainstConditions(row, constellation.conditions)
        );
        
    // 4. Combine results (individual AND positive-constellation AND negated-constellation)
    return individualMatch && positiveConstellationMatch && negatedConstellationMatch;
}

        /**
         * Check if a row matches all conditions in a group
         */
        function checkRowAgainstConditions(row, conditions) {
            return conditions.every(condition => {
                // Handle "All Data" condition
                if (condition.parameter === '__all_data__') {
                    return true; // Always matches
                }

                const value = row[condition.parameter];
                const { operator, value: conditionValue, type } = condition;

                if (scaleTypes[type].numeric) {
                    const numValue = utils.parseNumericValue(value);
                    const numConditionValue = utils.parseNumericValue(conditionValue);

                    if (isNaN(numValue) || isNaN(numConditionValue)) return false;

                    return utils.compareNumbers(numValue, numConditionValue, operator);
                } else if (type === 'k') {
    if (value === null || value === undefined || value === '') return false;

    switch (operator) {
        case '=': return String(value).trim() === String(conditionValue).trim();
        case '!=': return String(value).trim() !== String(conditionValue).trim();
        default: return false;
    }
                }

                return false;
            });
        }

        /**
         * Update analysis results
         */
        function updateAnalysisResults() {
            updateOverviewTab();
            updateParameterDropdowns();
            updateSignificanceGroupSelection();

            // Automatically select first numeric parameter for detailed analysis
            const numericParams = globalState.columnNames.filter(name =>
                scaleTypes[globalState.columnTypes[name]].numeric
            );
            if (numericParams.length > 0) {
                document.getElementById('detail-parameter-select').value = numericParams[0];
                updateDetailAnalysis();
            }
        }

        /**
         * Update overview tab with summary statistics
         */
        function updateOverviewTab() {
            // Group summary table
            const summaryContainer = document.getElementById('group-summary-table');
            let html = '<table style="width: 100%;"><thead><tr><th>Group</th><th>Count</th><th>Percent</th></tr></thead><tbody>';

            const totalPatients = globalState.rawData.length;

            Object.entries(globalState.currentGroups).forEach(([groupId, group], index) => {
                const percentage = ((group.count / totalPatients) * 100).toFixed(1);
                const color = group.customColor || groupColors[group.colorIndex];
                const bgColor = typeof color === 'string' ? color : color.bg;

                html += `
                    <tr>
                        <td>
                            <span class="group-badge" style="background-color: ${bgColor};">
                                ${group.name}
                            </span>
                        </td>
                        <td><strong>${group.count}</strong></td>
                        <td>${percentage}%</td>
                    </tr>
                `;
            });

            html += `
                <tr style="border-top: 2px solid #666; font-weight: bold;">
                    <td>Total</td>
                    <td>${totalPatients}</td>
                    <td>100%</td>
                </tr>
            `;
            html += '</tbody></table>';
            summaryContainer.innerHTML = html;

            // Group distribution chart
            updateGroupDistributionChart();

            // Overview statistics table
            updateOverviewStatsTable();
        }

        /**
         * Update group distribution chart
         */
        function updateGroupDistributionChart() {
            const ctx = document.getElementById('group-distribution-chart').getContext('2d');

            const labels = Object.values(globalState.currentGroups).map(group => group.name);
            const data = Object.values(globalState.currentGroups).map(group => group.count);

            const backgroundColors = Object.values(globalState.currentGroups).map(group => {
                if (group.customColor) {
                    return group.customColor;
                }
                return groupColors[group.colorIndex].bg;
            });

            const borderColors = Object.values(globalState.currentGroups).map(group => {
                if (group.customColor) {
                    // Convert custom color to border (remove transparency)
                    return group.customColor.replace('B3', '');
                }
                return groupColors[group.colorIndex].border;
            });

            utils.destroyChart('group-distribution-chart');

            globalState.charts['group-distribution-chart'] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Distribution of Records',
                            font: { size: 16 },
                            color: '#e0e0e0'
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#e0e0e0'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.label || '';
                                    const value = context.parsed;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        /**
         * Update overview statistics table
         */
        function updateOverviewStatsTable() {
            const table = document.getElementById('overview-stats-table');
            let html = '<thead><tr><th>Parameter</th><th>Scale</th><th>Group</th><th>N</th><th>Mean/Median</th><th>SD/IQR</th><th>Min</th><th>Max</th></tr></thead><tbody>';

            // All parameters
            globalState.columnNames.forEach(paramName => {
                const paramType = globalState.columnTypes[paramName];
                const scaleInfo = utils.getScaleInfo(paramType);

                Object.entries(globalState.currentGroups).forEach(([groupId, group], index) => {
                    const color = group.customColor || groupColors[group.colorIndex];
                    const bgColor = typeof color === 'string' ? color : color.bg;

                    if (scaleTypes[paramType].numeric) {
                        // Numeric parameters
                        const groupData = globalState.processedData[groupId]
                            .map(row => utils.parseNumericValue(row[paramName]))
                            .filter(val => !isNaN(val));

                        const stats = statistics.calculate(groupData);

                        let centralTendency = '-';
                        let dispersion = '-';

                        if (stats.count > 0) {
                            if (paramType === 'o') {
                                // Ordinal: use median and IQR
                                centralTendency = utils.formatNumber(stats.median, 2);
                                dispersion = utils.formatNumber(stats.iqr, 2);
                            } else {
                                // Interval/Ratio: use mean and SD
                                centralTendency = utils.formatNumber(stats.mean, 2);
                                dispersion = utils.formatNumber(stats.stdDev, 2);
                            }
                        }

                        html += `
                            <tr>
                                <td><strong>${paramName}</strong></td>
                                <td><span class="scale-badge ${scaleInfo.class}">${paramType.toUpperCase()}</span></td>
                                <td>
                                    <span class="group-badge" style="background-color: ${bgColor};">
                                        ${group.name}
                                    </span>
                                </td>
                                <td>${stats.count}</td>
                                <td>${centralTendency}</td>
                                <td>${dispersion}</td>
                                <td>${stats.min !== null ? utils.formatNumber(stats.min, 2) : '-'}</td>
                                <td>${stats.max !== null ? utils.formatNumber(stats.max, 2) : '-'}</td>
                            </tr>
                        `;
                    } else {
                        // Categorical parameters
                        const groupData = globalState.processedData[groupId]
                            .map(row => row[paramName])
                            .filter(val => val !== null && val !== undefined && val !== '');

                        const uniqueValues = [...new Set(groupData)];
                        const mode = uniqueValues.length > 0 ?
                            uniqueValues.reduce((a, b) =>
                                groupData.filter(v => v === a).length >= groupData.filter(v => v === b).length ? a : b
                            ) : '-';

                        html += `
                            <tr>
                                <td><strong>${paramName}</strong></td>
                                <td><span class="scale-badge ${scaleInfo.class}">${paramType.toUpperCase()}</span></td>
                                <td>
                                    <span class="group-badge" style="background-color: ${bgColor};">
                                        ${group.name}
                                    </span>
                                </td>
                                <td>${groupData.length}</td>
                                <td colspan="2">Mode: ${mode}</td>
                                <td colspan="2">${uniqueValues.length} categories</td>
                            </tr>
                        `;
                    }
                });
            });

            html += '</tbody>';
            table.innerHTML = html;
        }

        /**
         * Update significance test group selection
         */
        function updateSignificanceGroupSelection() {
            const container = document.getElementById('sig-group-selection');
            container.innerHTML = '';

            Object.entries(globalState.currentGroups).forEach(([groupId, group], index) => {
                const color = group.customColor || groupColors[group.colorIndex];
                const bgColor = typeof color === 'string' ? color : color.bg;

                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'checkbox-container';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `sig-group-${groupId}`;
                checkbox.value = groupId;
                checkbox.checked = true;

                const label = document.createElement('label');
                label.htmlFor = `sig-group-${groupId}`;
                label.innerHTML = `
            <span class="group-badge" style="background-color: ${bgColor};">
                ${group.name}
            </span> (n=${group.count})
        `;

                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                container.appendChild(checkboxDiv);
            });
        }

        /**
         * Update parameter dropdowns across the application
         */
        function updateParameterDropdowns() {
            // Detailed analysis
            const detailSelect = document.getElementById('detail-parameter-select');
            detailSelect.innerHTML = '<option value="">Select parameter</option>';

            // Significance test
            const sigSelect = document.getElementById('sig-parameter-select');
            sigSelect.innerHTML = '<option value="">Select parameter</option>';

            // Visualization
            const vizXSelect = document.getElementById('viz-parameter-x');
            const vizYSelect = document.getElementById('viz-parameter-y');
            vizXSelect.innerHTML = '<option value="">Select parameter</option>';
            vizYSelect.innerHTML = '<option value="">Select parameter</option>';

            // Add all parameters
            globalState.columnNames.forEach(name => {
                const type = globalState.columnTypes[name];
                const scaleInfo = utils.getScaleInfo(type);

                // Add parameter to all dropdowns with scale info
                const optionText = `${name} (${scaleInfo.name})`;

                const vizXOption = new Option(optionText, name);
                vizXSelect.add(vizXOption);

                const sigOption = new Option(optionText, name);
                sigSelect.add(sigOption);

                // Detailed analysis and Y-axis: numeric parameters only
                if (scaleTypes[type].numeric) {
                    const detailOption = new Option(optionText, name);
                    detailSelect.add(detailOption);

                    const vizYOption = new Option(optionText, name);
                    vizYSelect.add(vizYOption);
                }
            });

            // Update significance test groups
            //updateSignificanceGroupSelection();
        }

        /**
         * Update detailed analysis based on selected parameter
         */
        function updateDetailAnalysis() {
            const paramName = document.getElementById('detail-parameter-select').value;

            if (!paramName || !scaleTypes[globalState.columnTypes[paramName]].numeric) {
                // Show empty content
                document.getElementById('detail-analysis-content').innerHTML =
                    '<p style="text-align: center; color: #666; margin: 40px 0;">Please select a numeric parameter (ordinal, interval, or ratio scale).</p>';
                return;
            }

            // Collect data for each group
            const groupData = {};
            Object.keys(globalState.currentGroups).forEach(groupId => {
                groupData[groupId] = globalState.processedData[groupId]
                    .map(row => utils.parseNumericValue(row[paramName]))
                    .filter(val => !isNaN(val));
            });

            // Mean chart
            updateDetailMeanChart(paramName, groupData);

            // Distribution chart
            updateDetailDistributionChart(paramName, groupData);

            // Detailed statistics table
            updateDetailStatsTable(paramName, groupData);

            // Initialize histogram group selection
            initializeHistogramGroupSelection(paramName, groupData);

            // Create histogram with all groups selected initially
            updateDetailHistogram(paramName, groupData);
        }

        /**
         * Update mean value chart with error bars
         */
        function updateDetailMeanChart(paramName, groupData) {
            const ctx = document.getElementById('detail-mean-chart').getContext('2d');
            const paramType = globalState.columnTypes[paramName];

            const labels = Object.values(globalState.currentGroups).map(group => group.name);
            const means = Object.entries(groupData).map(([groupId, data]) => {
                if (data.length === 0) return 0;
                const stats = statistics.calculate(data);
                // Use median for ordinal, mean for interval/ratio
                return paramType === 'o' ? stats.median : stats.mean;
            });

            const stdDevs = Object.entries(groupData).map(([groupId, data]) => {
                if (data.length <= 1) return 0;
                const stats = statistics.calculate(data);
                // Use IQR for ordinal, SD for interval/ratio
                return paramType === 'o' ? stats.iqr / 2 : stats.stdDev;
            });

            const backgroundColors = Object.values(globalState.currentGroups).map(group => {
                if (group.customColor) {
                    return group.customColor;
                }
                return groupColors[group.colorIndex].bg;
            });

            const borderColors = Object.values(globalState.currentGroups).map(group => {
                if (group.customColor) {
                    return group.customColor.replace('B3', '');
                }
                return groupColors[group.colorIndex].border;
            });

            // Calculate Y-axis range
            const allValues = Object.values(groupData).flat();
            const yRange = utils.calculateYAxisRange(allValues, paramType);

            utils.destroyChart('detail-mean-chart');

            const chartLabel = paramType === 'o' ? 'Median' : 'Mean';

            globalState.charts['detail-mean-chart'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: chartLabel,
                        data: means,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            min: yRange.min,
                            max: yRange.max,
                            title: {
                                display: true,
                                text: paramName,
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        },
                        x: {
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `${chartLabel} Values: ${paramName}`,
                            font: { size: 14 },
                            color: '#e0e0e0'
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const index = context.dataIndex;
                                    const value = means[index];
                                    const error = stdDevs[index];
                                    const errorLabel = paramType === 'o' ? 'IQR/2' : 'Std Dev';
                                    return [
                                        `${chartLabel}: ${utils.formatNumber(value, 2)}`,
                                        `${errorLabel}: ${utils.formatNumber(error, 2)}`,
                                        `N: ${Object.values(groupData)[index].length}`
                                    ];
                                }
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'errorBars',
                    afterDraw: function (chart) {
                        const ctx = chart.ctx;
                        chart.data.datasets.forEach((dataset, datasetIndex) => {
                            const meta = chart.getDatasetMeta(datasetIndex);

                            meta.data.forEach((element, index) => {
                                const stdDev = stdDevs[index];
                                const mean = means[index];

                                if (stdDev > 0) {
                                    const centerX = element.x;
                                    const scale = chart.scales.y;
                                    const topY = scale.getPixelForValue(mean + stdDev);
                                    const bottomY = scale.getPixelForValue(mean - stdDev);
                                    const barWidth = 10;

                                    ctx.save();
                                    ctx.strokeStyle = borderColors[index];
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();

                                    // Vertical line
                                    ctx.moveTo(centerX, topY);
                                    ctx.lineTo(centerX, bottomY);

                                    // Top cap
                                    ctx.moveTo(centerX - barWidth / 2, topY);
                                    ctx.lineTo(centerX + barWidth / 2, topY);

                                    // Bottom cap
                                    ctx.moveTo(centerX - barWidth / 2, bottomY);
                                    ctx.lineTo(centerX + barWidth / 2, bottomY);

                                    ctx.stroke();
                                    ctx.restore();
                                }
                            });
                        });
                    }
                }]
            });
        }

        /**
         * Update distribution comparison chart
         */
        function updateDetailDistributionChart(paramName, groupData) {
            const ctx = document.getElementById('detail-distribution-chart').getContext('2d');
            const paramType = globalState.columnTypes[paramName];

            // Create histogram-like representation for each group
            const labels = Object.values(globalState.currentGroups).map(group => group.name);

            // Quartiles as stacked bars
            const q1Data = [], medianData = [], q3Data = [], minData = [], maxData = [];

            Object.entries(groupData).forEach(([groupId, data]) => {
                const stats = statistics.calculate(data);
                minData.push(stats.min || 0);
                q1Data.push(stats.q1 || 0);
                medianData.push(stats.median || 0);
                q3Data.push(stats.q3 || 0);
                maxData.push(stats.max || 0);
            });

            const backgroundColors = Object.values(globalState.currentGroups).map(group => {
                if (group.customColor) {
                    return group.customColor;
                }
                return groupColors[group.colorIndex].bg;
            });

            // Calculate Y-axis range
            const allValues = [...minData, ...maxData];
            const yRange = utils.calculateYAxisRange(allValues, paramType);

            utils.destroyChart('detail-distribution-chart');

            globalState.charts['detail-distribution-chart'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Minimum',
                            data: minData,
                            backgroundColor: backgroundColors.map(color => color.replace('0.7', '0.3')),
                            borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                            borderWidth: 1
                        },
                        {
                            label: 'Q1',
                            data: q1Data,
                            backgroundColor: backgroundColors.map(color => color.replace('0.7', '0.5')),
                            borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                            borderWidth: 1
                        },
                        {
                            label: 'Median',
                            data: medianData,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                            borderWidth: 2
                        },
                        {
                            label: 'Q3',
                            data: q3Data,
                            backgroundColor: backgroundColors.map(color => color.replace('0.7', '0.5')),
                            borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                            borderWidth: 1
                        },
                        {
                            label: 'Maximum',
                            data: maxData,
                            backgroundColor: backgroundColors.map(color => color.replace('0.7', '0.3')),
                            borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            min: yRange.min,
                            max: yRange.max,
                            title: {
                                display: true,
                                text: paramName,
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        },
                        x: {
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Distribution: ${paramName}`,
                            font: { size: 14 },
                            color: '#e0e0e0'
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#e0e0e0'
                            }
                        }
                    }
                }
            });
        }

        /**
         * Update detailed statistics table
         */
        function updateDetailStatsTable(paramName, groupData) {
            const table = document.getElementById('detail-stats-table');
            const paramType = globalState.columnTypes[paramName];

            let html = '<thead><tr><th>Group</th><th>N</th>';

            if (paramType === 'o') {
                // Ordinal: focus on median and quartiles
                html += '<th>Median</th><th>Q1</th><th>Q3</th><th>IQR</th><th>Min</th><th>Max</th><th>Range</th>';
            } else {
                // Interval/Ratio: full statistics
                html += '<th>Mean</th><th>Median</th><th>Std Dev</th><th>Min</th><th>Max</th><th>Q1</th><th>Q3</th><th>IQR</th>';
                if (paramType === 'r') {
                    html += '<th>CV (%)</th>';
                }
            }

            html += '</tr></thead><tbody>';

            Object.entries(groupData).forEach(([groupId, data], index) => {
                const stats = statistics.calculate(data);
                const group = globalState.currentGroups[groupId];
                const color = group.customColor || groupColors[group.colorIndex];
                const bgColor = typeof color === 'string' ? color : color.bg;

                html += `
                    <tr>
                        <td>
                            <span class="group-badge" style="background-color: ${bgColor};">
                                ${group.name}
                            </span>
                        </td>
                        <td>${stats.count}</td>
                `;

                if (paramType === 'o') {
                    // Ordinal statistics
                    html += `
                        <td>${stats.median !== null ? utils.formatNumber(stats.median, 2) : '-'}</td>
                        <td>${stats.q1 !== null ? utils.formatNumber(stats.q1, 2) : '-'}</td>
                        <td>${stats.q3 !== null ? utils.formatNumber(stats.q3, 2) : '-'}</td>
                        <td>${stats.iqr !== null ? utils.formatNumber(stats.iqr, 2) : '-'}</td>
                        <td>${stats.min !== null ? utils.formatNumber(stats.min, 2) : '-'}</td>
                        <td>${stats.max !== null ? utils.formatNumber(stats.max, 2) : '-'}</td>
                        <td>${stats.range !== null ? utils.formatNumber(stats.range, 2) : '-'}</td>
                    `;
                } else {
                    // Interval/Ratio statistics
                    html += `
                        <td>${stats.mean !== null ? utils.formatNumber(stats.mean, 3) : '-'}</td>
                        <td>${stats.median !== null ? utils.formatNumber(stats.median, 3) : '-'}</td>
                        <td>${stats.stdDev !== null ? utils.formatNumber(stats.stdDev, 3) : '-'}</td>
                        <td>${stats.min !== null ? utils.formatNumber(stats.min, 3) : '-'}</td>
                        <td>${stats.max !== null ? utils.formatNumber(stats.max, 3) : '-'}</td>
                        <td>${stats.q1 !== null ? utils.formatNumber(stats.q1, 3) : '-'}</td>
                        <td>${stats.q3 !== null ? utils.formatNumber(stats.q3, 3) : '-'}</td>
                        <td>${stats.iqr !== null ? utils.formatNumber(stats.iqr, 3) : '-'}</td>
                    `;

                    if (paramType === 'r') {
                        html += `<td>${stats.cv !== null ? utils.formatNumber(stats.cv, 1) : '-'}</td>`;
                    }
                }

                html += '</tr>';
            });

            html += '</tbody>';
            table.innerHTML = html;
        }

        /**
         * Initialize group selection checkboxes for histogram
         */
        function initializeHistogramGroupSelection(paramName, groupData) {
            const container = document.getElementById('histogram-group-selection');
            container.innerHTML = '';

            // Create checkboxes for each group
            Object.entries(globalState.currentGroups).forEach(([groupId, group]) => {
                const color = group.customColor || groupColors[group.colorIndex];
                const bgColor = typeof color === 'string' ? color : color.bg;

                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'checkbox-container';
                checkboxDiv.style.marginBottom = '0';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `histogram-group-${groupId}`;
                checkbox.value = groupId;
                checkbox.checked = true; // All selected by default

                // Add change listener
                checkbox.addEventListener('change', () => {
                    updateDetailHistogram(paramName, groupData);
                });

                const label = document.createElement('label');
                label.htmlFor = `histogram-group-${groupId}`;
                label.innerHTML = `
            <span class="group-badge" style="background-color: ${bgColor};">
                ${group.name}
            </span> (n=${groupData[groupId].length})
        `;

                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                container.appendChild(checkboxDiv);
            });

            // Set up select all/none buttons
            document.getElementById('histogram-select-all').addEventListener('click', () => {
                document.querySelectorAll('#histogram-group-selection input[type="checkbox"]').forEach(cb => {
                    cb.checked = true;
                });
                updateDetailHistogram(paramName, groupData);
            });

            document.getElementById('histogram-select-none').addEventListener('click', () => {
                document.querySelectorAll('#histogram-group-selection input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                updateDetailHistogram(paramName, groupData);
            });
        }

        /**
         * Update histogram chart for distribution analysis
         */
        function updateDetailHistogram(paramName, groupData) {
            const ctx = document.getElementById('detail-histogram-chart').getContext('2d');
            const paramType = globalState.columnTypes[paramName];

            // Destroy existing chart
            utils.destroyChart('detail-histogram-chart');

            // Get selected groups
            const selectedGroups = [];
            document.querySelectorAll('#histogram-group-selection input:checked').forEach(checkbox => {
                selectedGroups.push(checkbox.value);
            });

            if (selectedGroups.length === 0) {
                // Show message when no groups selected
                ctx.font = '16px Arial';
                ctx.fillStyle = '#666';
                ctx.textAlign = 'center';
                ctx.fillText('Please select at least one group to display', ctx.canvas.width / 2, ctx.canvas.height / 2);
                return;
            }

            // Collect data from selected groups
            const allData = [];
            const groupDataMap = {};

            selectedGroups.forEach(groupId => {
                const data = groupData[groupId] || [];
                groupDataMap[groupId] = data;
                allData.push(...data);
            });

            if (allData.length === 0) {
                return;
            }

            // Sort data
            allData.sort((a, b) => a - b);

            // Calculate number of bins using Sturges' rule
            const numBins = Math.max(5, Math.ceil(Math.log2(allData.length) + 1));
            const min = allData[0];
            const max = allData[allData.length - 1];
            const binWidth = (max - min) / numBins;

            // Create bins
            const bins = [];
            const binLabels = [];

            for (let i = 0; i < numBins; i++) {
                const binStart = min + i * binWidth;
                const binEnd = binStart + binWidth;
                bins.push({
                    start: binStart,
                    end: binEnd,
                    midpoint: (binStart + binEnd) / 2
                });

                // Format bin labels
                if (paramType === 'o') {
                    binLabels.push(`${Math.round(binStart)}-${Math.round(binEnd)}`);
                } else {
                    binLabels.push(`${binStart.toFixed(1)}-${binEnd.toFixed(1)}`);
                }
            }

            // Create datasets
            const datasets = [];

            // Add histogram for each selected group
            selectedGroups.forEach(groupId => {
                const group = globalState.currentGroups[groupId];
                const color = group.customColor || groupColors[group.colorIndex];
                const bgColor = typeof color === 'string' ? color : color.bg;
                const borderColor = typeof color === 'string' ? color.replace('B3', '') : color.border;

                // Count data points in each bin for this group
                const binCounts = new Array(numBins).fill(0);
                groupDataMap[groupId].forEach(value => {
                    const binIndex = Math.min(Math.floor((value - min) / binWidth), numBins - 1);
                    if (binIndex >= 0 && binIndex < numBins) {
                        binCounts[binIndex]++;
                    }
                });

                datasets.push({
                    label: group.name,
                    data: binCounts,
                    backgroundColor: bgColor.replace('0.7', '0.5'),
                    borderColor: borderColor,
                    borderWidth: 1,
                    type: 'bar'
                });
            });

            // Add overall distribution line if multiple groups selected
            if (selectedGroups.length > 1) {
                const overallBinCounts = new Array(numBins).fill(0);
                allData.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - min) / binWidth), numBins - 1);
                    if (binIndex >= 0 && binIndex < numBins) {
                        overallBinCounts[binIndex]++;
                    }
                });

                datasets.push({
                    label: 'Combined Distribution',
                    data: overallBinCounts,
                    borderColor: 'rgba(255, 255, 255, 0.8)',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    borderDash: [10, 5],
                    type: 'line',
                    fill: false,
                    tension: 0.1,
                    pointRadius: 3
                });
            }

            // Calculate and add normal distribution curve for overall data
            const mean = allData.reduce((sum, val) => sum + val, 0) / allData.length;
            const variance = allData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (allData.length - 1);
            const stdDev = Math.sqrt(variance);

            // Generate normal distribution curve
            const curveData = bins.map(bin => {
                const z = (bin.midpoint - mean) / stdDev;
                const y = (1 / (stdDev * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * z * z);
                return y * allData.length * binWidth;
            });

            datasets.push({
                label: 'Normal Distribution',
                data: curveData,
                borderColor: 'rgba(255, 99, 132, 1)',
                backgroundColor: 'transparent',
                borderWidth: 2,
                borderDash: [5, 5],
                type: 'line',
                fill: false,
                tension: 0.4,
                pointRadius: 0
            });

            // Create the chart
            globalState.charts['detail-histogram-chart'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: paramName + ' (Bins)',
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0',
                                maxRotation: 45,
                                minRotation: 0
                            },
                            grid: {
                                color: '#444'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency',
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Distribution of ${paramName} (n=${allData.length})`,
                            font: { size: 14 },
                            color: '#e0e0e0'
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#e0e0e0',
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function (context) {
                                    const label = context.dataset.label || '';
                                    if (context.dataset.type === 'bar') {
                                        const count = context.parsed.y;
                                        const total = context.dataset.data.reduce((sum, val) => sum + val, 0);
                                        const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : '0';
                                        return `${label}: ${count} (${percentage}%)`;
                                    } else if (label === 'Normal Distribution') {
                                        return `Expected: ${context.parsed.y.toFixed(1)}`;
                                    } else {
                                        return `${label}: ${context.parsed.y}`;
                                    }
                                }
                            }
                        }
                    }
                }
            });

            // Add normality test results for selected groups
            let subtitleText = '';
            if (selectedGroups.length === 1) {
                // Single group - show Shapiro-Wilk test
                const data = groupDataMap[selectedGroups[0]];
                const shapiroResult = statistics.shapiroWilkTest(data);
                if (!shapiroResult.error) {
                    subtitleText = shapiroResult.normal ?
                        `Shapiro-Wilk: W=${shapiroResult.W.toFixed(4)}, p=${shapiroResult.pValue.toFixed(4)} (Normal)` :
                        `Shapiro-Wilk: W=${shapiroResult.W.toFixed(4)}, p=${shapiroResult.pValue.toFixed(4)} (Not Normal)`;
                }
            } else {
                // Multiple groups - show overall statistics
                subtitleText = `Combined: μ=${mean.toFixed(2)}, σ=${stdDev.toFixed(2)}`;
            }

            if (subtitleText) {
                globalState.charts['detail-histogram-chart'].options.plugins.subtitle = {
                    display: true,
                    text: subtitleText,
                    color: '#e0e0e0',
                    font: { size: 12 }
                };
                globalState.charts['detail-histogram-chart'].update();
            }
        }

        /**
         * Clear significance test results
         */
        function clearSignificanceResults() {
            document.getElementById('significance-results').innerHTML = '';
            document.getElementById('prerequisite-results').innerHTML = '';
            globalState.prerequisiteResults = {};
        }

        /**
         * Check test requirements and generate violations list
         */
        function checkTestRequirements(testType, paramName, selectedGroups) {
            const violations = [];
            const paramType = globalState.columnTypes[paramName];
            const scaleInfo = scaleTypes[paramType];

            // Check scale type requirements
            switch (testType) {
                case 'ttest':
                case 'welch':
                case 'anova':
                    if (!scaleInfo.numeric || paramType === 'o') {
                        violations.push('Test requires interval or ratio scale data (currently: ' + scaleInfo.name + ')');
                    }
                    break;
                case 'chi-square':
                case 'fisher':
                    if (scaleInfo.numeric) {
                        violations.push('Test requires categorical (nominal) data');
                    }
                    break;
                case 'pearson':
                    if (!scaleInfo.numeric || paramType === 'o') {
                        violations.push('Pearson correlation requires interval or ratio scale data');
                    }
                    break;
            }

            // Check group count requirements
            if ((testType === 'ttest' || testType === 'welch' || testType === 'mann-whitney' || testType === 'fisher') && selectedGroups.length !== 2) {
                violations.push(`Test requires exactly 2 groups (selected: ${selectedGroups.length})`);
            }

            if ((testType === 'anova' || testType === 'kruskal-wallis') && selectedGroups.length < 2) {
                violations.push('Test requires at least 2 groups');
            }

            // Check normality if results exist
            if ((testType === 'ttest' || testType === 'welch' || testType === 'anova') && globalState.prerequisiteResults[paramName]) {
                selectedGroups.forEach(groupId => {
                    const prereq = globalState.prerequisiteResults[paramName][groupId];
                    if (prereq && prereq.normality && !prereq.normality.normal) {
                        const groupName = globalState.currentGroups[groupId].name;
                        violations.push(`Group "${groupName}" is not normally distributed (required for parametric tests)`);
                    }
                });
            }

            // Check variance homogeneity for t-test
            if (testType === 'ttest' && globalState.prerequisiteResults[paramName] && globalState.prerequisiteResults[paramName].varianceTest) {
                const varianceTest = globalState.prerequisiteResults[paramName].varianceTest;
                if (!varianceTest.equalVariances) {
                    violations.push('Groups have unequal variances (consider using Welch\'s t-test instead)');
                }
            }

            // Check sample size
            selectedGroups.forEach(groupId => {
                const groupData = globalState.processedData[groupId]
                    .map(row => scaleInfo.numeric ? utils.parseNumericValue(row[paramName]) : row[paramName])
                    .filter(val => val !== null && val !== undefined && (scaleInfo.numeric ? !isNaN(val) : val !== ''));

                if (groupData.length < 3 && (testType === 'ttest' || testType === 'welch' || testType === 'anova')) {
                    const groupName = globalState.currentGroups[groupId].name;
                    violations.push(`Group "${groupName}" has less than 3 observations (n=${groupData.length})`);
                }
            });

            return violations;
        }

        /**
         * Automatically selects the appropriate test based on parameter and group selection
         */
        function selectAppropriateTest(paramName, selectedGroups) {
            const paramType = globalState.columnTypes[paramName];
            const scaleInfo = scaleTypes[paramType];

            if (!scaleInfo.numeric) {
                // Categorical data
                if (selectedGroups.length === 2 && is2x2Table(paramName, selectedGroups)) {
                    return 'fisher';
                }
                return 'chi-square';
            }

            // Numeric data
            if (selectedGroups.length === 2) {
                // Check for normality if results exist
                const prereqs = globalState.prerequisiteResults[paramName];
                let isNormal = true;
                let equalVariances = true;

                if (prereqs) {
                    selectedGroups.forEach(groupId => {
                        if (prereqs[groupId] && prereqs[groupId].normality) {
                            isNormal = isNormal && prereqs[groupId].normality.normal;
                        }
                    });

                    if (prereqs.varianceTest) {
                        equalVariances = prereqs.varianceTest.equalVariances;
                    }
                }

                if (paramType === 'o') {
                    // Ordinal data - use non-parametric
                    return 'mann-whitney';
                } else if (isNormal && equalVariances) {
                    return 'ttest';
                } else if (isNormal && !equalVariances) {
                    return 'welch';
                } else {
                    return 'mann-whitney';
                }
            } else if (selectedGroups.length > 2) {
                // Check for normality
                const prereqs = globalState.prerequisiteResults[paramName];
                let isNormal = true;

                if (prereqs) {
                    selectedGroups.forEach(groupId => {
                        if (prereqs[groupId] && prereqs[groupId].normality) {
                            isNormal = isNormal && prereqs[groupId].normality.normal;
                        }
                    });
                }

                if (paramType === 'o' || !isNormal) {
                    return 'kruskal-wallis';
                } else {
                    return 'anova';
                }
            }

            return 'auto';
        }

        /**
         * Check if data forms a 2x2 table for Fisher's exact test
         */
        function is2x2Table(paramName, selectedGroups) {
            if (selectedGroups.length !== 2) return false;

            const allValues = [];
            selectedGroups.forEach(groupId => {
                const values = globalState.processedData[groupId]
                    .map(row => row[paramName])
                    .filter(val => val !== null && val !== undefined && val !== '');
                allValues.push(...values);
            });

            const uniqueValues = [...new Set(allValues)];
            return uniqueValues.length === 2;
        }

        /**
         * Run statistical significance test
         */
        function runSignificanceTest() {
            const paramName = document.getElementById('sig-parameter-select').value;
            if (!paramName) {
                utils.showError("Please select a parameter for significance testing.");
                return;
            }

            let testType = document.getElementById('sig-test-type').value;
            const forceExecution = document.getElementById('force-test-execution').checked;

            // Get alpha level
            let alpha = 0.05;
            const alphaSelect = document.getElementById('sig-alpha');
            if (alphaSelect.value === 'custom') {
                alpha = parseFloat(document.getElementById('sig-custom-alpha').value);
                if (isNaN(alpha) || alpha <= 0 || alpha >= 1) {
                    utils.showError("Custom alpha must be between 0 and 1.");
                    return;
                }
            } else {
                alpha = parseFloat(alphaSelect.value);
            }

            // Get test direction
            const direction = document.getElementById('sig-direction').value;

            // Get selected groups
            const selectedGroups = [];
            document.querySelectorAll('#sig-group-selection input:checked').forEach(checkbox => {
                selectedGroups.push(checkbox.value);
            });

            if (selectedGroups.length < 1) {
                utils.showError("Please select at least one group for comparison.");
                return;
            }

            // Auto-select appropriate test if needed
            if (testType === 'auto') {
                testType = selectAppropriateTest(paramName, selectedGroups);
            }

            // Check test requirements
            const violations = checkTestRequirements(testType, paramName, selectedGroups);

            // If violations exist and force execution is not enabled, show error
            if (violations.length > 0 && !forceExecution) {
                utils.showError(`Test requirements not met:\n• ${violations.join('\n• ')}\n\nEnable "Force test execution" to run anyway.`);
                return;
            }

            // Run the appropriate test
            let result;
            const testOptions = { alpha, direction };

            try {
                switch (testType) {
                    case 'ttest':
                        result = runTTest(paramName, selectedGroups, testOptions);
                        break;
                    case 'welch':
                        result = runWelchTest(paramName, selectedGroups, testOptions);
                        break;
                    case 'anova':
                        result = runANOVA(paramName, selectedGroups, testOptions);
                        break;
                    case 'mann-whitney':
                        result = runMannWhitney(paramName, selectedGroups, testOptions);
                        break;
                    case 'kruskal-wallis':
                        result = runKruskalWallis(paramName, selectedGroups, testOptions);
                        break;
                    case 'chi-square':
                        result = runChiSquare(paramName, selectedGroups, testOptions);
                        break;
                    case 'fisher':
                        result = runFisherExact(paramName, selectedGroups, testOptions);
                        break;
                    case 'pearson':
                        result = runPearsonCorrelation(paramName, selectedGroups, testOptions);
                        break;
                    case 'spearman':
                        result = runSpearmanCorrelation(paramName, selectedGroups, testOptions);
                        break;
                    default:
                        utils.showError("Unknown test type selected.");
                        return;
                }

                if (!result) {
                    utils.showError("Test could not be performed. Check your data.");
                    return;
                }

                if (result.error) {
                    utils.showError(result.error);
                    return;
                }

                // Add violations to result if forced
                if (violations.length > 0) {
                    result.violations = violations;
                }

                // Store result for export
                globalState.significanceResults.push({
                    paramName: paramName,
                    groupNames: selectedGroups.map(id => globalState.currentGroups[id].name),
                    result: result,
                    timestamp: new Date()
                });

                // Display results
                displaySignificanceResults(result, paramName, selectedGroups.map(id => globalState.currentGroups[id].name), violations);

            } catch (error) {
                console.error('Test execution error:', error);
                utils.showError(`Error running test: ${error.message}`);
            }
        }

        /**
         * Run t-test
         */
        function runTTest(paramName, selectedGroups, options) {
            if (selectedGroups.length !== 2) {
                return { error: "t-test requires exactly 2 groups." };
            }

            const group1Data = globalState.processedData[selectedGroups[0]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            const group2Data = globalState.processedData[selectedGroups[1]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            return utils.runStatisticalTest(statistics.tTest, group1Data, group2Data, options);
        }

        /**
         * Run Welch's t-test
         */
        function runWelchTest(paramName, selectedGroups, options) {
            if (selectedGroups.length !== 2) {
                return { error: "Welch's t-test requires exactly 2 groups." };
            }

            const group1Data = globalState.processedData[selectedGroups[0]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            const group2Data = globalState.processedData[selectedGroups[1]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            return utils.runStatisticalTest(statistics.welchTTest, group1Data, group2Data, options);
        }

        /**
         * Run ANOVA
         */
        function runANOVA(paramName, selectedGroups, options) {
            if (selectedGroups.length < 2) {
                return { error: "ANOVA requires at least 2 groups." };
            }

            const groupDataArrays = selectedGroups.map(groupId => {
                return globalState.processedData[groupId]
                    .map(row => utils.parseNumericValue(row[paramName]))
                    .filter(val => !isNaN(val));
            });

            return utils.runStatisticalTest(statistics.anova, groupDataArrays, options);
        }

        /**
         * Run Mann-Whitney U test
         */
        function runMannWhitney(paramName, selectedGroups, options) {
            if (selectedGroups.length !== 2) {
                return { error: "Mann-Whitney U test requires exactly 2 groups." };
            }

            const group1Data = globalState.processedData[selectedGroups[0]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            const group2Data = globalState.processedData[selectedGroups[1]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            return utils.runStatisticalTest(statistics.mannWhitneyU, group1Data, group2Data, options);
        }

        /**
         * Run Kruskal-Wallis test
         */
        function runKruskalWallis(paramName, selectedGroups, options) {
            if (selectedGroups.length < 2) {
                return { error: "Kruskal-Wallis test requires at least 2 groups." };
            }

            const groupDataArrays = selectedGroups.map(groupId => {
                return globalState.processedData[groupId]
                    .map(row => utils.parseNumericValue(row[paramName]))
                    .filter(val => !isNaN(val));
            });

            return utils.runStatisticalTest(statistics.kruskalWallis, groupDataArrays, options);
        }

        /**
         * Run Chi-square test
         */
        function runChiSquare(paramName, selectedGroups, options) {
            const selectedGroupData = {};
            selectedGroups.forEach(groupId => {
                selectedGroupData[groupId] = globalState.processedData[groupId];
            });

            return utils.runStatisticalTest(statistics.chiSquareTest, paramName, selectedGroupData, options);
        }

        /**
         * Run Fisher's exact test
         */
        function runFisherExact(paramName, selectedGroups, options) {
            if (selectedGroups.length !== 2) {
                return { error: "Fisher's exact test requires exactly 2 groups." };
            }

            // Get unique categories
            const allValues = [];
            selectedGroups.forEach(groupId => {
                const values = globalState.processedData[groupId]
                    .map(row => row[paramName])
                    .filter(val => val !== null && val !== undefined && val !== '');
                allValues.push(...values);
            });

            const categories = [...new Set(allValues)];
            if (categories.length !== 2) {
                return { error: "Fisher's exact test requires exactly 2 categories." };
            }

            // Build 2x2 table
            const table = [[0, 0], [0, 0]];

            selectedGroups.forEach((groupId, groupIndex) => {
                globalState.processedData[groupId].forEach(row => {
                    const value = row[paramName];
                    if (value === categories[0]) {
                        table[groupIndex][0]++;
                    } else if (value === categories[1]) {
                        table[groupIndex][1]++;
                    }
                });
            });

            const result = utils.runStatisticalTest(statistics.fisherExactTest, table, options);
            if (result) {
                result.categories = categories;
                result.groups = selectedGroups.map(id => globalState.currentGroups[id].name);
            }

            return result;
        }

        /**
         * Run Pearson correlation
         */
        function runPearsonCorrelation(paramName, selectedGroups, options) {
            // For correlation, we need two numeric parameters
            // This is a simplified version - in practice, you'd select two parameters
            return { error: "Pearson correlation requires selecting two numeric parameters. Please use the visualization tab for correlation analysis." };
        }

        /**
         * Run Spearman correlation
         */
        function runSpearmanCorrelation(paramName, selectedGroups, options) {
            // For correlation, we need two parameters
            // This is a simplified version - in practice, you'd select two parameters
            return { error: "Spearman correlation requires selecting two parameters. Please use the visualization tab for correlation analysis." };
        }

        /**
         * Display significance test results
         */
        function displaySignificanceResults(result, paramName, groupNames, violations = []) {
            const container = document.getElementById('significance-results');

            const resultDiv = document.createElement('div');
            resultDiv.className = `significance-result ${result.significant ? 'significant' : 'not-significant'}`;

            // Initialize html variable here!
            let html = `
        <h4>${result.test} Results</h4>
        <p><strong>Parameter:</strong> ${paramName}</p>
    `;

            // Add multiple comparison warning if applicable
            if (globalState.significanceResults.length > 1) {
                html += `
            <div class="warning-box" style="margin: 10px 0;">
                <strong>⚠️ Multiple Testing Warning:</strong> 
                You have performed ${globalState.significanceResults.length} statistical tests. 
                Consider adjusting your significance level (currently α=${result.alpha}) to account for multiple comparisons 
                (e.g., Bonferroni correction: α/${globalState.significanceResults.length} = ${(result.alpha / globalState.significanceResults.length).toFixed(4)}).
            </div>
        `;
            }

            html += `<p><strong>Compared Groups:</strong> ${groupNames.join(', ')}</p>`;

            // Display violations if test was forced
            if (violations.length > 0) {
                html += `
            <div class="test-violation-warning">
                <h5>⚠️ Test Requirement Violations</h5>
                <p>The following test requirements were not met:</p>
                        <ul>
                            ${violations.map(v => `<li>${v}</li>`).join('')}
                        </ul>
                        <p><strong>Results should be interpreted with extreme caution!</strong></p>
                    </div>
                `;
            }

            // Test-specific results
            if (result.test === 't-Test' || result.test === "Welch's t-Test") {
                html += `
                    <div style="margin: 15px 0;">
                        <p><strong>Test Statistic:</strong> t = ${utils.formatNumber(result.statistic, 4)}</p>
                        <p><strong>Degrees of Freedom:</strong> df = ${utils.formatNumber(result.df, 2)}</p>
                        <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)} (${result.direction} test, α = ${result.alpha})</p>
                        <p><strong>Effect Size (Cohen's d):</strong> ${utils.formatNumber(result.effectSize, 3)}</p>
                        <p><strong>Mean Difference:</strong> ${utils.formatNumber(result.meanDifference, 3)}</p>
                        <p><strong>${(1 - result.alpha) * 100}% Confidence Interval:</strong> [${utils.formatNumber(result.confidenceInterval[0], 3)}, ${utils.formatNumber(result.confidenceInterval[1], 3)}]</p>
                        <p><strong>Statistical Power:</strong> ${utils.formatNumber(result.power, 3)}</p>
                    </div>
                    <div style="margin: 15px 0;">
                        <p><strong>Group 1:</strong> n=${result.group1Stats.count}, Mean=${utils.formatNumber(result.group1Stats.mean, 2)}, SD=${utils.formatNumber(result.group1Stats.stdDev, 2)}</p>
                        <p><strong>Group 2:</strong> n=${result.group2Stats.count}, Mean=${utils.formatNumber(result.group2Stats.mean, 2)}, SD=${utils.formatNumber(result.group2Stats.stdDev, 2)}</p>
                    </div>
                `;
            } else if (result.test === 'ANOVA') {
                html += `
                    <div style="margin: 15px 0;">
                        <p><strong>F-value:</strong> F(${result.dfBetween}, ${result.dfWithin}) = ${utils.formatNumber(result.statistic, 4)}</p>
                        <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)} (α = ${result.alpha})</p>
                        <p><strong>Effect Size (η²):</strong> ${utils.formatNumber(result.etaSquared, 3)}</p>
                        <p><strong>Statistical Power:</strong> ${utils.formatNumber(result.power, 3)}</p>
                    </div>
                    <div style="background-color: rgba(255,255,255,0.05); padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <p><strong>Sum of Squares:</strong></p>
                        <p>Between Groups: ${utils.formatNumber(result.ssb, 2)}</p>
                        <p>Within Groups: ${utils.formatNumber(result.ssw, 2)}</p>
                        <p>Mean Squares: MSB=${utils.formatNumber(result.msb, 2)}, MSW=${utils.formatNumber(result.msw, 2)}</p>
                    </div>
                `;
            } else if (result.test === 'Mann-Whitney U') {
                html += `
                    <div style="margin: 15px 0;">
                        <p><strong>U Statistic:</strong> U = ${utils.formatNumber(result.U, 0)}</p>
                        <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)} (${result.direction} test, α = ${result.alpha})</p>
                        <p><strong>Effect Size (r):</strong> ${utils.formatNumber(result.effectSize, 3)}</p>
                        <p><strong>Sample Sizes:</strong> n₁ = ${result.n1}, n₂ = ${result.n2}</p>
                        <p><strong>Rank Sums:</strong> R₁ = ${utils.formatNumber(result.rankSum1, 1)}, R₂ = ${utils.formatNumber(result.rankSum2, 1)}</p>
                        ${result.tieCorrection ? '<p><em>Note: Tie correction was applied</em></p>' : ''}
                    </div>
                `;
            } else if (result.test === 'Kruskal-Wallis') {
                html += `
                    <div style="margin: 15px 0;">
                        <p><strong>H Statistic:</strong> H = ${utils.formatNumber(result.H, 4)}</p>
                        <p><strong>Degrees of Freedom:</strong> df = ${result.df}</p>
                        <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)} (α = ${result.alpha})</p>
                        <p><strong>Effect Size (η²):</strong> ${utils.formatNumber(result.etaSquared, 3)}</p>
                        <p><strong>Total N:</strong> ${result.N}</p>
                        ${result.tieCorrection ? '<p><em>Note: Tie correction was applied</em></p>' : ''}
                    </div>
                `;
            } else if (result.test === 'Chi-Square') {
                html += `
                    <div style="margin: 15px 0;">
                        <p><strong>Chi-Square (χ²):</strong> ${utils.formatNumber(result.statistic, 4)}</p>
                        <p><strong>Degrees of Freedom:</strong> df = ${result.df}</p>
                        <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)} (α = ${result.alpha})</p>
                        <p><strong>Effect Size (Cramer's V):</strong> ${utils.formatNumber(result.cramersV, 3)}</p>
                        <p><strong>Statistical Power:</strong> ${utils.formatNumber(result.power, 3)}</p>
                    </div>
                `;

                // Display contingency table
                if (result.observed && result.categories && result.groups) {
                    html += `
                        <div style="margin: 15px 0;">
                            <p><strong>Contingency Table (Observed Frequencies):</strong></p>
                            <div style="overflow-x: auto; margin-top: 10px;">
                                <table style="width: auto;">
                                    <thead>
                                        <tr>
                                            <th>${paramName}</th>
                                            ${result.groups.map(group => `<th>${group}</th>`).join('')}
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;

                    result.categories.forEach((category, i) => {
                        html += `<tr><td>${category}</td>`;
                        result.observed[i].forEach(count => {
                            html += `<td>${count}</td>`;
                        });
                        html += `</tr>`;
                    });

                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }

                // Show warning if present
                if (result.warning) {
                    html += `<p style="color: #e74c3c;"><strong>Warning:</strong> ${result.warning}</p>`;
                }
            } else if (result.test === "Fisher's Exact Test") {
                html += `
                    <div style="margin: 15px 0;">
                        <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)} (α = ${result.alpha})</p>
                        <p><strong>Odds Ratio:</strong> ${utils.formatNumber(result.oddsRatio, 3)}</p>
                    </div>
                `;

                if (result.table && result.categories && result.groups) {
                    html += `
                        <div style="margin: 15px 0;">
                            <p><strong>2x2 Contingency Table:</strong></p>
                            <div style="overflow-x: auto; margin-top: 10px;">
                                <table style="width: auto;">
                                    <thead>
                                        <tr>
                                            <th>${paramName}</th>
                                            <th>${result.groups[0]}</th>
                                            <th>${result.groups[1]}</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>${result.categories[0]}</td>
                                            <td>${result.table[0][0]}</td>
                                            <td>${result.table[1][0]}</td>
                                        </tr>
                                        <tr>
                                            <td>${result.categories[1]}</td>
                                            <td>${result.table[0][1]}</td>
                                            <td>${result.table[1][1]}</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
            } else if (result.test === 'Spearman Correlation' || result.test === 'Pearson Correlation') {
                html += `
                    <div style="margin: 15px 0;">
                        <p><strong>Correlation Coefficient:</strong> ${result.test === 'Spearman' ? 'ρ' : 'r'} = ${utils.formatNumber(result.rho || result.r, 4)}</p>
                        <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)} (α = ${result.alpha})</p>
                        <p><strong>Sample Size:</strong> n = ${result.n}</p>
                        <p><strong>Interpretation:</strong> ${result.interpretation}</p>
                        <p><strong>Statistical Power:</strong> ${utils.formatNumber(result.power, 3)}</p>
                    </div>
                `;
            }

            html += `
                <div style="margin-top: 20px; padding: 15px; border-radius: 5px; ${result.significant ? 'background-color: rgba(82, 163, 115, 0.1);' : 'background-color: rgba(200, 84, 80, 0.1);'}">
                    <p><strong>Interpretation:</strong></p>
                    <p>${result.significant ?
                    `🟢 <strong>Significant Difference</strong> (p < ${result.alpha})<br>The null hypothesis is rejected. There is statistical evidence of a difference between the groups.` :
                    `🔴 <strong>No Significant Difference</strong> (p ≥ ${result.alpha})<br>The null hypothesis is maintained. There is insufficient statistical evidence of a difference between the groups.`
                }</p>
                </div>
            `;

            resultDiv.innerHTML = html;

            // Insert at the beginning of the results container
            if (container.firstChild) {
                container.insertBefore(resultDiv, container.firstChild);
            } else {
                container.appendChild(resultDiv);
            }
        }

        /**
         * Generate custom visualization
         */
        function generateCustomVisualization() {
            const paramX = document.getElementById('viz-parameter-x').value;
            const paramY = document.getElementById('viz-parameter-y').value;
            const chartType = document.getElementById('viz-chart-type').value;

            if (!paramX) {
                utils.showError("Please select a parameter for the X-axis.");
                return;
            }

            if (!paramY && chartType !== 'bar') {
                utils.showError("Please select a parameter for the Y-axis.");
                return;
            }

            const ctx = document.getElementById('custom-visualization-chart').getContext('2d');
            utils.destroyChart('custom-visualization-chart');

            if (chartType === 'scatter') {
                createScatterPlot(ctx, paramX, paramY);
            } else if (chartType === 'bar' || chartType === 'line') {
                createBarOrLinePlot(ctx, paramX, paramY, chartType);
            }
        }

        /**
         * Create scatter plot with optional regression lines
         */
        function createScatterPlot(ctx, paramX, paramY) {
            const datasets = [];
            const showRegression = document.getElementById('show-regression').checked;
            const regressionType = document.getElementById('regression-type').value;
            const alpha = parseFloat(document.getElementById('regression-alpha').value);
            let regressionInfo = '';

            // Check if both parameters are numeric for scatter plot
            const xIsNumeric = scaleTypes[globalState.columnTypes[paramX]].numeric;
            const yIsNumeric = scaleTypes[globalState.columnTypes[paramY]].numeric;

            if (!xIsNumeric || !yIsNumeric) {
                utils.showError("Scatter plot requires both X and Y axes to be numeric parameters (ordinal, interval, or ratio scale).");
                return;
            }

            // Get scale types for proper Y-axis range calculation
            const yScaleType = globalState.columnTypes[paramY];

            // Process each group
            Object.entries(globalState.currentGroups).forEach(([groupId, group], index) => {
                const color = group.customColor || groupColors[group.colorIndex];
                const bgColor = typeof color === 'string' ? color : color.bg;
                const borderColor = typeof color === 'string' ? color.replace('B3', '') : color.border;

                const points = globalState.processedData[groupId].map(row => {
                    const x = utils.parseNumericValue(row[paramX]);
                    const y = utils.parseNumericValue(row[paramY]);
                    return { x, y };
                }).filter(point => !isNaN(point.x) && !isNaN(point.y) && isFinite(point.x) && isFinite(point.y));

                if (points.length > 0) {
                    // Add scatter points
                    datasets.push({
                        label: group.name,
                        data: points,
                        backgroundColor: bgColor,
                        borderColor: borderColor,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        showLine: false
                    });

                    // Add regression line if requested
                    if (showRegression && points.length >= regressionTypes[regressionType].minPoints) {
                        let regression = null;

                        // Check if regression type is valid for the data
                        if (regressionTypes[regressionType].validate) {
                            if (!regressionTypes[regressionType].validate(points)) {
                                regressionInfo += `
                                    <div style="margin-bottom: 10px; color: ${borderColor};">
                                        <strong>${group.name}:</strong> Invalid data for ${regressionTypes[regressionType].name} regression
                                    </div>
                                `;
                                return;
                            }
                        }

                        // Calculate regression based on type
                        switch (regressionType) {
                            case 'linear':
                                regression = statistics.linearRegression(points);
                                break;
                            case 'polynomial2':
                                regression = statistics.polynomialRegression(points, 2);
                                break;
                            case 'polynomial3':
                                regression = statistics.polynomialRegression(points, 3);
                                break;
                            case 'logarithmic':
                                regression = statistics.logarithmicRegression(points);
                                break;
                            case 'exponential':
                                regression = statistics.exponentialRegression(points);
                                break;
                        }

                        if (regression && regression.predict) {
                            // Test regression significance
                            const sigTest = statistics.testRegressionSignificance(regression, regressionType, alpha);

                            // Calculate line points
                            const xValues = points.map(p => p.x);
                            const minX = Math.min(...xValues);
                            const maxX = Math.max(...xValues);

                            // Generate smooth curve for non-linear regressions
                            const numPoints = regressionType === 'linear' ? 2 : 100;
                            const linePoints = [];

                            for (let i = 0; i < numPoints; i++) {
                                const x = minX + (maxX - minX) * i / (numPoints - 1);
                                const y = regression.predict(x);
                                if (isFinite(y)) {
                                    linePoints.push({ x, y });
                                }
                            }

                            // Add regression line dataset
                            datasets.push({
                                label: `${group.name} Regression`,
                                data: linePoints,
                                backgroundColor: 'transparent',
                                borderColor: borderColor,
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                showLine: true,
                                fill: false
                            });

                            // Add to regression info with significance
                            const sigClass = sigTest.significant ? 'significant' : 'not-significant';
                            regressionInfo += `
                                <div class="regression-significance ${sigClass}" style="margin-bottom: 10px;">
                                    <div style="color: ${borderColor};">
                                        <strong>${group.name}:</strong> ${regression.equation}<br>
                                        R² = ${utils.formatNumber(regression.r2, 4)}, n = ${regression.n}
                                        ${regression.conditionNumber ? `<br><small>Condition number: ${utils.formatNumber(regression.conditionNumber, 2)}</small>` : ''}
                                    </div>
                            `;

                            if (sigTest.error) {
                                regressionInfo += `<div style="font-size: 0.85em; margin-top: 5px;">${sigTest.error}</div>`;
                            } else {
                                regressionInfo += `
                                    <div style="font-size: 0.85em; margin-top: 5px;">
                                        ${sigTest.fStatistic ? `F(${sigTest.df1},${sigTest.df2}) = ${utils.formatNumber(sigTest.fStatistic, 3)}, ` : ''}
                                        p = ${utils.formatNumber(sigTest.pValue, 4)}
                                        ${sigTest.significant ?
                                        `<span style="color: var(--secondary-color); font-weight: bold;"> ✓ Significant</span>` :
                                        `<span style="color: var(--danger-color);"> Not significant</span>`}
                                    </div>
                                `;
                            }

                            regressionInfo += `</div>`;
                        }
                    }
                }
            });

            if (datasets.length === 0) {
                utils.showError("No valid data points to display.");
                return;
            }

            // Update regression info display
            document.getElementById('regression-info').innerHTML = regressionInfo;

            // Y-axis range
            const allYValues = datasets
                .filter(ds => !ds.label.includes('Regression'))
                .flatMap(ds => ds.data.map(point => point.y));
            const yRange = utils.calculateYAxisRange(allYValues, yScaleType);

            // X-axis range
            const allXValues = datasets
                .filter(ds => !ds.label.includes('Regression'))
                .flatMap(ds => ds.data.map(point => point.x));
            const xMin = Math.min(...allXValues);
            const xMax = Math.max(...allXValues);
            const xPadding = (xMax - xMin) * 0.05;

            globalState.charts['custom-visualization-chart'] = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            min: xMin - xPadding,
                            max: xMax + xPadding,
                            title: {
                                display: true,
                                text: paramX,
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        },
                        y: {
                            min: yRange.min,
                            max: yRange.max,
                            title: {
                                display: true,
                                text: paramY,
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `${paramY} vs ${paramX}`,
                            font: { size: 16 },
                            color: '#e0e0e0'
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                filter: function (item) {
                                    // Hide regression labels from legend
                                    return !item.text.includes('Regression');
                                },
                                color: '#e0e0e0'
                            }
                        }
                    }
                }
            });
        }

        /**
         * Create bar or line plot
         */
        function createBarOrLinePlot(ctx, paramX, paramY, chartType) {
            // For categorical X-axis, aggregate data
            if (!scaleTypes[globalState.columnTypes[paramX]].numeric) {
                const categories = [...new Set(globalState.rawData.map(row => row[paramX]).filter(val => val))];

                const datasets = [];

                Object.entries(globalState.currentGroups).forEach(([groupId, group], index) => {
                    const color = group.customColor || groupColors[group.colorIndex];
                    const bgColor = typeof color === 'string' ? color : color.bg;
                    const borderColor = typeof color === 'string' ? color.replace('B3', '') : color.border;

                    const categoryMeans = categories.map(category => {
                        const categoryValues = globalState.processedData[groupId]
                            .filter(row => row[paramX] === category)
                            .map(row => utils.parseNumericValue(row[paramY]))
                            .filter(val => !isNaN(val));

                        return categoryValues.length > 0 ?
                            categoryValues.reduce((sum, val) => sum + val, 0) / categoryValues.length : 0;
                    });

                    datasets.push({
                        label: group.name,
                        data: categoryMeans,
                        backgroundColor: chartType === 'bar' ? bgColor : 'transparent',
                        borderColor: borderColor,
                        borderWidth: 2,
                        fill: false
                    });
                });

                // Y-axis range
                const allYValues = datasets.flatMap(ds => ds.data);
                const yScaleType = globalState.columnTypes[paramY];
                const yRange = utils.calculateYAxisRange(allYValues, yScaleType);

                globalState.charts['custom-visualization-chart'] = new Chart(ctx, {
                    type: chartType,
                    data: {
                        labels: categories,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: paramX,
                                    color: '#e0e0e0'
                                },
                                ticks: {
                                    color: '#e0e0e0'
                                },
                                grid: {
                                    color: '#444'
                                }
                            },
                            y: {
                                min: yRange.min,
                                max: yRange.max,
                                title: {
                                    display: true,
                                    text: paramY,
                                    color: '#e0e0e0'
                                },
                                ticks: {
                                    color: '#e0e0e0'
                                },
                                grid: {
                                    color: '#444'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `${paramY} by ${paramX}`,
                                font: { size: 16 },
                                color: '#e0e0e0'
                            },
                            legend: {
                                position: 'top',
                                labels: {
                                    color: '#e0e0e0'
                                }
                            }
                        }
                    }
                });
            } else {
                utils.showError("Bar and line plots require a categorical parameter for the X-axis.");
            }
        }

        /**
         * Generate fourfold table analysis
         */
        function generateFourfoldTable() {
            const testConstellationName = document.getElementById('fourfold-constellation-1').value;
            const trueConditionConstellationName = document.getElementById('fourfold-constellation-2').value;
            const not1 = document.getElementById('fourfold-not-1').checked;
            const not2 = document.getElementById('fourfold-not-2').checked;

            if (!testConstellationName || !trueConditionConstellationName) {
                utils.showError("Please select both test and true condition constellations.");
                return;
            }

            // Find constellations by name
            const testConstellation = globalState.parameterConstellations.find(c => c.name === testConstellationName);
            const trueConditionConstellation = globalState.parameterConstellations.find(c => c.name === trueConditionConstellationName);

            if (!testConstellation || !trueConditionConstellation) {
                utils.showError("Invalid constellation selection.");
                return;
            }

            // Create 2x2 table
            const table = [[0, 0], [0, 0]];

            globalState.rawData.forEach(row => {
                let matchesTest = checkRowAgainstConditions(row, testConstellation.conditions);
                let matchesTrueCondition = checkRowAgainstConditions(row, trueConditionConstellation.conditions);

                // Apply NOT if selected
                if (not1) matchesTest = !matchesTest;
                if (not2) matchesTrueCondition = !matchesTrueCondition;

                if (matchesTest && matchesTrueCondition) {
                    table[0][0]++; // True Positive
                } else if (matchesTest && !matchesTrueCondition) {
                    table[0][1]++; // False Positive
                } else if (!matchesTest && matchesTrueCondition) {
                    table[1][0]++; // False Negative
                } else {
                    table[1][1]++; // True Negative
                }
            });

            // Calculate comprehensive statistics
            const stats = statistics.calculateFourfoldStatistics(table);
            const diagnosticMetrics = statistics.calculateDiagnosticMetrics(table);
            const validation = statistics.validateDiagnosticTestData(table);

            // Store for export
            globalState.fourfoldResults = {
                testConstellation: testConstellation.name,
                trueConditionConstellation: trueConditionConstellation.name,
                not1: not1,
                not2: not2,
                table: table,
                stats: stats,
                diagnosticMetrics: diagnosticMetrics,
                validation: validation
            };

            // Display results
            const resultsDiv = document.getElementById('fourfold-results');

            const testName = not1 ? `NOT ${testConstellation.name}` : testConstellation.name;
            const conditionName = not2 ? `NOT ${trueConditionConstellation.name}` : trueConditionConstellation.name;

            let html = `
        <h4>Diagnostic Test Analysis</h4>
        <p><strong>Test:</strong> ${testName} | <strong>True Condition:</strong> ${conditionName}</p>
    `;

            // Add validation warnings/errors if any
            if (!validation.isValid || validation.warnings.length > 0) {
                html += '<div class="validation-warnings" style="margin: 16px 0;">';
                html += '<h4>⚠️ Data Validation Issues</h4>';

                if (validation.errors.length > 0) {
                    html += '<div style="color: var(--danger-color); margin-bottom: 10px;"><strong>Errors:</strong><ul>';
                    validation.errors.forEach(error => {
                        html += `<li>${error}</li>`;
                    });
                    html += '</ul></div>';
                }

                if (validation.warnings.length > 0) {
                    html += '<div style="color: var(--warning-color);"><strong>Warnings:</strong><ul>';
                    validation.warnings.forEach(warning => {
                        html += `<li>${warning}</li>`;
                    });
                    html += '</ul></div>';
                }

                html += '</div>';
            }

            // Display the contingency table
            html += `
        <div class="fourfold-grid">
            <div class="fourfold-cell fourfold-header"></div>
            <div class="fourfold-cell fourfold-header">${conditionName} (+)</div>
            <div class="fourfold-cell fourfold-header">${conditionName} (−)</div>
            
            <div class="fourfold-cell fourfold-header">${testName} (+)</div>
            <div class="fourfold-cell">
                <span class="fourfold-value">${table[0][0]}</span>
                <div style="font-size: 0.8em; color: #888;">TP</div>
            </div>
            <div class="fourfold-cell">
                <span class="fourfold-value">${table[0][1]}</span>
                <div style="font-size: 0.8em; color: #888;">FP</div>
            </div>
            
            <div class="fourfold-cell fourfold-header">${testName} (−)</div>
            <div class="fourfold-cell">
                <span class="fourfold-value">${table[1][0]}</span>
                <div style="font-size: 0.8em; color: #888;">FN</div>
            </div>
            <div class="fourfold-cell">
                <span class="fourfold-value">${table[1][1]}</span>
                <div style="font-size: 0.8em; color: #888;">TN</div>
            </div>
        </div>
    `;

            // Only show diagnostic metrics if data is valid
            if (validation.isValid) {
                html += `
            <h5 style="margin-top: 24px;">Diagnostic Test Metrics</h5>
            <div class="fourfold-statistics">
        `;

                // Helper function to add metric cards
                const addMetricCard = (title, value, ci = null, suffix = '%', decimals = 1) => {
                    if (!isNaN(value) && isFinite(value)) {
                        let cardHtml = `
                    <div class="fourfold-stat-card">
                        <h5>${title}</h5>
                        <div class="fourfold-stat-value">${utils.formatNumber(value * (suffix === '%' ? 100 : 1), decimals)}${suffix}</div>
                `;
                        if (ci && !isNaN(ci[0]) && !isNaN(ci[1])) {
                            cardHtml += `
                        <div style="font-size: 0.9em; color: #666;">
                            95% CI: [${utils.formatNumber(ci[0] * 100, decimals)}${suffix}, ${utils.formatNumber(ci[1] * 100, decimals)}${suffix}]
                        </div>
                    `;
                        }
                        cardHtml += '</div>';
                        return cardHtml;
                    } else {
                        return `
                    <div class="fourfold-stat-card">
                        <h5>${title}</h5>
                        <div class="fourfold-stat-value" style="color: #666;">N/A</div>
                        <div style="font-size: 0.9em; color: #666;">Cannot calculate</div>
                    </div>
                `;
                    }
                };

                // Add all diagnostic metrics
                html += addMetricCard('Sensitivity', diagnosticMetrics.sensitivity, diagnosticMetrics.sensitivityCI);
                html += addMetricCard('Specificity', diagnosticMetrics.specificity, diagnosticMetrics.specificityCI);
                html += addMetricCard('PPV', diagnosticMetrics.ppv, diagnosticMetrics.ppvCI);
                html += addMetricCard('NPV', diagnosticMetrics.npv, diagnosticMetrics.npvCI);
                html += addMetricCard('Accuracy', diagnosticMetrics.accuracy);
                html += addMetricCard('Prevalence', diagnosticMetrics.prevalence);

                // Likelihood ratios (no percentage)
                if (!isNaN(diagnosticMetrics.lrPositive) && isFinite(diagnosticMetrics.lrPositive)) {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>LR+</h5>
                    <div class="fourfold-stat-value">${utils.formatNumber(diagnosticMetrics.lrPositive, 2)}</div>
                    <div style="font-size: 0.9em; color: #666;">Positive Likelihood Ratio</div>
                </div>
            `;
                } else {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>LR+</h5>
                    <div class="fourfold-stat-value" style="color: #666;">${diagnosticMetrics.lrPositive === Infinity ? '∞' : 'N/A'}</div>
                    <div style="font-size: 0.9em; color: #666;">Positive Likelihood Ratio</div>
                </div>
            `;
                }

                if (!isNaN(diagnosticMetrics.lrNegative) && isFinite(diagnosticMetrics.lrNegative)) {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>LR−</h5>
                    <div class="fourfold-stat-value">${utils.formatNumber(diagnosticMetrics.lrNegative, 2)}</div>
                    <div style="font-size: 0.9em; color: #666;">Negative Likelihood Ratio</div>
                </div>
            `;
                } else {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>LR−</h5>
                    <div class="fourfold-stat-value" style="color: #666;">${diagnosticMetrics.lrNegative === Infinity ? '∞' : 'N/A'}</div>
                    <div style="font-size: 0.9em; color: #666;">Negative Likelihood Ratio</div>
                </div>
            `;
                }

                // Additional metrics
                html += addMetricCard('Youden\'s Index', diagnosticMetrics.youdenIndex, null, '', 3);
                html += addMetricCard('F1 Score', diagnosticMetrics.f1Score, null, '', 3);

                // DOR with special handling for infinity
                if (!isNaN(diagnosticMetrics.dor) && isFinite(diagnosticMetrics.dor)) {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>DOR</h5>
                    <div class="fourfold-stat-value">${utils.formatNumber(diagnosticMetrics.dor, 2)}</div>
                    <div style="font-size: 0.9em; color: #666;">Diagnostic Odds Ratio</div>
                </div>
            `;
                } else {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>DOR</h5>
                    <div class="fourfold-stat-value" style="color: #666;">${diagnosticMetrics.dor === Infinity ? '∞' : 'N/A'}</div>
                    <div style="font-size: 0.9em; color: #666;">Diagnostic Odds Ratio</div>
                </div>
            `;
                }

                html += addMetricCard('MCC', diagnosticMetrics.mcc, null, '', 3);

                html += '</div>';
            } else {
                html += `
            <div class="error" style="margin-top: 20px;">
                <strong>Diagnostic test metrics cannot be calculated due to data issues.</strong>
                <p>Please review the validation errors above and ensure your data has cases in all necessary categories.</p>
            </div>
        `;
            }

            // Always show association measures
            html += `
        <h5 style="margin-top: 24px;">Association Measures</h5>
        <div class="fourfold-statistics">
            <div class="fourfold-stat-card">
                <h5>Sample Size</h5>
                <div class="fourfold-stat-value">${stats.n}</div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Odds Ratio</h5>
                <div class="fourfold-stat-value">${utils.formatNumber(stats.odds.oddsRatio, 3)}</div>
                <div style="font-size: 0.9em; color: #666;">
                    95% CI: [${utils.formatNumber(stats.odds.oddsRatioCI[0], 3)}, ${utils.formatNumber(stats.odds.oddsRatioCI[1], 3)}]
                </div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Risk Difference</h5>
                <div class="fourfold-stat-value">${utils.formatNumber(stats.risk.riskDifference, 3)}</div>
                <div style="font-size: 0.9em; color: #666;">
                    95% CI: [${utils.formatNumber(stats.risk.riskDifferenceCI[0], 3)}, ${utils.formatNumber(stats.risk.riskDifferenceCI[1], 3)}]
                </div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Risk Ratio</h5>
                <div class="fourfold-stat-value">${utils.formatNumber(stats.risk.riskRatio, 3)}</div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Number Needed to Treat</h5>
                <div class="fourfold-stat-value">${utils.formatNumber(stats.risk.nnt, 1)}</div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Chi-Square Test</h5>
                <div class="fourfold-stat-value">χ² = ${utils.formatNumber(stats.chiSquare.statistic, 3)}</div>
                <div style="font-size: 0.9em; color: #666;">
                    p = ${utils.formatNumber(stats.chiSquare.pValue, 4)}
                    ${stats.chiSquare.pValue < 0.05 ?
                    '<span style="color: var(--secondary-color); font-weight: bold;"> ✓ Significant</span>' :
                    '<span style="color: var(--danger-color);"> Not significant</span>'}
                </div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Fisher's Exact Test</h5>
                <div class="fourfold-stat-value">p = ${utils.formatNumber(stats.fisherExact.pValue, 4)}</div>
                <div style="font-size: 0.9em; color: #666;">
                    ${stats.fisherExact.pValue < 0.05 ?
                    '<span style="color: var(--secondary-color); font-weight: bold;"> ✓ Significant</span>' :
                    '<span style="color: var(--danger-color);"> Not significant</span>'}
                </div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Phi Coefficient</h5>
                <div class="fourfold-stat-value">${utils.formatNumber(stats.phi, 3)}</div>
                <div style="font-size: 0.9em; color: #666;">Effect size</div>
            </div>
        </div>
    `;

            resultsDiv.innerHTML = html;

            // Show export button
            document.getElementById('fourfold-export').style.display = 'block';
        }

        /**
         * Export chart as image
         */
        function exportChartAsImage(chartId) {
            const canvas = document.getElementById(chartId);
            if (!canvas) {
                utils.showError(`Chart with ID "${chartId}" not found.`);
                return;
            }

            // Create a container for the chart and metadata
            const container = document.createElement('div');
            container.style.backgroundColor = '#1a1a1a';
            container.style.padding = '20px';
            container.style.width = canvas.width + 'px';

            const title = document.createElement('h3');
            title.textContent = chartId.replace(/-/g, ' ').replace(/chart/g, 'Chart');
            title.style.textAlign = 'center';
            title.style.fontFamily = 'Arial, sans-serif';
            title.style.marginBottom = '10px';
            title.style.color = '#e0e0e0';
            container.appendChild(title);

            // Clone the canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            container.appendChild(tempCanvas);

            const dateText = document.createElement('div');
            dateText.textContent = `Generated: ${new Date().toLocaleDateString()}`;
            dateText.style.textAlign = 'right';
            dateText.style.fontFamily = 'Arial, sans-serif';
            dateText.style.fontSize = '12px';
            dateText.style.marginTop = '10px';
            dateText.style.color = '#e0e0e0';
            container.appendChild(dateText);

            // Append to document temporarily
            document.body.appendChild(container);

            // Use html2canvas to capture the container
            html2canvas(container).then(resultCanvas => {
                const image = resultCanvas.toDataURL('image/png', 1.0);

                const timestamp = utils.getTimestamp();
                const link = document.createElement('a');
                link.href = image;
                link.download = `sra-${timestamp}-${chartId.replace(/-/g, '-')}.png`;

                document.body.appendChild(link);
                link.click();

                // Clean up
                document.body.removeChild(link);
                document.body.removeChild(container);

                utils.showSuccess('Chart successfully exported!');
            });
        }

        /**
         * Export analysis results as CSV
         */
        function exportAnalysisResults() {
            const includeRawData = document.getElementById('export-raw-data').checked;
            const includeStatistics = document.getElementById('export-statistics').checked;
            const includeDefinitions = document.getElementById('export-group-definitions').checked;

            let csvContent = '\uFEFF'; // UTF-8 BOM for Excel

            // Group definitions and constellations
            if (includeDefinitions) {
                csvContent += 'PARAMETER CONSTELLATIONS\n';
                csvContent += 'Constellation Name' + globalState.csvDelimiter + 'Conditions\n';

                globalState.parameterConstellations.forEach(constellation => {
                    const conditions = constellation.conditions.map(condition => {
                        if (condition.parameter === '__all_data__') {
                            return 'All Data';
                        }
                        return `"${condition.parameter}" ${condition.operator} ${condition.value}`;
                    }).join(' AND ');

                    csvContent += constellation.name + globalState.csvDelimiter + '"' + conditions + '"\n';
                });

                csvContent += '\n';

                csvContent += 'GROUP DEFINITIONS\n';
                csvContent += 'Group' + globalState.csvDelimiter + 'Conditions' + globalState.csvDelimiter + 'Constellations' + globalState.csvDelimiter + 'Not In Previous' + globalState.csvDelimiter + 'Included\n';

                globalState.groupDefinitions.forEach(group => {
                    const conditions = group.conditions.map(condition => {
                        if (condition.parameter === '__all_data__') {
                            return 'All Data';
                        }
                        return `"${condition.parameter}" ${condition.operator} ${condition.value}`;
                    }).join(' AND ');

                    const constellations = group.constellations.map(c => c.negated ? `NOT ${c.name}` : c.name).join(', ');

                    csvContent += group.name + globalState.csvDelimiter;
                    csvContent += '"' + conditions + '"' + globalState.csvDelimiter;
                    csvContent += '"' + constellations + '"' + globalState.csvDelimiter;
                    csvContent += group.notInPrevious + globalState.csvDelimiter;
                    csvContent += group.includeInAnalysis + '\n';
                });

                csvContent += '\n';
            }

            // Statistical metrics
            if (includeStatistics) {
                csvContent += 'STATISTICAL METRICS\n';

                globalState.columnNames.forEach(paramName => {
                    const paramType = globalState.columnTypes[paramName];

                    if (scaleTypes[paramType].numeric) {
                        csvContent += `\nParameter: ${paramName} (${scaleTypes[paramType].name})\n`;

                        if (paramType === 'o') {
                            csvContent += 'Group' + globalState.csvDelimiter + 'Count' + globalState.csvDelimiter + 'Median' + globalState.csvDelimiter + 'Q1' + globalState.csvDelimiter + 'Q3' + globalState.csvDelimiter + 'IQR' + globalState.csvDelimiter + 'Min' + globalState.csvDelimiter + 'Max' + globalState.csvDelimiter + 'Range\n';
                        } else {
                            csvContent += 'Group' + globalState.csvDelimiter + 'Count' + globalState.csvDelimiter + 'Mean' + globalState.csvDelimiter + 'Median' + globalState.csvDelimiter + 'Std Dev' + globalState.csvDelimiter + 'Min' + globalState.csvDelimiter + 'Max' + globalState.csvDelimiter + 'Q1' + globalState.csvDelimiter + 'Q3' + globalState.csvDelimiter + 'IQR';
                            if (paramType === 'r') {
                                csvContent += globalState.csvDelimiter + 'CV (%)';
                            }
                            csvContent += '\n';
                        }

                        Object.entries(globalState.currentGroups).forEach(([groupId, group]) => {
                            const groupData = globalState.processedData[groupId]
                                .map(row => utils.parseNumericValue(row[paramName]))
                                .filter(val => !isNaN(val));

                            const stats = statistics.calculate(groupData);

                            csvContent += group.name + globalState.csvDelimiter + stats.count + globalState.csvDelimiter;

                            if (paramType === 'o') {
                                csvContent += utils.formatNumberForCSV(stats.median) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.q1) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.q3) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.iqr) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.min) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.max) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.range) + '\n';
                            } else {
                                csvContent += utils.formatNumberForCSV(stats.mean) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.median) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.stdDev) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.min) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.max) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.q1) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.q3) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.iqr);
                                if (paramType === 'r' && stats.cv !== null) {
                                    csvContent += globalState.csvDelimiter + utils.formatNumberForCSV(stats.cv);
                                }
                                csvContent += '\n';
                            }
                        });
                    }
                });

                csvContent += '\n';
            }

            // Raw data with grouping
            if (includeRawData) {
                csvContent += 'RAW DATA WITH GROUPING\n';
                csvContent += 'Groups' + globalState.csvDelimiter + globalState.columnNames.join(globalState.csvDelimiter) + '\n';

                globalState.rawData.forEach((row, rowIndex) => {
                    // Get all groups this row belongs to
                    const rowGroups = [];
                    if (globalState.recordAssignments && globalState.recordAssignments[rowIndex]) {
                        globalState.recordAssignments[rowIndex].forEach(groupId => {
                            rowGroups.push(globalState.currentGroups[groupId].name);
                        });
                    }

                    const groupsText = rowGroups.length > 0 ? rowGroups.join('; ') : 'None';

                    let rowData = '"' + groupsText + '"' + globalState.csvDelimiter;

                    globalState.columnNames.forEach(columnName => {
                        let cellValue = '';
                        const value = row[columnName];
                        const columnType = globalState.columnTypes[columnName];

                        if (value !== undefined && value !== null) {
                            if (scaleTypes[columnType].numeric && !isNaN(value)) {
                                cellValue = utils.formatNumberForCSV(value);
                            } else {
                                cellValue = String(value);
                            }

                            // Escape delimiter in data
                            if (cellValue.includes(globalState.csvDelimiter) || cellValue.includes('"')) {
                                cellValue = '"' + cellValue.replace(/"/g, '""') + '"';
                            }
                        }

                        rowData += cellValue + globalState.csvDelimiter;
                    });

                    csvContent += rowData.slice(0, -1) + '\n';
                });
            }

            // Create download with timestamp
            const timestamp = utils.getTimestamp();
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `sra-${timestamp}-analysis-results.csv`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            URL.revokeObjectURL(url);
            utils.showSuccess('Analysis results successfully exported!');
        }

        /**
         * Export table as CSV
         */
        function exportTableAsCSV(tableId, filename) {
            utils.exportTableToCSV(tableId, filename);
        }

        /**
         * Export group definitions
         */
        function exportGroupDefinitions() {
            collectGroupDefinitions();

            if (globalState.groupDefinitions.length === 0 && globalState.parameterConstellations.length === 0) {
                utils.showError("No group definitions or constellations to export.");
                return;
            }

            // Create text representation
            let textContent = "# Statistical Research Analyzer - Group Definitions\n";
            textContent += `# Created: ${new Date().toISOString()}\n`;
            textContent += `# Format Version: 1.0\n\n`;

            // Export constellations first
            if (globalState.parameterConstellations.length > 0) {
                textContent += "# PARAMETER CONSTELLATIONS\n\n";
                globalState.parameterConstellations.forEach(constellation => {
                    textContent += utils.constellationToText(constellation);
                });
            }

            // Export group definitions
            if (globalState.groupDefinitions.length > 0) {
                textContent += "# GROUP DEFINITIONS\n\n";
                globalState.groupDefinitions.forEach(group => {
                    textContent += utils.groupDefinitionToText(group);
                });
            }

            textContent += "[SETTINGS]\n";
            textContent += `ExportDate: ${new Date().toISOString()}\n`;
            textContent += `TotalRecords: ${globalState.rawData.length}\n`;
            textContent += `Parameters: ${globalState.columnNames.length}\n`;
            textContent += `Constellations: ${globalState.parameterConstellations.length}\n`;
            textContent += `Groups: ${globalState.groupDefinitions.length}\n\n`;

            // Create download with timestamp
            const timestamp = utils.getTimestamp();
            const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `sra-${timestamp}-group-definitions.txt`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            URL.revokeObjectURL(url);
            utils.showSuccess('Group definitions successfully exported!');
        }

        /**
         * Import group definitions
         */
        function importGroupDefinitions() {
            // Create file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';

            input.addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        parseGroupDefinitionFile(e.target.result);
                    } catch (error) {
                        utils.showError("Error parsing group definition file: " + error.message);
                    }
                };

                reader.readAsText(file);
            });

            input.click();
        }

        /**
         * Parse group definition file
         */
        function parseGroupDefinitionFile(content) {
            const lines = content.split('\n');
            let currentSection = null;
            let currentItem = null;
            const importedGroups = [];
            const importedConstellations = [];

            lines.forEach(line => {
                line = line.trim();

                // Skip comments and empty lines
                if (line.startsWith('#') || line === '') return;

                // Check for section headers
                if (line === '# PARAMETER CONSTELLATIONS') {
                    currentSection = 'constellations';
                    return;
                } else if (line === '# GROUP DEFINITIONS') {
                    currentSection = 'groups';
                    return;
                }

                // New item
                if (line.startsWith('[') && line.endsWith(']')) {
                    // Save previous item if exists
                    if (currentItem) {
                        if (currentSection === 'constellations' && currentItem.conditions.length > 0) {
                            importedConstellations.push(currentItem);
                        } else if (currentSection === 'groups' && (currentItem.conditions.length > 0 || currentItem.constellations.length > 0)) {
                            importedGroups.push(currentItem);
                        }
                    }

                    const itemName = line.substring(1, line.length - 1);

                    if (itemName.startsWith('CONSTELLATION:')) {
                        currentSection = 'constellations';
                        currentItem = {
                            name: itemName.substring('CONSTELLATION:'.length),
                            conditions: []
                        };
                    } else if (itemName !== 'SETTINGS') {
                        currentSection = 'groups';
                        currentItem = {
                            name: itemName,
                            conditions: [],
                            constellations: [],
                            notInPrevious: false,
                            includeInAnalysis: true,
                            customColor: null
                        };
                    } else {
                        currentItem = null;
                    }
                    return;
                }

                // Parse attributes
                if (currentItem && line.includes(':')) {
                    const colonIndex = line.indexOf(':');
                    const key = line.substring(0, colonIndex).trim();
                    const value = line.substring(colonIndex + 1).trim();

                    if (key.startsWith('Condition_')) {
                        // Parsing for conditions
                        let match;
                        let parameter, operator, conditionValue;

                        // Check for "All Data" condition
                        if (value === '"__all_data__" = true' || value === 'All Data') {
                            currentItem.conditions.push({
                                parameter: '__all_data__',
                                operator: '=',
                                value: true,
                                type: 'special'
                            });
                            return;
                        }

                        // Try quoted parameter first
                        match = value.match(/^"([^"]+)"\s*([<>=!]+)\s*(.+)$/);
                        if (match) {
                            parameter = match[1];
                            operator = match[2];
                            conditionValue = match[3];
                        } else {
                            // Try unquoted parameter
                            match = value.match(/^(\S+)\s*([<>=!]+)\s*(.+)$/);
                            if (match) {
                                parameter = match[1];
                                operator = match[2];
                                conditionValue = match[3];
                            } else {
                                console.warn(`Could not parse condition: ${value}`);
                                return;
                            }
                        }

                        // Remove quotes from value if present
                        if (conditionValue.startsWith('"') && conditionValue.endsWith('"')) {
                            conditionValue = conditionValue.slice(1, -1);
                        }

                        // Skip if parameter doesn't exist
                        if (!globalState.columnNames.includes(parameter)) {
                            utils.showError(`Parameter '${parameter}' not found in current data.`);
                            return;
                        }

                        const paramType = globalState.columnTypes[parameter];
                        let parsedValue;

                        if (scaleTypes[paramType].numeric) {
                            parsedValue = utils.parseNumericValue(conditionValue);
                            if (isNaN(parsedValue)) {
                                console.warn(`Invalid numeric value for parameter '${parameter}': ${conditionValue}`);
                                return;
                            }
                        } else {
                            parsedValue = conditionValue;
                        }

                        currentItem.conditions.push({
                            parameter: parameter,
                            operator: operator,
                            value: parsedValue,
                            type: paramType
                        });
                    } else if (key.startsWith('Constellation_')) {
                        // Parse constellation reference
                        const negated = value.includes('[NOT]');
                        const constellationName = value.replace(' [NOT]', '');
                        currentItem.constellations.push({
                            name: constellationName,
                            negated: negated
                        });
                    } else if (key === 'NotInPrevious') {
                        currentItem.notInPrevious = value.toLowerCase() === 'true';
                    } else if (key === 'IncludeInAnalysis') {
                        currentItem.includeInAnalysis = value.toLowerCase() === 'true';
                    } else if (key === 'Color') {
                        currentItem.customColor = value;
                    } else if (key === 'ColorIndex') {
                        currentItem.colorIndex = parseInt(value);
                    }
                }
            });

            // Add the last item if any
            if (currentItem) {
                if (currentSection === 'constellations' && currentItem.conditions.length > 0) {
                    importedConstellations.push(currentItem);
                } else if (currentSection === 'groups' && (currentItem.conditions.length > 0 || currentItem.constellations.length > 0)) {
                    importedGroups.push(currentItem);
                }
            }

            if (importedGroups.length === 0 && importedConstellations.length === 0) {
                utils.showError("No valid definitions found in the file.");
                return;
            }

            // Apply imported definitions to the UI
            applyImportedDefinitions(importedGroups, importedConstellations);
            utils.showSuccess(`Successfully imported ${importedConstellations.length} constellation(s) and ${importedGroups.length} group definition(s).`);
        }

        /**
         * Apply imported definitions to the UI
         */
        function applyImportedDefinitions(importedGroups, importedConstellations) {
            // Reset current definitions without confirmation
            utils.destroyAllCharts();
            initializeGroupDefinition();
            document.getElementById('analysis-results').style.display = 'none';

            // First, create constellations
            const constellationList = document.getElementById('constellation-list');
            constellationList.innerHTML = '';

            importedConstellations.forEach((constellation, index) => {
                const constellationDiv = document.createElement('div');
                constellationDiv.className = 'constellation-item';
                constellationDiv.dataset.constellationIndex = index;

                // Constellation header
                const header = document.createElement('div');
                header.className = 'constellation-header';

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'constellation-name';
                nameInput.value = constellation.name;
                nameInput.placeholder = 'Enter constellation name';

                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn btn-danger btn-small';
                removeBtn.textContent = 'Remove';
                removeBtn.addEventListener('click', () => {
                    constellationList.removeChild(constellationDiv);
                    updateConstellationIndices();
                });

                header.appendChild(nameInput);
                header.appendChild(removeBtn);
                constellationDiv.appendChild(header);

                // Parameter container
                const paramContainer = document.createElement('div');
                paramContainer.className = 'parameter-controls';
                constellationDiv.appendChild(paramContainer);

                // Add conditions
                constellation.conditions.forEach(condition => {
                    addParameterControlWithValues(paramContainer, condition);
                });

                // Add parameter button
                const addParamBtn = document.createElement('button');
                addParamBtn.className = 'btn btn-accent btn-small';
                addParamBtn.textContent = 'Add Parameter';
                addParamBtn.addEventListener('click', () => {
                    addConstellationParameterControl(paramContainer, false);
                });
                constellationDiv.appendChild(addParamBtn);

                constellationList.appendChild(constellationDiv);
            });

            // Update constellation state
            updateConstellationState();

            // Then create groups
            const container = document.getElementById('parameter-groups');
            container.innerHTML = '';

            importedGroups.forEach((group, index) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'parameter-group';
                groupDiv.dataset.groupIndex = index;

                if (!group.includeInAnalysis) {
                    groupDiv.classList.add('excluded');
                }

                // Group header
                const header = document.createElement('div');
                header.className = 'parameter-group-title';

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'group-name-input';
                nameInput.value = group.name;
                nameInput.placeholder = 'Enter group name';

                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn btn-danger btn-small';
                removeBtn.textContent = 'Remove';
                removeBtn.addEventListener('click', () => {
                    if (container.children.length > 1) {
                        container.removeChild(groupDiv);
                        updateGroupNumbers();
                    } else {
                        utils.showError("At least one subgroup must be defined.");
                    }
                });

                header.appendChild(nameInput);
                header.appendChild(removeBtn);
                groupDiv.appendChild(header);

                // Group controls (color and inclusion)
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'group-controls';

                // Color control
                const colorControl = document.createElement('div');
                colorControl.className = 'group-color-control';

                const colorLabel = document.createElement('label');
                colorLabel.textContent = 'Color:';
                colorControl.appendChild(colorLabel);

                const colorSelect = document.createElement('select');
                colorSelect.className = 'color-preset-selector';

                // Add preset colors
                groupColors.forEach((color, idx) => {
                    const option = document.createElement('option');
                    option.value = idx;
                    option.textContent = color.name;
                    colorSelect.appendChild(option);
                });

                // Add custom option
                const customOption = document.createElement('option');
                customOption.value = 'custom';
                customOption.textContent = 'Custom';
                colorSelect.appendChild(customOption);

                colorControl.appendChild(colorSelect);

                // Color preview
                const colorPreview = document.createElement('div');
                colorPreview.className = 'color-preview';
                colorControl.appendChild(colorPreview);

                // Custom color input
                const customColorInput = document.createElement('input');
                customColorInput.type = 'text';
                customColorInput.className = 'custom-color-input';
                customColorInput.placeholder = '#RRGGBB';
                customColorInput.style.display = 'none';
                colorControl.appendChild(customColorInput);

                // Set color based on imported data (AFTER creating all elements)
                if (group.customColor) {
                    colorSelect.value = 'custom';
                    customColorInput.value = group.customColor.replace('B3', '');
                    customColorInput.style.display = 'block';
                    colorPreview.style.backgroundColor = group.customColor;
                } else if (group.colorIndex !== undefined && group.colorIndex < groupColors.length) {
                    colorSelect.value = group.colorIndex;
                    colorPreview.style.backgroundColor = groupColors[group.colorIndex].bg;
                } else {
                    colorSelect.value = index % groupColors.length;
                    colorPreview.style.backgroundColor = groupColors[index % groupColors.length].bg;
                }

                // Color change handler
                colorSelect.addEventListener('change', () => {
                    if (colorSelect.value === 'custom') {
                        customColorInput.style.display = 'block';
                        customColorInput.focus();
                    } else {
                        customColorInput.style.display = 'none';
                        const colorIndex = parseInt(colorSelect.value);
                        colorPreview.style.backgroundColor = groupColors[colorIndex].bg;
                    }
                });

                customColorInput.addEventListener('input', () => {
                    const hexRegex = /^#[0-9A-F]{6}$/i;
                    if (hexRegex.test(customColorInput.value)) {
                        colorPreview.style.backgroundColor = customColorInput.value + 'B3';
                    }
                });

                controlsDiv.appendChild(colorControl);

                // Include in analysis checkbox
                const includeCheckbox = document.createElement('input');
                includeCheckbox.type = 'checkbox';
                includeCheckbox.id = `include-group-${index}`;
                includeCheckbox.checked = group.includeInAnalysis;
                includeCheckbox.addEventListener('change', () => {
                    groupDiv.classList.toggle('excluded', !includeCheckbox.checked);
                });

                const includeLabel = document.createElement('label');
                includeLabel.htmlFor = `include-group-${index}`;
                includeLabel.textContent = 'Include in analysis';

                const includeContainer = document.createElement('div');
                includeContainer.className = 'checkbox-container';
                includeContainer.appendChild(includeCheckbox);
                includeContainer.appendChild(includeLabel);

                controlsDiv.appendChild(includeContainer);

                groupDiv.appendChild(controlsDiv);

                // Not in previous groups checkbox
                const notInPreviousDiv = document.createElement('div');
                notInPreviousDiv.className = 'not-in-previous-checkbox';

                const notInPreviousCheckbox = document.createElement('input');
                notInPreviousCheckbox.type = 'checkbox';
                notInPreviousCheckbox.id = `not-in-previous-${index}`;
                notInPreviousCheckbox.checked = group.notInPrevious;

                const notInPreviousLabel = document.createElement('label');
                notInPreviousLabel.htmlFor = `not-in-previous-${index}`;
                notInPreviousLabel.textContent = 'Exclude records that are in previous groups';

                notInPreviousDiv.appendChild(notInPreviousCheckbox);
                notInPreviousDiv.appendChild(notInPreviousLabel);

                if (index === 0) {
                    notInPreviousDiv.style.display = 'none';
                }

                groupDiv.appendChild(notInPreviousDiv);

                // Condition type selector
                const conditionTypeDiv = document.createElement('div');
                conditionTypeDiv.className = 'condition-type-selector';

                const individualBtn = document.createElement('button');
                individualBtn.textContent = 'Add Individual Condition';
                individualBtn.className = 'active';
                individualBtn.addEventListener('click', () => {
                    addParameterControl(paramContainer);
                });

                const constellationBtn = document.createElement('button');
                constellationBtn.textContent = 'Add Constellation';
                constellationBtn.addEventListener('click', () => {
                    addConstellationToGroup(paramContainer);
                });

                conditionTypeDiv.appendChild(individualBtn);
                conditionTypeDiv.appendChild(constellationBtn);
                groupDiv.appendChild(conditionTypeDiv);

                // Parameter container
                const paramContainer = document.createElement('div');
                paramContainer.className = 'parameter-controls';
                groupDiv.appendChild(paramContainer);

                // Add individual conditions
                group.conditions.forEach(condition => {
                    addParameterControlWithValues(paramContainer, condition);
                });

                // Add constellations
                group.constellations.forEach(constellationRef => {
                    addConstellationToGroupWithValue(paramContainer, constellationRef);
                });

                container.appendChild(groupDiv);
            });

            // Add button for new group if none exists
            if (importedGroups.length === 0) {
                addNewGroup();
            }
        }

        /**
         * Add parameter control with pre-defined values
         */
        function addParameterControlWithValues(container, condition) {
            const controlDiv = document.createElement('div');
            controlDiv.className = 'parameter-control';

            // Parameter select
            const paramLabel = document.createElement('label');
            paramLabel.textContent = 'Parameter:';
            controlDiv.appendChild(paramLabel);

            const paramSelect = document.createElement('select');
            paramSelect.className = 'param-select';

            // Handle "All Data" condition
            if (condition.parameter === '__all_data__') {
                const allDataOption = document.createElement('option');
                allDataOption.value = '__all_data__';
                allDataOption.textContent = 'All Data';
                allDataOption.selected = true;
                paramSelect.appendChild(allDataOption);
            }

            // Default "no parameter" option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select parameter...';
            paramSelect.appendChild(defaultOption);

            // Add available parameters
            globalState.columnNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                const scaleInfo = utils.getScaleInfo(globalState.columnTypes[name]);
                option.textContent = `${name} (${scaleInfo.name})`;
                if (name === condition.parameter) {
                    option.selected = true;
                }
                paramSelect.appendChild(option);
            });

            controlDiv.appendChild(paramSelect);

            // Condition container
            const conditionContainer = document.createElement('div');
            conditionContainer.className = 'condition-controls';
            controlDiv.appendChild(conditionContainer);

            // Distribution info container
            const groupDistribution = document.createElement('div');
            groupDistribution.className = 'group-distribution';
            groupDistribution.style.display = 'none';
            controlDiv.appendChild(groupDistribution);

            // Info container
            const infoDiv = document.createElement('div');
            infoDiv.className = 'parameter-info';
            controlDiv.appendChild(infoDiv);

            // Set up condition controls
            updateConditionControls(conditionContainer, infoDiv, groupDistribution, condition.parameter);

            // Set operator and value after controls are created
            requestAnimationFrame(() => {
                const operatorSelect = conditionContainer.querySelector('.condition-operator');
                if (operatorSelect && condition.parameter !== '__all_data__') {
                    operatorSelect.value = condition.operator;

                    const valueInput = conditionContainer.querySelector('.condition-value');
                    if (valueInput) {
                        valueInput.value = condition.value;

                        // Trigger distribution update
                        if (scaleTypes[condition.type].numeric) {
                            updateNumericDistribution(condition.parameter, condition.operator, condition.value, groupDistribution);
                        } else {
                            updateCategoryDistribution(condition.parameter, condition.operator, condition.value, groupDistribution);
                        }
                    }
                }
            });

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove Parameter';
            removeBtn.style.marginTop = '10px';
            removeBtn.addEventListener('click', () => {
                container.removeChild(controlDiv);
            });
            controlDiv.appendChild(removeBtn);

            container.appendChild(controlDiv);
        }

        /**
         * Add constellation to group with pre-selected value
         */
        function addConstellationToGroupWithValue(container, constellationRef) {
            const controlDiv = document.createElement('div');
            controlDiv.className = 'parameter-control constellation-reference';
            if (constellationRef.negated) {
                controlDiv.classList.add('negated');
            }

            const label = document.createElement('label');
            label.textContent = 'Constellation:';
            controlDiv.appendChild(label);

            // Negation checkbox
            const negationCheckbox = document.createElement('input');
            negationCheckbox.type = 'checkbox';
            negationCheckbox.className = 'negation-checkbox';
            negationCheckbox.checked = constellationRef.negated;
            negationCheckbox.addEventListener('change', () => {
                controlDiv.classList.toggle('negated', negationCheckbox.checked);
                updateConstellationDisplay();
            });

            const negationLabel = document.createElement('label');
            negationLabel.textContent = 'NOT';
            negationLabel.style.marginRight = '10px';

            const negationContainer = document.createElement('span');
            negationContainer.appendChild(negationCheckbox);
            negationContainer.appendChild(negationLabel);
            controlDiv.appendChild(negationContainer);

            const constellationSelect = document.createElement('select');
            constellationSelect.className = 'constellation-select';

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select constellation...';
            constellationSelect.appendChild(defaultOption);

            globalState.parameterConstellations.forEach((constellation, index) => {
                const option = document.createElement('option');
                option.value = constellation.name;
                option.textContent = constellation.name;
                if (constellation.name === constellationRef.name) {
                    option.selected = true;
                }
                constellationSelect.appendChild(option);
            });

            controlDiv.appendChild(constellationSelect);

            // Display constellation conditions
            const conditionsDisplay = document.createElement('div');
            conditionsDisplay.className = 'constellation-conditions';
            conditionsDisplay.style.marginTop = '10px';
            conditionsDisplay.style.fontSize = '0.9em';
            conditionsDisplay.style.color = '#666';
            controlDiv.appendChild(conditionsDisplay);

            const updateConstellationDisplay = () => {
                const selectedConstellation = globalState.parameterConstellations.find(
                    c => c.name === constellationSelect.value
                );

                if (selectedConstellation) {
                    const conditionsText = selectedConstellation.conditions.map(c => {
                        if (c.parameter === '__all_data__') {
                            return 'All Data';
                        }
                        return `${c.parameter} ${c.operator} ${c.value}`;
                    }).join(' AND ');

                    const prefix = negationCheckbox.checked ? '<strong>NOT</strong> (' : '';
                    const suffix = negationCheckbox.checked ? ')' : '';
                    conditionsDisplay.innerHTML = `<strong>Conditions:</strong> ${prefix}${conditionsText}${suffix}`;
                } else {
                    conditionsDisplay.innerHTML = '';
                }
            };

            // Initial display update
            updateConstellationDisplay();

            constellationSelect.addEventListener('change', updateConstellationDisplay);

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove Constellation';
            removeBtn.style.marginTop = '10px';
            removeBtn.addEventListener('click', () => {
                container.removeChild(controlDiv);
            });
            controlDiv.appendChild(removeBtn);

            container.appendChild(controlDiv);
        }

        /**
         * Reset groups
         */
        function resetGroups() {
            if (confirm('Are you sure you want to reset all groups and constellations?')) {
                utils.destroyAllCharts();
                initializeGroupDefinition();
                document.getElementById('analysis-results').style.display = 'none';
                utils.showSuccess('Groups and constellations have been reset.');
            }
        }

        /**
         * Export group overview
         */
        function exportGroupOverview() {
            let content = 'GROUP OVERVIEW REPORT\n';
            content += `Generated: ${new Date().toLocaleDateString()}\n\n`;

            content += 'GROUP SUMMARY\n';
            content += 'Group' + globalState.csvDelimiter + 'Count' + globalState.csvDelimiter + 'Percentage\n';

            const totalRecords = globalState.rawData.length;
            Object.entries(globalState.currentGroups).forEach(([groupId, group]) => {
                const percentage = ((group.count / totalRecords) * 100).toFixed(1);
                content += group.name + globalState.csvDelimiter + group.count + globalState.csvDelimiter + percentage + '%\n';
            });

            content += 'Total' + globalState.csvDelimiter + totalRecords + globalState.csvDelimiter + '100%\n\n';

            // Create download
            const timestamp = utils.getTimestamp();
            const blob = new Blob(['\uFEFF' + content], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `sra-${timestamp}-group-overview.csv`);
            link.click();

            URL.revokeObjectURL(url);
            utils.showSuccess('Group overview exported successfully!');
        }

        /**
         * Export significance test results
         */
        function exportSignificanceTests() {
            if (globalState.significanceResults.length === 0) {
                utils.showError("No significance test results to export.");
                return;
            }

            // Build content efficiently
            const lines = ['SIGNIFICANCE TEST RESULTS'];
            lines.push(`Generated: ${new Date().toLocaleDateString()}`);
            lines.push('');

            globalState.significanceResults.forEach((testResult, index) => {
                lines.push(`TEST ${index + 1}`);
                lines.push(`Parameter: ${testResult.paramName}`);
                lines.push(`Groups: ${testResult.groupNames.join(', ')}`);
                lines.push(`Test: ${testResult.result.test}`);
                lines.push(`p-value: ${testResult.result.pValue?.toFixed(6) || 'N/A'}`);
                lines.push(`Significant: ${testResult.result.significant ? 'Yes' : 'No'}`);
                lines.push(`Alpha: ${testResult.result.alpha}`);

                if (testResult.result.statistic !== undefined) {
                    lines.push(`Test Statistic: ${testResult.result.statistic.toFixed(4)}`);
                }

                if (testResult.result.effectSize !== undefined) {
                    lines.push(`Effect Size: ${testResult.result.effectSize.toFixed(3)}`);
                }

                if (testResult.result.power !== undefined) {
                    lines.push(`Power: ${testResult.result.power.toFixed(3)}`);
                }

                lines.push('');
            });

            // Create and trigger download immediately
            const content = lines.join('\n');
            const timestamp = utils.getTimestamp();

            // Use a data URL for small files (more efficient)
            const dataUrl = 'data:text/plain;charset=utf-8,' + encodeURIComponent(content);

            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = `sra-${timestamp}-significance-tests.txt`;
            link.click();

            utils.showSuccess('Significance test results exported successfully!');
        }

        /**
         * Export fourfold table results
         */
        function exportFourfoldTable() {
            if (!globalState.fourfoldResults) {
                utils.showError("No fourfold table results to export.");
                return;
            }

            const results = globalState.fourfoldResults;
            const lines = [];

            lines.push('DIAGNOSTIC TEST ANALYSIS');
            lines.push(`Generated: ${new Date().toLocaleDateString()}`);
            lines.push('');

            const testName = results.not1 ? `NOT ${results.testConstellation}` : results.testConstellation;
            const conditionName = results.not2 ? `NOT ${results.trueConditionConstellation}` : results.trueConditionConstellation;

            lines.push(`Test: ${testName}`);
            lines.push(`True Condition (Gold Standard): ${conditionName}`);
            lines.push('');

            // Add validation information if present
            if (results.validation && (!results.validation.isValid || results.validation.warnings.length > 0)) {
                lines.push('DATA VALIDATION ISSUES');
                lines.push('-'.repeat(40));

                if (results.validation.errors.length > 0) {
                    lines.push('Errors:');
                    results.validation.errors.forEach(error => {
                        lines.push(`  - ${error}`);
                    });
                    lines.push('');
                }

                if (results.validation.warnings.length > 0) {
                    lines.push('Warnings:');
                    results.validation.warnings.forEach(warning => {
                        lines.push(`  - ${warning}`);
                    });
                    lines.push('');
                }
            }

            lines.push('CONTINGENCY TABLE');
            lines.push(`\t${conditionName} (+)\t${conditionName} (−)`);
            lines.push(`${testName} (+)\t${results.table[0][0]} (TP)\t${results.table[0][1]} (FP)`);
            lines.push(`${testName} (−)\t${results.table[1][0]} (FN)\t${results.table[1][1]} (TN)`);
            lines.push('');

            // Only export diagnostic metrics if validation passed
            if (results.validation.isValid) {
                lines.push('DIAGNOSTIC TEST METRICS');
                const dm = results.diagnosticMetrics;

                // Helper function to format metric with CI
                const formatMetric = (name, value, ci = null, isPercentage = true) => {
                    if (!isNaN(value) && isFinite(value)) {
                        let line = `${name}: `;
                        if (isPercentage) {
                            line += `${(value * 100).toFixed(1)}%`;
                            if (ci && !isNaN(ci[0]) && !isNaN(ci[1])) {
                                line += ` [95% CI: ${(ci[0] * 100).toFixed(1)}%-${(ci[1] * 100).toFixed(1)}%]`;
                            }
                        } else {
                            line += value.toFixed(3);
                        }
                        return line;
                    } else if (value === Infinity) {
                        return `${name}: ∞ (Infinity)`;
                    } else {
                        return `${name}: Cannot be calculated`;
                    }
                };

                lines.push(formatMetric('Sensitivity', dm.sensitivity, dm.sensitivityCI));
                lines.push(formatMetric('Specificity', dm.specificity, dm.specificityCI));
                lines.push(formatMetric('Positive Predictive Value (PPV)', dm.ppv, dm.ppvCI));
                lines.push(formatMetric('Negative Predictive Value (NPV)', dm.npv, dm.npvCI));
                lines.push(formatMetric('Accuracy', dm.accuracy));
                lines.push(formatMetric('Prevalence', dm.prevalence));
                lines.push('');

                lines.push('LIKELIHOOD RATIOS');
                if (!isNaN(dm.lrPositive) && isFinite(dm.lrPositive)) {
                    lines.push(`Positive Likelihood Ratio (LR+): ${dm.lrPositive.toFixed(2)}`);
                } else if (dm.lrPositive === Infinity) {
                    lines.push('Positive Likelihood Ratio (LR+): ∞ (Perfect specificity)');
                } else {
                    lines.push('Positive Likelihood Ratio (LR+): Cannot be calculated');
                }

                if (!isNaN(dm.lrNegative) && isFinite(dm.lrNegative)) {
                    lines.push(`Negative Likelihood Ratio (LR−): ${dm.lrNegative.toFixed(2)}`);
                } else if (dm.lrNegative === Infinity) {
                    lines.push('Negative Likelihood Ratio (LR−): ∞');
                } else {
                    lines.push('Negative Likelihood Ratio (LR−): Cannot be calculated');
                }

                if (!isNaN(dm.dor) && isFinite(dm.dor)) {
                    lines.push(`Diagnostic Odds Ratio (DOR): ${dm.dor.toFixed(2)}`);
                } else if (dm.dor === Infinity) {
                    lines.push('Diagnostic Odds Ratio (DOR): ∞ (Perfect test)');
                } else {
                    lines.push('Diagnostic Odds Ratio (DOR): Cannot be calculated');
                }
                lines.push('');

                lines.push('ADDITIONAL METRICS');
                lines.push(formatMetric("Youden's Index", dm.youdenIndex, null, false));
                lines.push(formatMetric('Matthews Correlation Coefficient', dm.mcc, null, false));
                lines.push(formatMetric('F1 Score', dm.f1Score, null, false));
                lines.push('');
            } else {
                lines.push('DIAGNOSTIC TEST METRICS');
                lines.push('Cannot be calculated due to validation errors.');
                lines.push('Please see validation issues above.');
                lines.push('');
            }

            lines.push('ASSOCIATION MEASURES');
            lines.push(`Sample Size: ${results.stats.n}`);

            if (results.stats.odds.oddsRatio !== undefined && !isNaN(results.stats.odds.oddsRatio)) {
                lines.push(`Odds Ratio: ${results.stats.odds.oddsRatio.toFixed(3)}`);
                lines.push(`Odds Ratio 95% CI: [${results.stats.odds.oddsRatioCI[0].toFixed(3)}, ${results.stats.odds.oddsRatioCI[1].toFixed(3)}]`);
            }

            if (results.stats.risk.riskDifference !== undefined && !isNaN(results.stats.risk.riskDifference)) {
                lines.push(`Risk Difference: ${results.stats.risk.riskDifference.toFixed(3)}`);
                lines.push(`Risk Difference 95% CI: [${results.stats.risk.riskDifferenceCI[0].toFixed(3)}, ${results.stats.risk.riskDifferenceCI[1].toFixed(3)}]`);
            }

            if (results.stats.risk.riskRatio !== undefined && !isNaN(results.stats.risk.riskRatio)) {
                lines.push(`Risk Ratio: ${results.stats.risk.riskRatio.toFixed(3)}`);
            }

            if (results.stats.risk.nnt !== undefined && !isNaN(results.stats.risk.nnt)) {
                lines.push(`Number Needed to Treat: ${results.stats.risk.nnt.toFixed(1)}`);
            }

            if (results.stats.chiSquare.statistic !== undefined) {
                lines.push(`Chi-Square: ${results.stats.chiSquare.statistic.toFixed(3)}`);
                lines.push(`Chi-Square p-value: ${results.stats.chiSquare.pValue.toFixed(4)}`);
                lines.push(`Chi-Square with Yates correction: ${results.stats.chiSquare.statisticYates.toFixed(3)}`);
                lines.push(`Chi-Square with Yates p-value: ${results.stats.chiSquare.pValueYates.toFixed(4)}`);
            }

            if (results.stats.fisherExact.pValue !== undefined) {
                lines.push(`Fisher's Exact p-value: ${results.stats.fisherExact.pValue.toFixed(4)}`);
            }

            if (results.stats.phi !== undefined) {
                lines.push(`Phi Coefficient: ${results.stats.phi.toFixed(3)}`);
            }

            const content = lines.join('\n');
            const timestamp = utils.getTimestamp();

            // Use data URL
            const dataUrl = 'data:text/plain;charset=utf-8,' + encodeURIComponent(content);

            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = `sra-${timestamp}-diagnostic-test-analysis.txt`;
            link.click();

            utils.showSuccess('Diagnostic test analysis exported successfully!');
        }


        /**
         * Export comprehensive report
         */
        function exportComprehensiveReport() {
            const includeOverview = document.getElementById('export-report-overview').checked;
            const includeStatistics = document.getElementById('export-report-statistics').checked;
            const includeTests = document.getElementById('export-report-tests').checked;
            const includeFourfold = document.getElementById('export-report-fourfold').checked;

            const lines = [];

            lines.push('STATISTICAL RESEARCH ANALYZER - COMPREHENSIVE REPORT');
            lines.push('='.repeat(60));
            lines.push(`Generated: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`);
            lines.push(`Total Records: ${globalState.rawData.length}`);
            lines.push(`Parameters: ${globalState.columnNames.length}`);
            lines.push(`Groups: ${Object.keys(globalState.currentGroups).length}`);
            lines.push('');

            if (includeOverview) {
                lines.push('GROUP OVERVIEW');
                lines.push('-'.repeat(40));
                const totalRecords = globalState.rawData.length;
                Object.entries(globalState.currentGroups).forEach(([groupId, group]) => {
                    const percentage = ((group.count / totalRecords) * 100).toFixed(1);
                    lines.push(`${group.name}: ${group.count} records (${percentage}%)`);
                });
                lines.push('');
            }

            if (includeStatistics) {
                lines.push('DETAILED STATISTICS');
                lines.push('-'.repeat(40));

                const numericParams = globalState.columnNames.filter(name =>
                    scaleTypes[globalState.columnTypes[name]].numeric
                );

                numericParams.forEach(paramName => {
                    const paramType = globalState.columnTypes[paramName];
                    lines.push('');
                    lines.push(`Parameter: ${paramName} (${scaleTypes[paramType].name})`);

                    Object.entries(globalState.currentGroups).forEach(([groupId, group]) => {
                        const groupData = globalState.processedData[groupId]
                            .map(row => utils.parseNumericValue(row[paramName]))
                            .filter(val => !isNaN(val));

                        if (groupData.length > 0) {
                            const stats = statistics.calculate(groupData);
                            lines.push(`  ${group.name}:`);
                            lines.push(`    N: ${stats.count}`);
                            if (stats.mean !== null) lines.push(`    Mean: ${stats.mean.toFixed(3)}`);
                            if (stats.median !== null) lines.push(`    Median: ${stats.median.toFixed(3)}`);
                            if (stats.stdDev !== null) lines.push(`    Std Dev: ${stats.stdDev.toFixed(3)}`);
                            if (stats.min !== null && stats.max !== null) {
                                lines.push(`    Range: [${stats.min.toFixed(3)}, ${stats.max.toFixed(3)}]`);
                            }
                        }
                    });
                });
                lines.push('');
            }

            if (includeTests && globalState.significanceResults.length > 0) {
                lines.push('SIGNIFICANCE TEST RESULTS');
                lines.push('-'.repeat(40));

                globalState.significanceResults.forEach((testResult, index) => {
                    lines.push('');
                    lines.push(`Test ${index + 1}: ${testResult.result.test}`);
                    lines.push(`Parameter: ${testResult.paramName}`);
                    lines.push(`Groups: ${testResult.groupNames.join(' vs ')}`);
                    if (testResult.result.pValue !== undefined) {
                        lines.push(`p-value: ${testResult.result.pValue.toFixed(6)}`);
                    }
                    lines.push(`Result: ${testResult.result.significant ? 'SIGNIFICANT' : 'Not significant'} (α = ${testResult.result.alpha})`);

                    if (testResult.result.effectSize !== undefined) {
                        lines.push(`Effect Size: ${testResult.result.effectSize.toFixed(3)}`);
                    }
                });
                lines.push('');
            }

            if (includeFourfold && globalState.fourfoldResults) {
                lines.push('FOURFOLD TABLE ANALYSIS');
                lines.push('-'.repeat(40));
                const results = globalState.fourfoldResults;

                // Format test and condition names with negation
                const name1 = results.not1 ? `NOT ${results.testConstellation}` : results.testConstellation;
                const name2 = results.not2 ? `NOT ${results.trueConditionConstellation}` : results.trueConditionConstellation;

                lines.push(`${name1} vs ${name2}`);
                if (results.stats.odds.oddsRatio !== undefined) {
                    lines.push(`Odds Ratio: ${results.stats.odds.oddsRatio.toFixed(3)}`);
                }
                if (results.stats.chiSquare.pValue !== undefined) {
                    lines.push(`Chi-Square p-value: ${results.stats.chiSquare.pValue.toFixed(4)}`);
                }
                if (results.stats.fisherExact.pValue !== undefined) {
                    lines.push(`Fisher's Exact p-value: ${results.stats.fisherExact.pValue.toFixed(4)}`);
                }
                lines.push('');
            }

            lines.push('='.repeat(60));
            lines.push('End of Report');

            const content = lines.join('\n');
            const timestamp = utils.getTimestamp();

            // Use data URL for text files
            const dataUrl = 'data:text/plain;charset=utf-8,' + encodeURIComponent(content);

            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = `sra-${timestamp}-comprehensive-report.txt`;
            link.click();

            utils.showSuccess('Comprehensive report exported successfully!');
        }
    </script>
</body>

</html>
