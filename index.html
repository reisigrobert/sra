<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statistical Research Analyzer (SRA)</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="graphics/favicon.svg">

    <!-- Local library imports (these files must be downloaded to the /lib folder) -->
    <script src="lib/papaparse.min.js"></script>
    <script src="lib/chart.umd.js"></script>
    <script src="lib/jstat.min.js"></script>
    <script src="lib/html2canvas.min.js"></script>
    <script src="lib/simple-statistics.min.js"></script>

    <style>
        /**
         * Main CSS Stylesheet
         * This includes all the styling for the application components
         */

        /* Variables for consistent theming - dark theme */
        :root {
            --primary-color: #5a9fd4;
            --primary-hover: #4a8fc4;
            --secondary-color: #52a373;
            --secondary-hover: #429363;
            --accent-color: #7a8b99;
            --accent-hover: #6a7b89;
            --danger-color: #c85450;
            --danger-hover: #b84440;
            --success-color: #52a373;
            --warning-color: #d4a25a;
            --dark-color: #0f1419;
            --light-color: #1c2127;
            --border-color: #2d3339;
            --text-color: #e1e8ed;
            --text-light: #8b98a5;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            --transition-speed: 0.2s;
            --background-dark: #0f1419;
            --background-medium: #1c2127;
            --background-light: #22272e;
            --card-background: #1c2127;
            --input-background: #22272e;
            --hover-background: rgba(90, 159, 212, 0.1);
        }

        /* Base styling */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            width: 100%;
            overflow-x: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-dark);
            padding: 20px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--background-medium);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
            transition: background var(--transition-speed);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #3d4349;
        }

        /* Container to hold application content */
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header styling */
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .header-title h1 {
            color: var(--text-color);
            margin-bottom: 5px;
            font-weight: 600;
        }

        .header-title p {
            color: var(--text-light);
            font-size: 14px;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        /* Card component for sections */
        .card {
            background: var(--card-background);
            border-radius: 12px;
            box-shadow: var(--box-shadow);
            padding: 24px;
            margin-bottom: 24px;
            border: 1px solid var(--border-color);
        }

        /* Section headers */
        h2,
        h3,
        h4 {
            color: var(--text-color);
            margin-bottom: 16px;
            font-weight: 600;
        }

        h2 {
            font-size: 20px;
        }

        h3 {
            font-size: 18px;
        }

        h4 {
            font-size: 16px;
        }

        /* File upload area */
        .file-input {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            text-align: center;
            transition: all var(--transition-speed) ease;
            background-color: var(--background-light);
        }

        .file-input:hover {
            border-color: var(--primary-color);
            background-color: var(--hover-background);
        }

        .file-input.dragover {
            border-color: var(--primary-color);
            background-color: var(--hover-background);
            transform: scale(1.02);
        }

        .file-input input {
            display: none;
        }

        .file-input label {
            padding: 10px 24px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            transition: all var(--transition-speed);
            font-weight: 500;
        }

        .file-input label:hover {
            background-color: var(--primary-hover);
            transform: translateY(-1px);
        }

        /* Data preview table */
        .data-preview {
            overflow-x: auto;
            max-height: 400px;
            margin-top: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--background-light);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        table th,
        table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }

        table th {
            background-color: var(--background-medium);
            position: sticky;
            top: 0;
            z-index: 10;
            font-weight: 600;
            color: var(--text-color);
        }

        table tbody tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.02);
        }

        table tbody tr:hover {
            background-color: var(--hover-background);
        }

        /* Data pagination */
        .pagination {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            gap: 4px;
        }

        .pagination button {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            background-color: var(--background-light);
            color: var(--text-color);
            cursor: pointer;
            transition: all var(--transition-speed);
            border-radius: 6px;
            font-size: 14px;
        }

        .pagination button:hover:not(:disabled) {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        .pagination button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Group parameter definitions */
        .parameter-groups {
            margin-bottom: 20px;
        }

        .parameter-group {
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            background-color: var(--background-light);
            position: relative;
            transition: all var(--transition-speed);
        }

        .parameter-group:hover {
            border-color: #3d4349;
        }

        .parameter-group.excluded {
            opacity: 0.6;
            border-color: var(--border-color);
        }

        .parameter-group-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        /* Group controls section */
        .group-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .group-color-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .color-preset-selector {
            padding: 6px 12px;
            background-color: var(--input-background);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-color);
            font-size: 14px;
            transition: all var(--transition-speed);
        }

        .color-preset-selector:hover {
            border-color: var(--primary-color);
        }

        .color-preview {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all var(--transition-speed);
        }

        .color-preview:hover {
            transform: scale(1.1);
        }

        .custom-color-input {
            width: 100px;
            padding: 6px 12px;
            background-color: var(--input-background);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-color);
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 13px;
            transition: all var(--transition-speed);
        }

        .custom-color-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* Editable group name styling */
        .group-name-input {
            font-size: 18px;
            font-weight: 600;
            border: 1px solid transparent;
            background: transparent;
            padding: 6px 12px;
            border-radius: 6px;
            color: var(--text-color);
            transition: all var(--transition-speed);
            min-width: 200px;
        }

        .group-name-input:hover {
            background-color: var(--hover-background);
        }

        .group-name-input:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: var(--input-background);
        }

        .parameter-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-bottom: 16px;
        }

        .parameter-control {
            flex: 1;
            min-width: 320px;
            padding: 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--background-medium);
            position: relative;
            transition: all var(--transition-speed);
        }

        .parameter-control:hover {
            border-color: #3d4349;
        }

        .parameter-control label {
            font-weight: 500;
            margin-bottom: 8px;
            display: block;
            color: var(--text-color);
            font-size: 14px;
        }

        .condition-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 12px;
        }

        /* Form elements */
        select,
        input[type="number"],
        input[type="text"] {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--input-background);
            color: var(--text-color);
            font-family: inherit;
            font-size: 14px;
            transition: all var(--transition-speed);
        }

        select:hover,
        input[type="number"]:hover,
        input[type="text"]:hover {
            border-color: #3d4349;
        }

        select:focus,
        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        select {
            min-width: 140px;
            cursor: pointer;
        }

        input[type="number"] {
            width: 120px;
        }

        /* Parameter info display */
        .parameter-info {
            font-size: 13px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
            color: var(--text-light);
            line-height: 1.5;
        }

        /* Group distribution statistics */
        .group-distribution {
            background-color: var(--background-dark);
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
            font-size: 13px;
            border: 1px solid var(--border-color);
        }

        .distribution-bar {
            height: 8px;
            background-color: var(--background-medium);
            border-radius: 4px;
            margin: 8px 0;
            overflow: hidden;
        }

        .distribution-fill {
            height: 100%;
            background-color: var(--primary-color);
            transition: width var(--transition-speed);
            border-radius: 4px;
        }

        /* Tab navigation */
        .tabs {
            margin-top: 24px;
        }

        .tab-buttons {
            display: flex;
            overflow-x: auto;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 24px;
            background-color: var(--background-medium);
            border-radius: 12px 12px 0 0;
            padding: 4px;
        }

        .tab-button {
            padding: 10px 20px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            font-weight: 500;
            border-radius: 8px;
            margin-right: 4px;
            white-space: nowrap;
            transition: all var(--transition-speed) ease;
            color: var(--text-light);
            font-size: 14px;
        }

        .tab-button:hover {
            background-color: var(--hover-background);
            color: var(--text-color);
        }

        .tab-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        .tab-content {
    display: none;
    animation: fadeIn var(--transition-speed) ease-in;
}

.tab-content.active {
    display: block;
}

/* Force hide all significance test elements outside significance tab */
body:not(.significance-tab-active) #sig-parameter-select,
body:not(.significance-tab-active) #sig-group-selection,
body:not(.significance-tab-active) #check-prerequisites,
body:not(.significance-tab-active) #run-significance-test,
body:not(.significance-tab-active) #clear-significance-results,
body:not(.significance-tab-active) #test-recommendation-inline,
body:not(.significance-tab-active) #prerequisite-results,
body:not(.significance-tab-active) #significance-results {
    display: none !important;
}

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Chart containers */
        .chart-container {
            height: 400px;
            margin-bottom: 24px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--background-medium);
        }

        .chart-container.small {
            height: 300px;
        }

        /* Flexible grid layouts */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stats-card {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            background-color: var(--background-medium);
            transition: all var(--transition-speed);
        }

        .stats-card:hover {
            border-color: #3d4349;
        }

        .stats-card h4 {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 12px;
            margin-bottom: 16px;
            color: var(--text-color);
        }

        /* Group badges */
        .group-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 16px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            margin-right: 8px;
        }

        /* Buttons */
        .btn {
            padding: 8px 20px;
    border: 1px solid transparent;
    border-radius: 8px;
    color: white;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition-speed) ease;
    margin: 8px;
    font-size: 14px;
    background-color: transparent;
        }

        /* Specific spacing for export buttons */
.text-center .btn {
    margin-top: 20px;
    margin-bottom: 10px;
}

/* Card spacing */
.card {
    background: var(--card-background);
    border-radius: 12px;
    box-shadow: var(--box-shadow);
    padding: 24px;
    margin-bottom: 30px;
    border: 1px solid var(--border-color);
}

/* Export section spacing */
.export-section {
    margin-top: 30px;
    padding: 20px;
    background-color: var(--background-medium);
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.export-section h5 {
    margin-bottom: 15px;
    color: var(--text-color);
    font-size: 14px;
}

/* Button container spacing */
.flex-container {
    display: flex;
    flex-wrap: wrap;
    gap: 25px;
}

/* Tab button spacing */
.tab-button {
    padding: 10px 20px;
    background-color: transparent;
    border: none;
    cursor: pointer;
    font-weight: 500;
    border-radius: 8px;
    margin-right: 8px;
    white-space: nowrap;
    transition: all var(--transition-speed) ease;
    color: var(--text-light);
    font-size: 14px;
}

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .btn-primary:hover {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
        }

        .btn-secondary {
            background-color: transparent;
            border-color: var(--secondary-color);
            color: var(--secondary-color);
        }

        .btn-secondary:hover {
            background-color: var(--secondary-color);
            color: white;
        }

        .btn-accent {
            background-color: transparent;
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        .btn-accent:hover {
            background-color: var(--accent-color);
            color: white;
        }

        .btn-danger {
            background-color: transparent;
            border-color: var(--danger-color);
            color: var(--danger-color);
        }

        .btn-danger:hover {
            background-color: var(--danger-color);
            color: white;
        }

        .btn-small {
            padding: 4px 12px;
            font-size: 12px;
        }

        /* Flexible container */
        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .flex-item {
            flex: 1;
            min-width: 300px;
        }

        /* Loading indicator */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            font-size: 16px;
            color: var(--primary-color);
        }

        .loading::after {
            content: "";
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary-color);
            border-top: 2px solid transparent;
            border-radius: 50%;
            margin-left: 12px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Message boxes */
        .error {
            color: var(--danger-color);
            font-weight: 500;
            padding: 16px;
            border: 1px solid var(--danger-color);
            border-radius: 8px;
            background-color: rgba(200, 84, 80, 0.1);
            margin-bottom: 20px;
        }

        .success {
            color: var(--success-color);
            font-weight: 500;
            padding: 16px;
            border: 1px solid var(--success-color);
            border-radius: 8px;
            background-color: rgba(82, 163, 115, 0.1);
            margin-bottom: 20px;
        }

        /* Significance test results */
        .significance-result {
            margin-top: 16px;
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid;
            position: relative;
            background-color: var(--background-medium);
        }

        .significance-result.significant {
            background-color: rgba(82, 163, 115, 0.1);
            border-left-color: var(--secondary-color);
        }

        .significance-result.not-significant {
            background-color: rgba(200, 84, 80, 0.1);
            border-left-color: var(--danger-color);
        }

        /* Test prerequisites section */
        .test-prerequisites {
            background-color: var(--background-medium);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .prerequisite-result {
            margin: 12px 0;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
        }

        .prerequisite-result.pass {
            background-color: rgba(82, 163, 115, 0.1);
            border: 1px solid rgba(82, 163, 115, 0.3);
        }

        .prerequisite-result.fail {
            background-color: rgba(200, 84, 80, 0.1);
            border: 1px solid rgba(200, 84, 80, 0.3);
        }

        /* Warning box for test override */
        .warning-box {
            background-color: rgba(212, 162, 90, 0.1);
            border: 1px solid rgba(212, 162, 90, 0.3);
            border-radius: 6px;
            padding: 12px;
            margin: 12px 0;
            font-size: 14px;
        }

        .warning-box strong {
            color: var(--warning-color);
        }

        /* Test violation warning */
        .test-violation-warning {
            background-color: rgba(200, 84, 80, 0.1);
            border: 1px solid rgba(200, 84, 80, 0.3);
            border-radius: 6px;
            padding: 16px;
            margin: 16px 0;
        }

        .test-violation-warning h5 {
            color: var(--danger-color);
            margin-bottom: 12px;
        }

        .test-violation-warning ul {
            margin-left: 20px;
            margin-top: 12px;
        }

        .test-violation-warning li {
            margin-bottom: 6px;
        }

        /* Checkbox styling */
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--primary-color);
        }

        /* Parameter selector */
        .parameter-selector {
            margin-bottom: 20px;
            padding: 16px;
            background-color: var(--background-medium);
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            border: 1px solid var(--border-color);
        }

        .parameter-selector label {
            font-weight: 500;
            margin-right: 8px;
            color: var(--text-color);
            font-size: 14px;
        }

        .parameter-selector select {
            padding: 8px 12px;
            min-width: 240px;
        }

        /* Statistics table */
        .stats-table-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        /* Clear button for results */
        .clear-results {
            display: block;
            margin: 12px 0;
            padding: 6px 12px;
            background-color: var(--background-light);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-color);
            transition: all var(--transition-speed);
        }

        .clear-results:hover {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        /* Help tooltips */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            margin-left: 6px;
            font-size: 14px;
            color: var(--primary-color);
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 260px;
            background-color: var(--background-light);
            color: var(--text-color);
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            margin-left: -130px;
            opacity: 0;
            transition: opacity var(--transition-speed);
            font-size: 12px;
            font-weight: normal;
            line-height: 1.5;
            border: 1px solid var(--border-color);
            box-shadow: var(--box-shadow);
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Test info box */
        .test-info {
            background-color: rgba(90, 159, 212, 0.1);
            border: 1px solid rgba(90, 159, 212, 0.3);
            border-radius: 6px;
            padding: 12px;
            margin: 12px 0;
            font-size: 14px;
        }

        /* Regression controls */
        .regression-controls {
            margin-bottom: 16px;
            padding: 12px;
            background-color: var(--background-medium);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        /* Regression type selector */
        .regression-type-container {
            margin-bottom: 12px;
        }

        .regression-type-container label {
            font-weight: 500;
            margin-right: 10px;
            color: var(--text-color);
            font-size: 14px;
        }

        /* Regression significance info */
        .regression-significance {
            margin-top: 12px;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
        }

        .regression-significance.significant {
            background-color: rgba(82, 163, 115, 0.1);
            border: 1px solid rgba(82, 163, 115, 0.3);
        }

        .regression-significance.not-significant {
            background-color: rgba(200, 84, 80, 0.1);
            border: 1px solid rgba(200, 84, 80, 0.3);
        }

        /* Scale type badges */
        .scale-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
            text-transform: uppercase;
        }

        .scale-badge.nominal {
            background-color: #3d4349;
            color: var(--text-light);
        }

        .scale-badge.ordinal {
            background-color: #4d5359;
            color: var(--text-light);
        }

        .scale-badge.interval {
            background-color: #5d6369;
            color: var(--text-color);
        }

        .scale-badge.ratio {
            background-color: #6d7379;
            color: var(--text-color);
        }

        /* Parameter constellation styles */
        .parameter-constellations {
            margin-bottom: 24px;
            padding: 20px;
            background-color: var(--background-medium);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .parameter-constellations h3 {
            margin-bottom: 8px;
        }

        .parameter-constellations>p {
            color: var(--text-light);
            font-size: 14px;
            margin-bottom: 16px;
        }

        .constellation-item {
            padding: 16px;
            margin-bottom: 16px;
            background-color: var(--background-light);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: all var(--transition-speed);
        }

        .constellation-item:hover {
            border-color: #3d4349;
        }

        .constellation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .constellation-name {
            font-weight: 600;
            color: var(--primary-color);
            background-color: transparent;
            border: 1px solid transparent;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all var(--transition-speed);
            font-size: 16px;
            min-width: 200px;
        }

        .constellation-name:hover {
            background-color: var(--hover-background);
        }

        .constellation-name:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: var(--input-background);
        }

        .constellation-conditions {
            font-size: 14px;
            color: var(--text-light);
        }

        /* Constellation reference in groups */
        .constellation-reference {
            background-color: var(--background-dark) !important;
            border: 1px solid var(--primary-color) !important;
        }

        .constellation-reference.negated {
            background-color: rgba(200, 84, 80, 0.1) !important;
            border-color: var(--danger-color) !important;
        }

        .negation-checkbox {
            margin-right: 8px;
            accent-color: var(--danger-color);
        }

        /* Group condition selector */
        .group-conditions {
            margin-bottom: 16px;
        }

        .condition-type-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .condition-type-selector button {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--border-color);
            background-color: var(--background-light);
            color: var(--text-color);
            cursor: pointer;
            transition: all var(--transition-speed);
            border-radius: 6px;
            font-weight: 500;
            font-size: 14px;
        }

        .condition-type-selector button:hover {
            background-color: var(--hover-background);
            border-color: var(--primary-color);
        }

        .condition-type-selector button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Not in previous group checkbox */
        .not-in-previous-checkbox {
            margin: 16px 0;
            padding: 12px;
            background-color: rgba(212, 162, 90, 0.1);
            border: 1px solid rgba(212, 162, 90, 0.3);
            border-radius: 6px;
        }

        /* Fourfold table styles */
        .fourfold-table {
            margin: 20px 0;
        }

        .fourfold-selector {
            margin-bottom: 24px;
            padding: 20px;
            background-color: var(--background-medium);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .fourfold-selector-item {
            margin-bottom: 16px;
        }

        .fourfold-selector-item label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color);
            font-size: 14px;
        }

        .fourfold-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .fourfold-grid {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 12px;
            margin-bottom: 24px;
        }

        .fourfold-cell {
            padding: 16px;
            border: 1px solid var(--border-color);
            text-align: center;
            background-color: var(--background-medium);
            border-radius: 6px;
        }

        .fourfold-header {
            background-color: var(--background-light);
            font-weight: 600;
        }

        .fourfold-value {
            font-size: 1.5em;
            font-weight: 700;
            color: var(--primary-color);
        }

        .fourfold-statistics {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 16px;
            margin-top: 24px;
        }

        .fourfold-stat-card {
            padding: 16px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--background-medium);
            transition: all var(--transition-speed);
        }

        .fourfold-stat-card:hover {
            border-color: #3d4349;
        }

        .fourfold-stat-card h5 {
            margin-bottom: 8px;
            color: var(--text-color);
            font-size: 14px;
        }

        .fourfold-stat-value {
            font-size: 1.3em;
            font-weight: 700;
            color: var(--primary-color);
        }

        /* Data validation warnings */
        .validation-warnings {
            background-color: rgba(212, 162, 90, 0.1);
            border: 1px solid rgba(212, 162, 90, 0.3);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .validation-warnings h4 {
            color: var(--warning-color);
            margin-bottom: 12px;
        }

        .validation-warnings ul {
            margin-left: 20px;
        }

        .validation-warnings li {
            margin-bottom: 6px;
            font-size: 14px;
        }

        /* About modal */
        #about-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        #about-modal>div {
            position: relative;
            width: 80%;
            max-width: 600px;
            margin: 80px auto;
            background-color: var(--card-background);
            padding: 32px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            max-height: calc(100vh - 160px);
            overflow-y: auto;
        }

        #close-about {
            position: absolute;
            top: 16px;
            right: 16px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-light);
            transition: color var(--transition-speed);
        }

        #close-about:hover {
            color: var(--text-color);
        }

        /* Export results section */
        .export-section {
            margin-top: 24px;
            padding: 16px;
            background-color: var(--background-medium);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .export-section h5 {
            margin-bottom: 12px;
            color: var(--text-color);
            font-size: 14px;
        }

        /* Text center utility */
        .text-center {
            text-align: center;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .parameter-control {
                min-width: 100%;
            }

            .tab-button {
                padding: 8px 16px;
                font-size: 13px;
            }

            .flex-item {
                min-width: 100%;
            }

            .condition-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .group-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }

        /* Intelligente Testauswahl Styles */
.intelligent-test-panel {
    margin-bottom: 30px;
    padding: 20px;
    background-color: var(--background-medium);
    border-radius: 12px;
    border: 1px solid var(--border-color);
}

.test-recommendation-section {
    margin-bottom: 25px;
}

.recommendation-controls {
    display: flex;
    gap: 15px;
    margin: 15px 0;
}

.recommendation-display {
    margin-top: 20px;
}

.recommendation-card {
    padding: 20px;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    background-color: var(--background-light);
}

.recommendation-card.confidence-high {
    border-left: 4px solid var(--success-color);
    background-color: rgba(82, 163, 115, 0.05);
}

.recommendation-card.confidence-medium {
    border-left: 4px solid var(--warning-color);
    background-color: rgba(212, 162, 90, 0.05);
}

.recommendation-card.confidence-low {
    border-left: 4px solid var(--danger-color);
    background-color: rgba(200, 84, 80, 0.05);
}

.recommended-test-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border-color);
}

.confidence-indicator {
    display: flex;
    align-items: center;
    gap: 10px;
}

.confidence-bar {
    width: 100px;
    height: 8px;
    background-color: var(--background-dark);
    border-radius: 4px;
    overflow: hidden;
}

.confidence-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--danger-color) 0%, var(--warning-color) 50%, var(--success-color) 100%);
    transition: width 0.3s ease;
}

.confidence-text {
    font-weight: bold;
    min-width: 40px;
}

.test-indication {
    margin: 15px 0;
    padding: 12px;
    background-color: rgba(90, 159, 212, 0.1);
    border-radius: 6px;
    border-left: 3px solid var(--primary-color);
}

.test-details {
    margin: 15px 0;
}

.test-details p {
    margin: 5px 0;
    font-size: 14px;
}

.test-violations, .test-warnings {
    margin: 15px 0;
    padding: 12px;
    border-radius: 6px;
}

.test-violations {
    background-color: rgba(200, 84, 80, 0.1);
    border-left: 3px solid var(--danger-color);
}

.test-warnings {
    background-color: rgba(212, 162, 90, 0.1);
    border-left: 3px solid var(--warning-color);
}

.alternative-tests {
    margin: 15px 0;
    padding: 12px;
    background-color: var(--background-dark);
    border-radius: 6px;
}

.alternative-tests ul {
    margin: 10px 0 0 20px;
}

.alternative-tests li {
    margin-bottom: 8px;
}

.recommendation-explanation {
    margin-top: 15px;
    padding: 12px;
    background-color: rgba(90, 159, 212, 0.05);
    border-radius: 6px;
}

.explanation-text {
    font-size: 14px;
    line-height: 1.5;
}

.prerequisite-overview {
    margin-top: 20px;
}

.prerequisite-summary {
    margin-top: 10px;
}

.prerequisite-section {
    margin-bottom: 15px;
}

.prerequisite-section h6 {
    margin-bottom: 8px;
    color: var(--text-color);
    font-size: 14px;
}

.prerequisite-item {
    padding: 8px 12px;
    margin: 5px 0;
    border-radius: 4px;
    font-size: 13px;
    border-left: 3px solid;
}

.prerequisite-item.pass {
    background-color: rgba(82, 163, 115, 0.1);
    border-left-color: var(--success-color);
}

.prerequisite-item.fail {
    background-color: rgba(200, 84, 80, 0.1);
    border-left-color: var(--danger-color);
}

.prerequisite-item.warning {
    background-color: rgba(212, 162, 90, 0.1);
    border-left-color: var(--warning-color);
}

.prerequisite-item.error {
    background-color: rgba(160, 160, 160, 0.1);
    border-left-color: var(--accent-color);
}
    </style>
</head>

<body>
    <div class="container">
        <header>
            <div class="header-title">
                <h1>Statistical Research Analyzer (SRA)</h1>
                <p>A comprehensive tool for statistical analysis and visualization</p>
            </div>
            <div class="header-actions">
                <button id="about-btn" class="btn btn-accent">About</button>
            </div>
        </header>

        <!-- File Import Section -->
        <div class="card">
            <h2>Data Import</h2>
            <div class="file-input" id="file-input-area">
                <h3>Import CSV Data</h3>
                <p>Upload a CSV file with the following format:</p>
                <ul style="text-align: left; margin: 10px 0;">
                    <li><strong>Row 1:</strong> Column Headers</li>
                    <li><strong>Row 2:</strong> Data Types
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li><strong>k</strong> = Categorical (Nominal scale)</li>
                            <li><strong>o</strong> = Ordinal (Ordinal scale, e.g., 1-5 ratings)</li>
                            <li><strong>i</strong> = Interval (Interval scale, e.g., temperature)</li>
                            <li><strong>r</strong> = Ratio (Ratio scale, e.g., age, weight)</li>
                        </ul>
                    </li>
                    <li><strong>Row 3+:</strong> Data Rows</li>
                </ul>
                <p><em>Delimiter: Semicolon (;) or Comma (,) | Decimal: Comma (,) or Point (.)</em></p>
                <input type="file" id="csv-file" accept=".csv">
                <label for="csv-file">Select File or Drag & Drop</label>
            </div>

            <div id="loading" class="loading" style="display: none;">
                Processing data...
            </div>

            <div id="error-message" class="error" style="display: none;"></div>
            <div id="success-message" class="success" style="display: none;"></div>

            <div id="validation-warnings" class="validation-warnings" style="display: none;">
                <h4>⚠️ Data Validation Warnings</h4>
                <ul id="validation-warnings-list"></ul>
            </div>
        </div>

        <!-- Data Preview Section -->
        <div id="data-preview-container" class="card" style="display: none;">
            <h2>Data Preview</h2>
            <div id="data-summary" style="margin-bottom: 15px;"></div>

            <div class="data-preview">
                <table id="data-preview-table"></table>
            </div>

            <!-- Pagination Controls -->
            <div class="pagination" id="data-pagination"></div>

            <!-- Data Options -->
            <div class="flex-container" style="margin-top: 15px;">
                <div class="flex-item">
                    <label for="rows-per-page">Rows per page:</label>
                    <select id="rows-per-page" onchange="updateDataPagination()">
                        <option value="10">10</option>
                        <option value="25" selected>25</option>
                        <option value="50">50</option>
                        <option value="100">100</option>
                        <option value="200">200</option>
                    </select>
                </div>
                <div class="flex-item">
                    <button id="export-preview-csv" class="btn btn-accent">Export Preview as CSV</button>
                </div>
            </div>
        </div>

        <!-- Group Definition Section -->
        <div id="group-definition-container" class="card" style="display: none;">
            <h2>Define Subgroups</h2>

            <!-- Parameter Constellations Section -->
            <div class="parameter-constellations">
                <h3>Parameter Constellations</h3>
                <p>Define reusable parameter combinations that can be used in multiple groups (optional):</p>
                <div id="constellation-list"></div>
                <button id="add-constellation" class="btn btn-primary btn-small">Add New Constellation</button>
            </div>

            <p>Create subgroups by combining parameter constellations and/or individual conditions:</p>

            <div class="parameter-groups" id="parameter-groups">
                <!-- Dynamically populated -->
            </div>

            <div style="margin-top: 20px;">
                <button id="add-group" class="btn btn-primary">Add New Subgroup</button>
                <button id="apply-groups" class="btn btn-secondary">Apply Groups & Analyze</button>
                <button id="reset-groups" class="btn btn-danger">Reset</button>
                <button id="import-groups" class="btn btn-accent">Import Definition</button>
                <button id="export-groups" class="btn btn-accent">Export Definition</button>
            </div>
        </div>

        <!-- Analysis Results Section -->
        <div id="analysis-results" class="card" style="display: none;">
            <h2>Analysis Results</h2>

            <div class="tabs">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="overview">Overview</button>
                    <button class="tab-button" data-tab="detailed">Detailed Analysis</button>
                    <button class="tab-button" data-tab="significance">Significance Tests</button>
                    <button class="tab-button" data-tab="visualization">Visualization</button>
                    <button class="tab-button" data-tab="fourfold">Fourfold Table</button>
                    <button class="tab-button" data-tab="export">Export</button>
                </div>

                <!-- Overview Tab -->
                <div class="tab-content active" id="overview">
                    <h3>Group Overview</h3>
                    <div class="flex-container">
                        <div class="flex-item">
                            <div id="group-summary-table"></div>
                        </div>
                        <div class="flex-item">
                            <div class="chart-container small">
                                <canvas id="group-distribution-chart"></canvas>
                            </div>
                            <div class="text-center">
                                <button class="btn btn-small btn-accent"
                                    onclick="exportChartAsImage('group-distribution-chart')">Export Chart</button>
                            </div>
                        </div>
                    </div>

                    <h3>Statistical Metrics for All Parameters</h3>
                    <div class="stats-table-container">
                        <table id="overview-stats-table"></table>
                    </div>
                    <div class="text-center">
                        <button class="btn btn-small btn-accent"
                            onclick="exportTableAsCSV('overview-stats-table', 'overview-statistics')">Export Statistics
                        </button>
                    </div>
                </div>

                <!-- Detailed Analysis Tab -->
                <div class="tab-content" id="detailed">
                    <h3>Detailed Parameter Analysis</h3>

                    <div class="parameter-selector">
                        <label for="detail-parameter-select">Select Parameter:</label>
                        <select id="detail-parameter-select">
                            <option value="">Please select a parameter</option>
                        </select>
                        <span class="tooltip">ⓘ
                            <span class="tooltip-text">Select a numeric parameter (ordinal, interval, or ratio scale) to
                                view detailed statistics across all groups</span>
                        </span>
                    </div>

                    <div id="detail-analysis-content">
                        <div class="flex-container">
                            <div class="flex-item">
                                <h4>Mean Values with Error Bars</h4>
                                <div class="chart-container">
                                    <canvas id="detail-mean-chart"></canvas>
                                </div>
                                <div class="text-center">
                                    <button class="btn btn-small btn-accent"
                                        onclick="exportChartAsImage('detail-mean-chart')">Export Chart</button>
                                </div>
                            </div>
                            <div class="flex-item">
                                <h4>Distribution Comparison</h4>
                                <div class="chart-container">
                                    <canvas id="detail-distribution-chart"></canvas>
                                </div>
                                <div class="text-center">
                                    <button class="btn btn-small btn-accent"
                                        onclick="exportChartAsImage('detail-distribution-chart')">Export Chart</button>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 30px;">
                            <h4>Data Distribution Analysis</h4>

                            <!-- Add group selection controls -->
                            <div
                                style="margin-bottom: 15px; padding: 15px; background-color: var(--background-medium); border-radius: 8px; border: 1px solid var(--border-color);">
                                <div style="margin-bottom: 10px;">
                                    <strong>Select Groups to Display:</strong>
                                    <button id="histogram-select-all" class="btn btn-small btn-primary"
                                        style="margin-left: 10px;">Select All</button>
                                    <button id="histogram-select-none" class="btn btn-small btn-accent">Select
                                        None</button>
                                </div>
                                <div id="histogram-group-selection" style="display: flex; flex-wrap: wrap; gap: 10px;">
                                    <!-- Group checkboxes will be inserted here -->
                                </div>
                            </div>

                            <div class="chart-container">
                                <canvas id="detail-histogram-chart"></canvas>
                            </div>
                            <div class="text-center">
                                <button class="btn btn-small btn-accent"
                                    onclick="exportChartAsImage('detail-histogram-chart')">Export Chart</button>
                            </div>
                        </div>

                        <h4>Detailed Statistics</h4>
                        <div class="stats-table-container">
                            <table id="detail-stats-table"></table>
                        </div>
                        <div class="text-center">
                            <button class="btn btn-small btn-accent"
                                onclick="exportTableAsCSV('detail-stats-table', 'detailed-statistics')">Export
                                Statistics
                            </button>
                        </div>
                    </div>
                </div>

              <!-- Significance Tests Tab -->
<div class="tab-content" id="significance">
    <h3>Statistical Significance Tests</h3>
    
    <!-- Step 1: Parameter and Group Selection -->
    <div class="card" style="background-color: var(--background-medium); margin-bottom: 30px;">
        <h4>📊 Step 1: Select Parameter and Groups</h4>
        
        <div class="flex-container" style="margin-bottom: 20px;">
            <div class="flex-item">
                <label for="sig-parameter-select">Parameter for Testing:</label>
                <select id="sig-parameter-select" style="width: 100%; margin-top: 5px;">
                    <option value="">Select parameter</option>
                </select>
            </div>
        </div>
        
        <div style="margin-bottom: 20px;">
            <h5>Select Groups for Comparison:</h5>
            <div id="sig-group-selection" class="flex-container" style="margin-top: 10px;"></div>
        </div>
    </div>
    
    <!-- Step 2: Optional Prerequisites (completely independent) -->
    <div class="card" style="background-color: var(--background-medium); margin-bottom: 30px;">
    <h4>📋 Step 2: Check Prerequisites (Optional)</h4>
    
    <div style="text-align: center; margin-bottom: 20px;">
        <button id="check-prerequisites" class="btn btn-primary">Check Prerequisites & Get Recommendation</button>
    </div>
    
    <!-- Override checkboxes moved to top -->
    <div style="margin-bottom: 20px;">
        <div class="checkbox-container" style="padding: 12px; background-color: var(--background-dark); border-radius: 6px; margin-bottom: 10px;">
            <input type="checkbox" id="override-normality" onchange="updateRecommendationBasedOnOverrides()">
            <label for="override-normality">Override normality assumption</label>
        </div>
        <div class="checkbox-container" style="padding: 12px; background-color: var(--background-dark); border-radius: 6px;">
            <input type="checkbox" id="override-homogeneity" onchange="updateRecommendationBasedOnOverrides()">
            <label for="override-homogeneity">Override variance homogeneity assumption</label>
        </div>
    </div>
    
    <div id="prerequisite-results" style="margin-bottom: 20px;"></div>
    
    <div id="test-recommendation-display" style="display: none; margin-bottom: 20px; padding: 15px; background-color: var(--background-light); border-radius: 8px; border: 1px solid var(--primary-color);">
        <h5 style="color: var(--primary-color); margin-bottom: 10px;">🎯 Recommended Test</h5>
        <div id="recommendation-content"></div>
    </div>
</div>
    
    <!-- Step 3: Test Execution (completely independent) -->
    <div class="card" style="background-color: var(--background-medium); margin-bottom: 30px;">
        <h4>🧪 Step 3: Run Statistical Test</h4>
        
        <div class="flex-container" style="margin-bottom: 20px;">
            <div class="flex-item">
                <label for="sig-test-type">Test Method:</label>
                <select id="sig-test-type" style="width: 100%; margin-top: 5px;">
                    <option value="">Select test manually...</option>
                    <optgroup label="Parametric Tests">
                        <option value="ttest">t-Test (2 groups, normal distribution)</option>
                        <option value="welch">Welch's t-Test (2 groups, unequal variances)</option>
                        <option value="anova">ANOVA (>2 groups, normal distribution)</option>
                    </optgroup>
                    <optgroup label="Non-Parametric Tests">
                        <option value="mann-whitney">Mann-Whitney U (2 groups, non-normal)</option>
                        <option value="wilcoxon">Wilcoxon Signed-Rank (paired samples)</option>
                        <option value="kruskal-wallis">Kruskal-Wallis (>2 groups, non-normal)</option>
                    </optgroup>
                    <optgroup label="Categorical Tests">
                        <option value="chi-square">Chi-Square (categorical data)</option>
                        <option value="fisher">Fisher's Exact (2x2 tables, small samples)</option>
                    </optgroup>
                </select>
                <div id="test-info" class="test-info" style="display: none; margin-top: 10px;"></div>
            </div>
            <div class="flex-item">
                <label for="sig-alpha">Significance Level (α):</label>
                <select id="sig-alpha" style="width: 100%; margin-top: 5px;">
                    <option value="0.05">0.05 (5%)</option>
                    <option value="0.01">0.01 (1%)</option>
                    <option value="0.1">0.10 (10%)</option>
                    <option value="custom">Custom</option>
                </select>
                <input type="number" id="sig-custom-alpha" style="width: 100%; margin-top: 5px; display: none;" 
                       min="0.001" max="0.5" step="0.001" value="0.05">
            </div>
            <div class="flex-item">
                <label for="sig-direction">Test Direction:</label>
                <select id="sig-direction" style="width: 100%; margin-top: 5px;">
                    <option value="two-sided">Two-sided (≠)</option>
                    <option value="left">Left-sided (<)</option>
                    <option value="right">Right-sided (>)</option>
                </select>
            </div>
        </div>
        
        <div style="text-align: center; margin: 30px 0;">
            <button id="run-significance-test" class="btn btn-primary" style="padding: 12px 40px; font-size: 16px;">
                Run Statistical Test
            </button>
            <button id="clear-significance-results" class="btn btn-danger" style="margin-left: 15px;">
                Clear Results
            </button>
        </div>
    </div>
    
    <!-- Results Section -->
    <div id="significance-results"></div>
    
    <!-- Export Section -->
    <div class="export-section" style="margin-top: 30px;">
        <h5>Export Test Results</h5>
        <button class="btn btn-accent btn-small" onclick="exportSignificanceTests()" style="margin-top: 15px;">
            Export All Test Results
        </button>
    </div>
</div>

                <!-- Visualization Tab -->
                <div class="tab-content" id="visualization">
                    <h3>Custom Visualization</h3>

                    <div class="flex-container" style="margin-bottom: 20px;">
                        <div class="flex-item">
                            <label for="viz-parameter-x">X-Axis Parameter:</label>
                            <select id="viz-parameter-x" style="width: 100%; margin-top: 5px;"></select>
                        </div>
                        <div class="flex-item">
                            <label for="viz-parameter-y">Y-Axis Parameter:</label>
                            <select id="viz-parameter-y" style="width: 100%; margin-top: 5px;"></select>
                        </div>
                        <div class="flex-item">
                            <label for="viz-chart-type">Chart Type:</label>
                            <select id="viz-chart-type" style="width: 100%; margin-top: 5px;">
                                <option value="scatter">Scatter Plot</option>
                                <option value="bar">Bar Chart</option>
                                <option value="line">Line Chart</option>
                            </select>
                        </div>
                    </div>

                    <!-- Regression Controls -->
                    <div class="regression-controls" id="regression-controls" style="display: none;">
                        <div class="regression-type-container">
                            <label for="regression-type">Regression Type:</label>
                            <select id="regression-type">
                                <option value="linear">Linear</option>
                                <option value="polynomial2">Polynomial (2nd order)</option>
                                <option value="polynomial3">Polynomial (3rd order)</option>
                                <option value="logarithmic">Logarithmic</option>
                                <option value="exponential">Exponential</option>
                            </select>
                            <span class="tooltip">ⓘ
                                <span class="tooltip-text">
                                    Linear: y = ax + b<br>
                                    Polynomial: y = ax² + bx + c<br>
                                    Logarithmic: y = a·ln(x) + b<br>
                                    Exponential: y = a·e^(bx)
                                </span>
                            </span>
                        </div>
                        <div class="checkbox-container">
                            <input type="checkbox" id="show-regression" checked>
                            <label for="show-regression">Show regression line</label>
                        </div>
                        <div class="regression-type-container" style="margin-top: 10px;">
    <label for="regression-alpha">Confidence Level:</label>
    <select id="regression-alpha">
        <option value="0.05">95% (α = 0.05)</option>
        <option value="0.01">99% (α = 0.01)</option>
        <option value="0.1">90% (α = 0.10)</option>
        <option value="custom">Custom</option>
    </select>
    <input type="number" id="regression-custom-alpha" style="display: none; margin-left: 10px; width: 80px;" 
           min="0.001" max="0.5" step="0.001" value="0.05" 
           placeholder="α value">
</div>
                        <div id="regression-info" style="margin-top: 10px; font-size: 0.9em; color: var(--text-light);">
                        </div>
                    </div>

                    <button id="generate-visualization" class="btn btn-primary">Generate Chart</button>

                    <div class="chart-container">
                        <canvas id="custom-visualization-chart"></canvas>
                    </div>

                    <div class="text-center">
                        <button class="btn btn-accent" onclick="exportChartAsImage('custom-visualization-chart')">Export
                            Chart
                        </button>
                    </div>
                </div>

                <!-- Fourfold Table Tab -->
                <div class="tab-content" id="fourfold">
                    <h3>Fourfold Table Analysis</h3>

                    <div class="fourfold-selector">
                        <p>Select two parameter constellations for comparison:</p>
                        <div class="fourfold-selector-item">
                            <label for="fourfold-constellation-1">Test Constellation (what is being tested):</label>
                            <div class="fourfold-controls">
                                <input type="checkbox" id="fourfold-not-1" class="negation-checkbox">
                                <label for="fourfold-not-1">NOT</label>
                                <select id="fourfold-constellation-1" style="flex: 1;">
                                    <option value="">Select test constellation</option>
                                </select>
                            </div>
                        </div>
                        <div class="fourfold-selector-item">
                            <label for="fourfold-constellation-2">True Condition Constellation (gold standard):</label>
                            <div class="fourfold-controls">
                                <input type="checkbox" id="fourfold-not-2" class="negation-checkbox">
                                <label for="fourfold-not-2">NOT</label>
                                <select id="fourfold-constellation-2" style="flex: 1;">
                                    <option value="">Select true condition constellation</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <button id="generate-fourfold" class="btn btn-primary">Generate Fourfold Table</button>

                    <div id="fourfold-results" style="margin-top: 20px;"></div>

                    <div class="export-section" id="fourfold-export" style="display: none;">
                        <h5>Export Fourfold Table</h5>
                        <button class="btn btn-accent btn-small" onclick="exportFourfoldTable()">Export Fourfold
                            Analysis
                        </button>
                    </div>
                </div>

                <!-- Export Tab -->
                <div class="tab-content" id="export">
                    <h3>Export Data</h3>

                    <div class="flex-container">
                        <div class="flex-item">
                            <h4>Data Export</h4>
                            <p>Export the grouped analysis as a CSV file:</p>
                            <div style="margin: 15px 0;">
                                <div class="checkbox-container">
                                    <input type="checkbox" id="export-raw-data" checked>
                                    <label for="export-raw-data">Raw data with grouping</label>
                                </div>
                                <div class="checkbox-container">
                                    <input type="checkbox" id="export-statistics" checked>
                                    <label for="export-statistics">Statistical metrics</label>
                                </div>
                                <div class="checkbox-container">
                                    <input type="checkbox" id="export-group-definitions" checked>
                                    <label for="export-group-definitions">Group definitions</label>
                                </div>
                            </div>
                            <button id="export-csv-data" class="btn btn-secondary">Export as CSV</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- About Modal -->
        <div id="about-modal">
            <div>
                <button id="close-about">×</button>
                <h2>About Statistical Research Analyzer</h2>
                <p style="margin: 15px 0;">
                    This application is designed for statistical analysis of research data, allowing for subgroup
                    definition, statistical testing, and visualization of results. All processing is done locally in
                    your browser - no data is sent to any server.
                </p>
                <h4>Features:</h4>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Support for multiple scale types (nominal, ordinal, interval, ratio)</li>
                    <li>Prerequisite testing (normality, variance homogeneity)</li>
                    <li>Multiple parametric and non-parametric tests</li>
                    <li>Multiple visualization options</li>
                    <li>Multiple regression analysis types with significance testing</li>
                </ul>
                <p><strong>Privacy:</strong> All data processing happens locally in your browser. No data is transmitted
                    to any server.</p>
                <p>Version 1.0</p>
            </div>
        </div>
    </div>

    <script>
        /**
         * Statistical Research Analyzer (SRA) - Version 1.0
         * 
         * A comprehensive client-side statistical analysis tool for research data.
         * All processing is done locally for data privacy.
         */

        /**
         * Global State Management
         */
        const globalState = {
    // Data related properties
    rawData: [],                // Original data from CSV
    columnTypes: {},            // Data types for each column
    columnNames: [],            // Column names from CSV header
    processedData: {},          // Data organized by groups
    csvDelimiter: ';',         // CSV delimiter detected from import
    decimalSeparator: '.',     // Decimal separator detected from import

    // Group related properties
    groupDefinitions: [],       // User defined group criteria
    currentGroups: {},          // Current active groups
    parameterConstellations: [], // Reusable parameter combinations

    // UI state
    charts: {},                 // References to all created charts
    isProcessing: false,        // Processing state flag
    currentPage: 1,             // Current page for data pagination
    rowsPerPage: 25,            // Number of rows per page

    // Analysis state
    selectedParameter: null,    // Currently selected parameter for analysis
    significanceResults: [],    // Stored significance test results
    prerequisiteResults: {},    // Stored prerequisite test results
    recordAssignments: [],      // Track which groups each record belongs to
    fourfoldResults: null,      // Store fourfold table results for export
    
    // Add assumption overrides
    assumptionOverrides: {
        normality: {},  // paramName -> { groupId -> boolean }
        homogeneity: {} // paramName -> boolean
    }
};

        /**
         * Color Palette for Groups - dark theme colors
         */
        const groupColors = [
            { bg: 'rgba(90, 159, 212, 0.7)', border: 'rgba(90, 159, 212, 1)', name: 'Blue' },
            { bg: 'rgba(122, 139, 153, 0.7)', border: 'rgba(122, 139, 153, 1)', name: 'Gray' },
            { bg: 'rgba(82, 163, 115, 0.7)', border: 'rgba(82, 163, 115, 1)', name: 'Green' },
            { bg: 'rgba(91, 192, 222, 0.7)', border: 'rgba(91, 192, 222, 1)', name: 'Light Blue' },
            { bg: 'rgba(212, 162, 90, 0.7)', border: 'rgba(212, 162, 90, 1)', name: 'Orange' },
            { bg: 'rgba(200, 84, 80, 0.7)', border: 'rgba(200, 84, 80, 1)', name: 'Red' },
            { bg: 'rgba(160, 160, 160, 0.7)', border: 'rgba(160, 160, 160, 1)', name: 'Light Gray' },
            { bg: 'rgba(100, 100, 100, 0.7)', border: 'rgba(100, 100, 100, 1)', name: 'Dark Gray' },
            { bg: 'rgba(156, 117, 181, 0.7)', border: 'rgba(156, 117, 181, 1)', name: 'Purple' },
            { bg: 'rgba(255, 193, 7, 0.7)', border: 'rgba(255, 193, 7, 1)', name: 'Amber' },
            { bg: 'rgba(0, 188, 212, 0.7)', border: 'rgba(0, 188, 212, 1)', name: 'Cyan' },
            { bg: 'rgba(233, 30, 99, 0.7)', border: 'rgba(233, 30, 99, 1)', name: 'Pink' },
            { bg: 'rgba(139, 195, 74, 0.7)', border: 'rgba(139, 195, 74, 1)', name: 'Light Green' },
            { bg: 'rgba(255, 152, 0, 0.7)', border: 'rgba(255, 152, 0, 1)', name: 'Deep Orange' },
            { bg: 'rgba(96, 125, 139, 0.7)', border: 'rgba(96, 125, 139, 1)', name: 'Blue Gray' },
            { bg: 'rgba(121, 85, 72, 0.7)', border: 'rgba(121, 85, 72, 1)', name: 'Brown' },
            { bg: 'rgba(0, 150, 136, 0.7)', border: 'rgba(0, 150, 136, 1)', name: 'Teal' },
            { bg: 'rgba(103, 58, 183, 0.7)', border: 'rgba(103, 58, 183, 1)', name: 'Deep Purple' }
        ];

        /**
         * Scale Type Definitions
         */
        const scaleTypes = {
            'k': {
                name: 'Nominal',
                description: 'Categories without order (e.g., gender, color)',
                allowedStats: ['mode', 'frequency'],
                allowedTests: ['chi-square', 'fisher'],
                numeric: false
            },
            'o': {
                name: 'Ordinal',
                description: 'Ordered categories (e.g., ratings 1-5, education level)',
                allowedStats: ['median', 'mode', 'quartiles', 'range'],
                allowedTests: ['mann-whitney', 'wilcoxon', 'kruskal-wallis', 'spearman'],
                numeric: true
            },
            'i': {
                name: 'Interval',
                description: 'Equal intervals, no true zero (e.g., temperature in °C)',
                allowedStats: ['mean', 'median', 'mode', 'std', 'quartiles', 'range'],
                allowedTests: ['ttest', 'welch', 'anova', 'mann-whitney', 'kruskal-wallis', 'pearson', 'spearman'],
                numeric: true
            },
            'r': {
                name: 'Ratio',
                description: 'Equal intervals with true zero (e.g., age, weight)',
                allowedStats: ['mean', 'median', 'mode', 'std', 'quartiles', 'range', 'cv'],
                allowedTests: ['ttest', 'welch', 'anova', 'mann-whitney', 'kruskal-wallis', 'pearson', 'spearman'],
                numeric: true
            }
        };

        /**
         * Test Information
         */
        const testInfo = {
            'auto': {
                name: 'Auto-select',
                description: 'Automatically selects the most appropriate test based on data type, scale level, and distribution'
            },
            'ttest': {
                name: 't-Test',
                description: 'Compares means of two groups. Requires normal distribution and equal variances.',
                requirements: 'Normal distribution, equal variances, interval/ratio scale'
            },
            'welch': {
                name: "Welch's t-Test",
                description: 'Modified t-test for two groups with unequal variances. More robust than standard t-test.',
                requirements: 'Normal distribution, interval/ratio scale'
            },
            'anova': {
                name: 'ANOVA',
                description: 'Compares means across multiple groups. Extension of t-test for >2 groups.',
                requirements: 'Normal distribution, equal variances, interval/ratio scale'
            },
            'mann-whitney': {
                name: 'Mann-Whitney U Test',
                description: 'Non-parametric alternative to t-test. Compares distributions of two independent groups.',
                requirements: 'Ordinal, interval, or ratio scale. No normality assumption.'
            },
            'wilcoxon': {
                name: 'Wilcoxon Signed-Rank Test',
                description: 'Non-parametric test for paired samples. Alternative to paired t-test.',
                requirements: 'Paired data, ordinal/interval/ratio scale'
            },
            'kruskal-wallis': {
                name: 'Kruskal-Wallis Test',
                description: 'Non-parametric alternative to ANOVA. Compares distributions across multiple groups.',
                requirements: 'Ordinal, interval, or ratio scale. No normality assumption.'
            },
            'chi-square': {
                name: 'Chi-Square Test',
                description: 'Tests association between categorical variables.',
                requirements: 'Nominal or ordinal scale, expected frequencies ≥ 5'
            },
            'fisher': {
                name: "Fisher's Exact Test",
                description: 'Exact test for 2x2 contingency tables. Used when sample sizes are small.',
                requirements: 'Nominal scale, 2x2 table, small sample sizes'
            },
            'pearson': {
                name: 'Pearson Correlation',
                description: 'Measures linear relationship between two continuous variables.',
                requirements: 'Interval/ratio scale, normal distribution, linear relationship'
            },
            'spearman': {
                name: 'Spearman Correlation',
                description: 'Measures monotonic relationship. Non-parametric alternative to Pearson.',
                requirements: 'Ordinal, interval, or ratio scale. No normality assumption.'
            }
        };

        /**
         * Regression Types Configuration
         */
        const regressionTypes = {
            linear: {
                name: 'Linear',
                equation: 'y = ax + b',
                minPoints: 2,
                transform: null,
                inverseTransform: null
            },
            polynomial2: {
                name: 'Polynomial (2nd order)',
                equation: 'y = ax² + bx + c',
                minPoints: 3,
                transform: null,
                inverseTransform: null
            },
            polynomial3: {
                name: 'Polynomial (3rd order)',
                equation: 'y = ax³ + bx² + cx + d',
                minPoints: 4,
                transform: null,
                inverseTransform: null
            },
            logarithmic: {
                name: 'Logarithmic',
                equation: 'y = a·ln(x) + b',
                minPoints: 2,
                transform: (x) => Math.log(x),
                inverseTransform: (x) => Math.exp(x),
                validate: (points) => points.every(p => p.x > 0)
            },
            exponential: {
                name: 'Exponential',
                equation: 'y = a·e^(bx)',
                minPoints: 2,
                transform: (y) => Math.log(y),
                inverseTransform: (y) => Math.exp(y),
                validate: (points) => points.every(p => p.y > 0)
            }
        };

        /**
         * Utility Functions
         */
        const utils = {
            /**
             * Parse a numeric value from various formats
             */
            parseNumericValue(value) {
                if (value === null || value === undefined || value === '') {
                    return NaN;
                }

                if (typeof value === 'number') {
                    return isNaN(value) ? NaN : value;
                }

                let stringValue = String(value).trim();
                if (stringValue === '') return NaN;

                // Replace comma with period for parseFloat
                stringValue = stringValue.replace(',', '.');

                const parsed = parseFloat(stringValue);
                return isNaN(parsed) ? NaN : parsed;
            },

            /**
             * Numeric comparison with epsilon
             */
            compareNumbers(a, b, operator) {
                const epsilon = this.calculateEpsilon(a, b);

                switch (operator) {
                    case '=':
                        return Math.abs(a - b) < epsilon;
                    case '!=':
                        return Math.abs(a - b) >= epsilon;
                    case '<':
                        return a < (b - epsilon);
                    case '<=':
                        return a <= (b + epsilon);
                    case '>':
                        return a > (b + epsilon);
                    case '>=':
                        return a >= (b - epsilon);
                    default:
                        return false;
                }
            },

            /**
             * Calculate Y-axis range with scale type awareness
             */
            calculateYAxisRange(values, scaleType = 'r') {
                const validValues = values.filter(v => !isNaN(v) && isFinite(v));
                if (validValues.length === 0) {
                    return { min: 0, max: 10 };
                }

                let min = Math.min(...validValues);
                let max = Math.max(...validValues);

                // Only include 0 for ratio scales
                if (scaleType === 'r') {
                    if (min > 0) min = 0;
                    if (max < 0) max = 0;
                }

                // Handle case where all values are the same
                if (min === max) {
                    if (min === 0) {
                        return { min: 0, max: 1 };
                    } else if (min > 0) {
                        return { min: scaleType === 'r' ? 0 : min * 0.9, max: min * 1.1 };
                    } else {
                        return { min: min * 1.1, max: scaleType === 'r' ? 0 : min * 0.9 };
                    }
                }

                // Add small padding
                const range = max - min;
                const padding = range * 0.05;

                if (min < 0 || scaleType !== 'r') min = min - padding;
                if (max > 0 || scaleType !== 'r') max = max + padding;

                return { min, max };
            },

            /**
             * CSV delimiter detection
             */
            detectDelimiter(firstLines) {
                // Count occurrences outside of quotes
                const semicolons = (firstLines.match(/;(?=(?:[^"]*"[^"]*")*[^"]*$)/g) || []).length;
                const commas = (firstLines.match(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/g) || []).length;

                // Check for thousands separator pattern (e.g., "1,234")
                const hasThousandsSeparator = firstLines.match(/\d{1,3},\d{3}/);

                // If we have thousands separators and semicolons, use semicolon as delimiter
                if (hasThousandsSeparator && semicolons > 0) {
                    return ';';
                }

                // Check consistency across lines
                const lines = firstLines.split('\n').slice(0, 5);
                const semicolonCounts = lines.map(line => (line.match(/;(?=(?:[^"]*"[^"]*")*[^"]*$)/g) || []).length);
                const commaCounts = lines.map(line => (line.match(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/g) || []).length);

                // Check consistency
                const semicolonConsistent = semicolonCounts.every(count => count === semicolonCounts[0] && count > 0);
                const commaConsistent = commaCounts.every(count => count === commaCounts[0] && count > 0);

                if (semicolonConsistent && !commaConsistent) return ';';
                if (commaConsistent && !semicolonConsistent) return ',';

                // Default to the one with more occurrences
                return semicolons > commas ? ';' : ',';
            },

            /**
             * Display error message to the user
             */
            showError(message) {
    // Create modal overlay
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
    `;
    
    // Create modal content
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
        background-color: var(--card-background);
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        max-width: 500px;
        width: 90%;
        border: 2px solid var(--danger-color);
    `;
    
    modalContent.innerHTML = `
        <h3 style="color: var(--danger-color); margin-bottom: 15px;">Error</h3>
        <p style="color: var(--text-color); margin-bottom: 20px;">${message}</p>
        <button onclick="this.closest('div').parentElement.remove()" 
                style="background-color: var(--danger-color); 
                       color: white; 
                       border: none; 
                       padding: 10px 20px; 
                       border-radius: 6px; 
                       cursor: pointer;">
            OK
        </button>
    `;
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // Also log to console
    console.error('Error:', message);
},

            /**
             * Display success message to the user
             */
            showSuccess(message) {
    // Create a full-screen overlay for the flash effect
    const flash = document.createElement('div');
    flash.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--success-color);
        opacity: 0;
        pointer-events: none;
        z-index: 1;
        transition: opacity 0.2s ease-in-out;
    `;
    
    document.body.appendChild(flash);
    
    // Trigger the flash
    setTimeout(() => {
        flash.style.opacity = '0.15';
    }, 10);
    
    // Fade out
    setTimeout(() => {
        flash.style.opacity = '0';
    }, 300);
    
    // Remove element
    setTimeout(() => {
        flash.remove();
    }, 600);
    
    // Still log to console for debugging
    console.log('Success:', message);
},

            /**
             * Safely destroy a chart instance
             */
            destroyChart(chartId) {
                if (globalState.charts[chartId]) {
                    try {
                        globalState.charts[chartId].destroy();
                    } catch (e) {
                        console.warn('Error destroying chart:', chartId, e);
                    }
                    delete globalState.charts[chartId];
                }
            },

            /**
             * Destroy all chart instances
             */
            destroyAllCharts() {
                Object.keys(globalState.charts).forEach(chartId => {
                    this.destroyChart(chartId);
                });
            },

            /**
             * Set application loading state
             */
            setLoading(isLoading) {
                globalState.isProcessing = isLoading;
                const loadingElement = document.getElementById('loading');
                loadingElement.style.display = isLoading ? 'flex' : 'none';
            },

            /**
             * Format a number with thousands separators and fixed decimals
             */
            formatNumber(value, decimals = 2) {
                if (value === null || value === undefined || isNaN(value)) {
                    return '-';
                }

                return value.toFixed(decimals);
            },

            /**
             * Format number for CSV export using detected decimal separator
             */
            formatNumberForCSV(value, decimals = 4) {
                if (value === null || value === undefined || isNaN(value)) {
                    return '';
                }

                const formatted = value.toFixed(decimals);

                if (globalState.decimalSeparator === ',') {
                    return formatted.replace('.', ',');
                }
                return formatted;
            },

            /**
             * Export a table to CSV format
             */
            exportTableToCSV(tableId, filename) {
                const table = document.getElementById(tableId);
                if (!table) return;

                let csv = '\uFEFF'; // UTF-8 BOM for Excel

                // Get headers
                const headers = Array.from(table.querySelectorAll('thead th'))
                    .map(th => th.textContent.trim());
                csv += headers.join(globalState.csvDelimiter) + '\n';

                // Get rows
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const cells = Array.from(row.querySelectorAll('td'))
                        .map(cell => {
                            let content = cell.textContent.trim();
                            if (content.includes(globalState.csvDelimiter) || content.includes('"')) {
                                content = '"' + content.replace(/"/g, '""') + '"';
                            }
                            return content;
                        });
                    csv += cells.join(globalState.csvDelimiter) + '\n';
                });

                // Create download with timestamp
                const timestamp = this.getTimestamp();
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);

                link.setAttribute('href', url);
                link.setAttribute('download', `sra-${timestamp}-${filename}.csv`);
                link.style.visibility = 'hidden';

                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                URL.revokeObjectURL(url);
            },

            /**
             * Get timestamp for file naming
             */
            getTimestamp() {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');

                return `${year}${month}${day}-${hours}${minutes}${seconds}`;
            },

            /**
             * Generate a text representation of a group definition
             */
            groupDefinitionToText(group) {
                let text = `[${group.name}]\n`;

                // Export color (both custom and preset)
                if (group.customColor) {
                    text += `Color: ${group.customColor}\n`;
                } else if (group.colorIndex !== undefined) {
                    text += `ColorIndex: ${group.colorIndex}\n`;
                }

                // Export inclusion state
                text += `IncludeInAnalysis: ${group.includeInAnalysis !== false}\n`;

                if (group.customColor) {
    text += `CustomColor: ${group.customColor}\n`;
}
if (group.colorIndex !== undefined) {
    text += `ColorIndex: ${group.colorIndex}\n`;
}

                // Export individual conditions
                if (group.conditions && group.conditions.length > 0) {
                    group.conditions.forEach((condition, index) => {
                        let conditionText = `Condition_${index + 1}: `;

                        // Always quote parameter names for consistency
                        conditionText += `"${condition.parameter}" `;
                        conditionText += `${condition.operator} `;

                        // Quote string values if they contain spaces
                        if (typeof condition.value === 'string' && condition.value.includes(' ')) {
                            conditionText += `"${condition.value}"`;
                        } else {
                            conditionText += condition.value;
                        }

                        text += conditionText + '\n';
                    });
                }

                // Export constellation references
                if (group.constellations && group.constellations.length > 0) {
                    group.constellations.forEach((constellation, index) => {
                        text += `Constellation_${index + 1}: ${constellation.name}`;
                        if (constellation.negated) {
                            text += ' [NOT]';
                        }
                        text += '\n';
                    });
                }

                // Export not-in-previous flag
                if (group.notInPrevious !== undefined) {
                    text += `NotInPrevious: ${group.notInPrevious}\n`;
                }

                text += '\n';
                return text;
            },

            /**
             * Generate text representation of a parameter constellation
             */
            constellationToText(constellation) {
                let text = `[CONSTELLATION:${constellation.name}]\n`;

                constellation.conditions.forEach((condition, index) => {
                    let conditionText = `Condition_${index + 1}: `;
                    conditionText += `"${condition.parameter}" ${condition.operator} `;

                    if (typeof condition.value === 'string' && condition.value.includes(' ')) {
                        conditionText += `"${condition.value}"`;
                    } else {
                        conditionText += condition.value;
                    }

                    text += conditionText + '\n';
                });

                text += '\n';
                return text;
            },

            /**
             * Calculate relative epsilon for floating-point comparison
             */
            calculateEpsilon(a, b) {
                const magnitude = Math.max(Math.abs(a), Math.abs(b), 1);
                return magnitude * Number.EPSILON * 100;
            },

            /**
             * Get scale type name and badge class
             */
            getScaleInfo(scaleCode) {
                const scale = scaleTypes[scaleCode];
                if (!scale) return { name: 'Unknown', class: '' };

                const classMap = {
                    'k': 'nominal',
                    'o': 'ordinal',
                    'i': 'interval',
                    'r': 'ratio'
                };

                return {
                    name: scale.name,
                    class: classMap[scaleCode] || ''
                };
            }
        };

        /**
 * Unified Statistical Library Wrapper
 */
        class StatisticalLibrary {
            constructor() {
                this.jstat = jStat;
                this.ss = ss; // simple-statistics
                this.testDefinitions = {
                    'ttest': {
                        name: 'Student t-Test',
                        indication: 'Compares means of two groups with normally distributed data and equal variances',
                        requirements: ['normal_distribution', 'equal_variances'],
                        groups: { min: 2, max: 2 },
                        scaleTypes: ['i', 'r'],
                        category: 'parametric'
                    },
                    'welch': {
                        name: 'Welch t-Test',
                        indication: 'Compares means of two groups with normally distributed data and unequal variances',
                        requirements: ['normal_distribution'],
                        groups: { min: 2, max: 2 },
                        scaleTypes: ['i', 'r'],
                        category: 'parametric'
                    },
                    'anova': {
                        name: 'Einfaktorielle ANOVA',
                        indication: 'Compares means of three or more groups with normally distributed data',
                        requirements: ['normal_distribution', 'equal_variances'],
                        groups: { min: 2, max: Infinity },
                        scaleTypes: ['i', 'r'],
                        category: 'parametric'
                    },
                    'mann-whitney': {
                        name: 'Mann-Whitney U Test',
                        indication: 'Compares distributions of two independent groups (rank-based, no normal distribution required)',
                        requirements: [],
                        groups: { min: 2, max: 2 },
                        scaleTypes: ['o', 'i', 'r'],
                        category: 'nonparametric'
                    },
                    'kruskal-wallis': {
                        name: 'Kruskal-Wallis Test',
                        indication: 'Compares distributions of three or more independent groups (rank-based)',
                        requirements: [],
                        groups: { min: 2, max: Infinity },
                        scaleTypes: ['o', 'i', 'r'],
                        category: 'nonparametric'
                    },
                    'chi-square': {
                        name: 'Chi-Quadrat Test',
                        indication: 'Tests independence between categorical variable and group membership',
                        requirements: ['expected_frequency_5'],
                        groups: { min: 1, max: Infinity },
                        scaleTypes: ['k'],
                        category: 'categorical'
                    },
                    'fisher': {
                        name: 'Fisher Exakter Test',
                        indication: 'Exact test for 2×2 tables, especially for small samples',
                        requirements: [],
                        groups: { min: 2, max: 2 },
                        scaleTypes: ['k'],
                        category: 'categorical'
                    }
                };
            }

            // Deskriptive Statistiken
            calculate(values) {
                const validValues = values.filter(v => !isNaN(v) && isFinite(v));

                if (validValues.length === 0) {
                    return {
                        count: 0, min: null, max: null, mean: null, median: null,
                        stdDev: null, variance: null, q1: null, q3: null, iqr: null,
                        range: null, sum: null, cv: null
                    };
                }

                try {
                    const mean = this.ss.mean(validValues);
                    const stdDev = validValues.length > 1 ? this.ss.standardDeviation(validValues) : 0;
                    const variance = validValues.length > 1 ? this.ss.variance(validValues) : 0;

                    return {
                        count: validValues.length,
                        min: this.ss.min(validValues),
                        max: this.ss.max(validValues),
                        mean: mean,
                        median: this.ss.median(validValues),
                        stdDev: stdDev,
                        variance: variance,
                        q1: this.ss.quantile(validValues, 0.25),
                        q3: this.ss.quantile(validValues, 0.75),
                        iqr: this.ss.interquartileRange(validValues),
                        range: this.ss.max(validValues) - this.ss.min(validValues),
                        sum: this.ss.sum(validValues),
                        cv: this.calculateCV(validValues, mean, stdDev)
                    };
                } catch (error) {
                    console.warn('Error in descriptive statistics:', error);
                    return {
                        count: validValues.length, min: null, max: null, mean: null, median: null,
                        stdDev: null, variance: null, q1: null, q3: null, iqr: null,
                        range: null, sum: null, cv: null
                    };
                }
            }

            calculateCV(values, mean, stdDev) {
                if (values.length === 0 || mean <= 0) return null;
                const allPositive = values.every(v => v > 0);
                if (!allPositive) return null;
                return (stdDev / mean) * 100;
            }

            // Normalitätstest
            shapiroWilkTest(data) {
    const validData = data.filter(v => !isNaN(v) && isFinite(v));
    const n = validData.length;
    
    if (n < 3) {
        return {
            W: null,
            pValue: null,
            error: 'Shapiro-Wilk test requires at least 3 observations'
        };
    }

    // For large samples, use simplified normality test
    if (n > 50) {
        try {
            const sorted = [...validData].sort((a, b) => a - b);
            const mean = this.jstat.mean(sorted);
            const std = this.jstat.stdev(sorted, true);
            
            // Calculate skewness manually
            let skewSum = 0;
            for (let i = 0; i < n; i++) {
                skewSum += Math.pow((sorted[i] - mean) / std, 3);
            }
            const skew = skewSum / n;
            
            // Calculate kurtosis manually
            let kurtSum = 0;
            for (let i = 0; i < n; i++) {
                kurtSum += Math.pow((sorted[i] - mean) / std, 4);
            }
            const kurt = kurtSum / n;
            
            // Jarque-Bera statistic
            const jb = (n / 6) * (Math.pow(skew, 2) + (1/4) * Math.pow(kurt - 3, 2));
            const pValue = 1 - this.jstat.chisquare.cdf(jb, 2);
            
            return {
                W: null,
                pValue: pValue,
                n: n,
                normal: pValue > 0.05,
                test: 'Jarque-Bera',
                warning: 'Sample size > 50, using Jarque-Bera test instead of Shapiro-Wilk'
            };
        } catch (error) {
            console.warn('Jarque-Bera test failed:', error);
            // Fallback to simple test
            return {
                W: null,
                pValue: 0.5,
                n: n,
                normal: true,
                test: 'Simplified',
                warning: 'Using simplified normality assumption for large sample'
            };
        }
    }

    try {
        // Original Shapiro-Wilk implementation for n <= 50
        const sorted = [...validData].sort((a, b) => a - b);
        const mean = this.jstat.mean(sorted);
        
        // Use jStat for better W statistic calculation
        let sumSquares = 0;
        for (let i = 0; i < n; i++) {
            sumSquares += Math.pow(sorted[i] - mean, 2);
        }
        
        // Calculate W using jStat's statistical functions
        let a_sum = 0;
        const k = Math.floor(n / 2);
        
        for (let i = 0; i < k; i++) {
            // Use jStat normal distribution for coefficients
            const ai = this.jstat.normal.inv((i + 1 - 0.375) / (n + 0.25), 0, 1);
            a_sum += ai * (sorted[n - 1 - i] - sorted[i]);
        }
        
        const W = Math.pow(a_sum, 2) / sumSquares;
        
        // Approximate p-value using jStat
        const logW = Math.log(W);
        const logN = Math.log(n);
        const z = (logW - (-1.2725 + 1.0521 * logN)) / (0.26758 + 0.0018 * logN);
        const pValue = 1 - this.jstat.normal.cdf(z, 0, 1);

        return {
            W: W,
            pValue: Math.max(0.001, Math.min(0.999, pValue)),
            n: n,
            normal: pValue > 0.05,
            test: 'Shapiro-Wilk'
        };
    } catch (error) {
        return {
            W: null,
            pValue: null,
            error: 'Shapiro-Wilk calculation failed'
        };
    }
}

            // F-Test
            fTest(group1, group2) {
                const stats1 = this.calculate(group1);
                const stats2 = this.calculate(group2);

                if (stats1.count < 2 || stats2.count < 2) {
                    return {
                        F: null,
                        pValue: null,
                        error: 'F-test requires at least 2 observations in each group'
                    };
                }

                try {
                    const F = stats1.variance > stats2.variance ?
                        stats1.variance / stats2.variance :
                        stats2.variance / stats1.variance;

                    const df1 = stats1.variance > stats2.variance ? stats1.count - 1 : stats2.count - 1;
                    const df2 = stats1.variance > stats2.variance ? stats2.count - 1 : stats1.count - 1;

                    const pValue = 2 * Math.min(
                        this.jstat.centralF.cdf(F, df1, df2),
                        1 - this.jstat.centralF.cdf(F, df1, df2)
                    );

                    return {
                        F: F,
                        pValue: pValue,
                        df1: df1,
                        df2: df2,
                        equalVariances: pValue > 0.05,
                        variance1: stats1.variance,
                        variance2: stats2.variance
                    };
                } catch (error) {
                    return {
                        F: null,
                        pValue: null,
                        error: 'F-test calculation failed'
                    };
                }
            }

            // t-Test
            tTest(group1, group2, options = {}) {
    const alpha = options.alpha || 0.05;
    const direction = options.direction || 'two-sided';

    if (group1.length < 2 || group2.length < 2) {
        return null;
    }

    try {
        const result = this.jstat.ttest(group1, group2, 2, 1);
        const stats1 = this.calculate(group1);
        const stats2 = this.calculate(group2);

        const pooledVariance = ((stats1.count - 1) * stats1.variance + (stats2.count - 1) * stats2.variance) / (stats1.count + stats2.count - 2);
        const effectSize = Math.abs(stats1.mean - stats2.mean) / Math.sqrt(pooledVariance);

        const se = Math.sqrt(pooledVariance * (1 / stats1.count + 1 / stats2.count));
        const meanDiff = stats1.mean - stats2.mean;
        const df = stats1.count + stats2.count - 2;
        const criticalT = this.jstat.studentt.inv(1 - alpha / 2, df);
        const ciLower = meanDiff - criticalT * se;
        const ciUpper = meanDiff + criticalT * se;
        
        // Calculate power using jStat
        const ncp = effectSize * Math.sqrt(stats1.count * stats2.count / (stats1.count + stats2.count));
        const criticalValue = this.jstat.studentt.inv(1 - alpha / 2, df);
        const power = 1 - this.jstat.normal.cdf(criticalValue - ncp, 0, 1) + this.jstat.normal.cdf(-criticalValue - ncp, 0, 1);

        return {
            test: 't-Test',
            statistic: result[0],
            pValue: result[1],
            df: df,
            significant: result[1] < alpha,
            alpha: alpha,
            direction: direction,
            group1Stats: stats1,
            group2Stats: stats2,
            effectSize: effectSize,
            meanDifference: meanDiff,
            confidenceInterval: [ciLower, ciUpper],
            confidenceLevel: 1 - alpha,
            power: power
        };
    } catch (error) {
        return null;
    }
}

            // Welch t-Test
            welchTTest(group1, group2, options = {}) {
                const alpha = options.alpha || 0.05;
                const direction = options.direction || 'two-sided';

                if (group1.length < 2 || group2.length < 2) {
                    return null;
                }

                try {
                    const result = this.jstat.ttest(group1, group2, 2, 0);
                    const stats1 = this.calculate(group1);
                    const stats2 = this.calculate(group2);

                    const se = Math.sqrt(stats1.variance / stats1.count + stats2.variance / stats2.count);
                    const df = Math.pow(se, 4) / (Math.pow(stats1.variance / stats1.count, 2) / (stats1.count - 1) + Math.pow(stats2.variance / stats2.count, 2) / (stats2.count - 1));

                    const effectSize = Math.abs(stats1.mean - stats2.mean) / Math.sqrt((stats1.variance + stats2.variance) / 2);
                    const meanDiff = stats1.mean - stats2.mean;
                    const criticalT = this.jstat.studentt.inv(1 - alpha / 2, df);
                    const ciLower = meanDiff - criticalT * se;
                    const ciUpper = meanDiff + criticalT * se;

                    // Calculate power using Welch-Satterthwaite approximation
const ncp = effectSize * Math.sqrt(stats1.count * stats2.count / (stats1.count + stats2.count));
const criticalValue = this.jstat.studentt.inv(1 - alpha / 2, df);
const power = 1 - this.jstat.normal.cdf(criticalValue - ncp, 0, 1) + this.jstat.normal.cdf(-criticalValue - ncp, 0, 1);

                    return {
                        test: "Welch's t-Test",
                        statistic: result[0],
                        pValue: result[1],
                        df: df,
                        significant: result[1] < alpha,
                        alpha: alpha,
                        direction: direction,
                        group1Stats: stats1,
                        group2Stats: stats2,
                        effectSize: effectSize,
                        meanDifference: meanDiff,
                        confidenceInterval: [ciLower, ciUpper],
                        confidenceLevel: 1 - alpha,
                        power: power
                    };
                } catch (error) {
                    return null;
                }
            }

            // ANOVA
            anova(groups, options = {}) {
    const validGroups = groups.filter(group => group.length > 0);
    const alpha = options.alpha || 0.05;

    if (validGroups.length < 2) return null;

    try {
        // Calculate ANOVA manually using jStat functions
        const k = validGroups.length;
        const N = validGroups.reduce((sum, group) => sum + group.length, 0);
        
        // Calculate grand mean
        const allValues = validGroups.flat();
        const grandMean = this.jstat.mean(allValues);
        
        // Calculate group means
        const groupMeans = validGroups.map(group => this.jstat.mean(group));
        const groupSizes = validGroups.map(group => group.length);
        
        // Calculate SSB (between groups)
        let ssb = 0;
        for (let i = 0; i < k; i++) {
            ssb += groupSizes[i] * Math.pow(groupMeans[i] - grandMean, 2);
        }
        
        // Calculate SSW (within groups)
        let ssw = 0;
        for (let i = 0; i < k; i++) {
            for (let j = 0; j < validGroups[i].length; j++) {
                ssw += Math.pow(validGroups[i][j] - groupMeans[i], 2);
            }
        }
        
        // Calculate degrees of freedom
        const dfb = k - 1;
        const dfw = N - k;
        
        // Calculate mean squares
        const msb = ssb / dfb;
        const msw = ssw / dfw;
        
        // Calculate F statistic
        const f = msb / msw;
        
        // Calculate p-value using F distribution
        const pValue = 1 - this.jstat.centralF.cdf(f, dfb, dfw);
        
        // Calculate effect size
        const etaSquared = ssb / (ssb + ssw);
        const effectSizeF = Math.sqrt(etaSquared / (1 - etaSquared));
        
        // Calculate power
        const lambda = effectSizeF * effectSizeF * N;
        const fcrit = this.jstat.centralF.inv(1 - alpha, dfb, dfw);
        const power = 1 - this.jstat.centralF.cdf(fcrit, dfb, dfw, lambda);
        
        // Group statistics
        const groupStats = validGroups.map((group, i) => ({
            n: groupSizes[i],
            mean: groupMeans[i],
            variance: this.jstat.variance(group, true),
            stdDev: this.jstat.stdev(group, true)
        }));
        
        // Perform post-hoc tests if significant and more than 2 groups
        let postHocResults = null;
        if (pValue < alpha && validGroups.length > 2) {
            postHocResults = this.tukeyHSD(validGroups, msw, alpha);
        }

        return {
            test: 'ANOVA',
            statistic: f,
            pValue: pValue,
            dfBetween: dfb,
            dfWithin: dfw,
            significant: pValue < alpha,
            alpha: alpha,
            ssb: ssb,
            ssw: ssw,
            msb: msb,
            msw: msw,
            etaSquared: etaSquared,
            effectSizeF: effectSizeF,
            groupStats: groupStats,
            power: power,
            postHoc: postHocResults,
            f: f,
            p: pValue
        };
    } catch (error) {
        return {
            error: 'ANOVA calculation failed: ' + error.message
        };
    }
}

// Add Tukey HSD post-hoc test
tukeyHSD(groups, msw, alpha = 0.05) {
    const k = groups.length;
    const comparisons = [];
    
    for (let i = 0; i < k - 1; i++) {
        for (let j = i + 1; j < k; j++) {
            const stats1 = this.calculate(groups[i]);
            const stats2 = this.calculate(groups[j]);
            
            const meanDiff = Math.abs(stats1.mean - stats2.mean);
            const se = Math.sqrt(msw * (1/stats1.count + 1/stats2.count));
            const q = meanDiff / se;
            
            // Get critical q value (using approximation)
            const df = groups.reduce((sum, g) => sum + g.length, 0) - k;
            const qCrit = this.getStudentizedRangeCritical(k, df, alpha);
            
            comparisons.push({
                group1: i + 1,
                group2: j + 1,
                meanDiff: meanDiff,
                se: se,
                q: q,
                qCritical: qCrit,
                significant: q > qCrit,
                lowerCI: meanDiff - qCrit * se,
                upperCI: meanDiff + qCrit * se
            });
        }
    }
    
    return {
        method: 'Tukey HSD',
        comparisons: comparisons,
        alpha: alpha
    };
}

// Approximation for studentized range critical values
getStudentizedRangeCritical(k, df, alpha) {
    // Simplified approximation using t-distribution
    // For exact values, would need lookup table
    const t = this.jstat.studentt.inv(1 - alpha / (k * (k - 1)), df);
    return t * Math.sqrt(2);
}

            // Mann-Whitney U Test
            mannWhitneyU(group1, group2, options = {}) {
    const validGroup1 = group1.filter(v => !isNaN(v) && isFinite(v));
    const validGroup2 = group2.filter(v => !isNaN(v) && isFinite(v));
    const alpha = options.alpha || 0.05;
    const direction = options.direction || 'two-sided';

    if (validGroup1.length < 1 || validGroup2.length < 1) {
        return {
            error: 'Mann-Whitney U test requires at least 1 observation in each group'
        };
    }

    try {
        // Combine and rank data
        const combined = [];
        validGroup1.forEach(val => combined.push({ value: val, group: 1 }));
        validGroup2.forEach(val => combined.push({ value: val, group: 2 }));

        combined.sort((a, b) => a.value - b.value);

        // Assign ranks with tie handling
        const ranks = new Array(combined.length);
        let i = 0;
        let tieCorrection = 0;

        while (i < combined.length) {
            let j = i;
            let sumRanks = 0;
            let tieCount = 0;

            while (j < combined.length && combined[j].value === combined[i].value) {
                sumRanks += j + 1;
                j++;
                tieCount++;
            }

            const avgRank = sumRanks / tieCount;
            for (let k = i; k < j; k++) {
                ranks[k] = avgRank;
            }
            
            if (tieCount > 1) {
                tieCorrection += (Math.pow(tieCount, 3) - tieCount);
            }

            i = j;
        }

        let R1 = 0, R2 = 0;
        for (let i = 0; i < combined.length; i++) {
            if (combined[i].group === 1) {
                R1 += ranks[i];
            } else {
                R2 += ranks[i];
            }
        }

        const n1 = validGroup1.length;
        const n2 = validGroup2.length;
        const U1 = n1 * n2 + n1 * (n1 + 1) / 2 - R1;
        const U2 = n1 * n2 + n2 * (n2 + 1) / 2 - R2;
        const U = Math.min(U1, U2);

        const meanU = n1 * n2 / 2;
        const N = n1 + n2;
        
        // Standard deviation with tie correction
        let sdU;
        if (tieCorrection > 0) {
            sdU = Math.sqrt((n1 * n2 / 12) * ((N + 1) - tieCorrection / (N * (N - 1))));
        } else {
            sdU = Math.sqrt(n1 * n2 * (N + 1) / 12);
        }

        let pValue;
        
        // Use exact distribution for small samples via jStat
        if (n1 <= 20 && n2 <= 20 && n1 * n2 <= 100) {
            // For small samples, use normal approximation with continuity correction
            const z = (Math.abs(U - meanU) - 0.5) / sdU;
            pValue = 2 * (1 - this.jstat.normal.cdf(Math.abs(z), 0, 1));
        } else {
            // For larger samples, use normal approximation
            const z = (U - meanU) / sdU;
            pValue = 2 * (1 - this.jstat.normal.cdf(Math.abs(z), 0, 1));
        }

        // Effect size (rank biserial correlation)
        const effectSize = 1 - (2 * U) / (n1 * n2);

        return {
            test: 'Mann-Whitney U',
            U: U,
            U1: U1,
            U2: U2,
            pValue: pValue,
            significant: pValue < alpha,
            alpha: alpha,
            n1: n1,
            n2: n2,
            rankSum1: R1,
            rankSum2: R2,
            effectSize: Math.abs(effectSize),
            direction: direction,
            tieCorrection: tieCorrection > 0,
            meanU: meanU,
            sdU: sdU
        };
    } catch (error) {
        return {
            error: 'Mann-Whitney U test calculation failed'
        };
    }
}

            // Kruskal-Wallis Test
            kruskalWallis(groups, options = {}) {
                const alpha = options.alpha || 0.05;
                const validGroups = groups.map(group => group.filter(v => !isNaN(v) && isFinite(v))).filter(group => group.length > 0);

                if (validGroups.length < 2) {
                    return {
                        error: 'Kruskal-Wallis test requires at least 2 groups'
                    };
                }

                try {
                    const combined = [];
                    validGroups.forEach((group, groupIndex) => {
                        group.forEach(val => {
                            combined.push({ value: val, group: groupIndex });
                        });
                    });

                    const N = combined.length;
                    combined.sort((a, b) => a.value - b.value);

                    const ranks = new Array(N);
                    let i = 0;

                    while (i < N) {
                        let j = i;
                        let sumRanks = 0;

                        while (j < N && combined[j].value === combined[i].value) {
                            sumRanks += j + 1;
                            j++;
                        }

                        const avgRank = sumRanks / (j - i);
                        for (let k = i; k < j; k++) {
                            ranks[k] = avgRank;
                        }

                        i = j;
                    }

                    const groupRankSums = new Array(validGroups.length).fill(0);
                    const groupSizes = validGroups.map(g => g.length);

                    for (let i = 0; i < N; i++) {
                        groupRankSums[combined[i].group] += ranks[i];
                    }

                    // Calculate H statistic
let H = 0;
i = 0;
for (i = 0; i < validGroups.length; i++) {
    H += (groupRankSums[i] * groupRankSums[i]) / groupSizes[i];
}
H = (12 / (N * (N + 1))) * H - 3 * (N + 1);

// Calculate tie correction
let tieCorrection = 0;
i = 0;
while (i < N) {
    let j = i;
    while (j < N && combined[j].value === combined[i].value) {
        j++;
    }
    if (j - i > 1) {
        tieCorrection += (j - i) * ((j - i) * (j - i) - 1);
    }
    i = j;
}

// Apply tie correction if needed
if (tieCorrection > 0) {
    const correction = 1 - tieCorrection / (N * (N * N - 1));
    H = H / correction;
}

                    const df = validGroups.length - 1;
                    const pValue = 1 - this.jstat.chisquare.cdf(H, df);
                    const etaSquared = (H - df) / (N - df);

                    // Perform post-hoc tests if significant and more than 2 groups
let postHocResults = null;
if (pValue < alpha && validGroups.length > 2) {
    postHocResults = this.dunnTest(validGroups, H, N, alpha);
}

                    return {
                        test: 'Kruskal-Wallis',
                        H: H,
                        pValue: pValue,
                        df: df,
                        significant: pValue < alpha,
                        alpha: alpha,
                        groupSizes: groupSizes,
                        groupRankSums: groupRankSums,
                        etaSquared: etaSquared > 0 ? etaSquared : 0,
                        N: N,
                        tieCorrection: false,
                        postHoc: postHocResults
                    };
                } catch (error) {
                    return {
                        error: 'Kruskal-Wallis test calculation failed'
                    };
                }
            }

            // Dunn's post-hoc test for Kruskal-Wallis
dunnTest(groups, H, N, alpha = 0.05) {
    const k = groups.length;
    const comparisons = [];
    
    // Calculate average ranks for each group
    const combined = [];
    groups.forEach((group, groupIndex) => {
        group.forEach(val => {
            combined.push({ value: val, group: groupIndex });
        });
    });
    
    combined.sort((a, b) => a.value - b.value);
    
    // Assign ranks
    const ranks = new Array(combined.length);
    let i = 0;
    while (i < combined.length) {
        let j = i;
        let sumRanks = 0;
        while (j < combined.length && combined[j].value === combined[i].value) {
            sumRanks += j + 1;
            j++;
        }
        const avgRank = sumRanks / (j - i);
        for (let k = i; k < j; k++) {
            ranks[k] = avgRank;
        }
        i = j;
    }
    
    // Calculate mean ranks for each group
    const meanRanks = new Array(k).fill(0);
    const groupSizes = groups.map(g => g.length);
    
    combined.forEach((item, index) => {
        meanRanks[item.group] += ranks[index];
    });
    
    meanRanks.forEach((sum, i) => {
        meanRanks[i] = sum / groupSizes[i];
    });
    
    // Perform pairwise comparisons
    for (let i = 0; i < k - 1; i++) {
        for (let j = i + 1; j < k; j++) {
            const rankDiff = Math.abs(meanRanks[i] - meanRanks[j]);
            const se = Math.sqrt((N * (N + 1) / 12) * (1/groupSizes[i] + 1/groupSizes[j]));
            const z = rankDiff / se;
            
            // Two-tailed p-value
            const pValue = 2 * (1 - this.jstat.normal.cdf(Math.abs(z), 0, 1));
            
            // Bonferroni correction
            const adjustedAlpha = alpha / (k * (k - 1) / 2);
            
            comparisons.push({
                group1: i + 1,
                group2: j + 1,
                meanRank1: meanRanks[i],
                meanRank2: meanRanks[j],
                rankDiff: rankDiff,
                z: z,
                pValue: pValue,
                adjustedPValue: Math.min(1, pValue * (k * (k - 1) / 2)),
                significant: pValue < adjustedAlpha
            });
        }
    }
    
    return {
        method: "Dunn's Test (Bonferroni)",
        comparisons: comparisons,
        alpha: alpha,
        adjustedAlpha: alpha / (k * (k - 1) / 2)
    };
}

            // Chi-Square Test
            chiSquareTest(paramName, groupData, options = {}) {
                const alpha = options.alpha || 0.05;
                const categories = [...new Set(globalState.rawData
                    .map(row => row[paramName])
                    .filter(val => val !== null && val !== undefined && val !== ''))];
                const groupIds = Object.keys(groupData);

                if (categories.length < 2 || groupIds.length < 1) {
                    return {
                        error: "Chi-Square test requires at least 2 categories and 1 group"
                    };
                }

                try {
                    const observed = [];
                    const rowTotals = [];
                    const colTotals = Array(groupIds.length).fill(0);
                    let totalCount = 0;

                    categories.forEach(category => {
                        const row = [];
                        let rowTotal = 0;

                        groupIds.forEach((groupId, colIndex) => {
                            const count = groupData[groupId].filter(record =>
                                String(record[paramName]) === String(category)
                            ).length;

                            row.push(count);
                            rowTotal += count;
                            colTotals[colIndex] += count;
                            totalCount += count;
                        });

                        observed.push(row);
                        rowTotals.push(rowTotal);
                    });

                    const expected = [];
                    for (let i = 0; i < categories.length; i++) {
                        const expectRow = [];
                        for (let j = 0; j < groupIds.length; j++) {
                            expectRow.push((rowTotals[i] * colTotals[j]) / totalCount);
                        }
                        expected.push(expectRow);
                    }

                    let chiSquare = 0;
                    let hasLowExpected = false;
                    for (let i = 0; i < observed.length; i++) {
                        for (let j = 0; j < observed[i].length; j++) {
                            const o = observed[i][j];
                            const e = expected[i][j];
                            if (e < 5) hasLowExpected = true;
                            chiSquare += Math.pow(o - e, 2) / Math.max(e, 0.0001);
                        }
                    }

                    const df = (categories.length - 1) * (groupIds.length - 1);
                    const pValue = 1 - this.jstat.chisquare.cdf(chiSquare, df);
                    const minDim = Math.min(categories.length - 1, groupIds.length - 1);
                    const cramersV = Math.sqrt(chiSquare / (totalCount * minDim));

                    // Perform post-hoc pairwise comparisons if significant and more than 2 groups
let postHocResults = null;
if (pValue < alpha && groupIds.length > 2) {
    const pairwiseComparisons = [];
    
    for (let i = 0; i < groupIds.length - 1; i++) {
        for (let j = i + 1; j < groupIds.length; j++) {
            // Create 2x2 table for this pair
            const pairwiseTable = [];
            const pairwiseRowTotals = [];
            const pairwiseColTotals = [0, 0];
            let pairwiseTotalCount = 0;
            
            categories.forEach(category => {
                const row = [];
                let rowTotal = 0;
                
                [i, j].forEach((groupIndex, colIndex) => {
                    const count = groupData[groupIds[groupIndex]].filter(record =>
                        String(record[paramName]) === String(category)
                    ).length;
                    
                    row.push(count);
                    rowTotal += count;
                    pairwiseColTotals[colIndex] += count;
                    pairwiseTotalCount += count;
                });
                
                pairwiseTable.push(row);
                pairwiseRowTotals.push(rowTotal);
            });
            
            // Calculate chi-square for this pair
            let pairwiseChiSquare = 0;
            for (let row = 0; row < categories.length; row++) {
                for (let col = 0; col < 2; col++) {
                    const o = pairwiseTable[row][col];
                    const e = (pairwiseRowTotals[row] * pairwiseColTotals[col]) / pairwiseTotalCount;
                    if (e > 0) {
                        pairwiseChiSquare += Math.pow(o - e, 2) / e;
                    }
                }
            }
            
            const pairwiseDf = (categories.length - 1);
            const pairwisePValue = 1 - this.jstat.chisquare.cdf(pairwiseChiSquare, pairwiseDf);
            
            // Bonferroni correction
            const adjustedAlpha = alpha / (groupIds.length * (groupIds.length - 1) / 2);
            
            pairwiseComparisons.push({
                group1: globalState.currentGroups[groupIds[i]].name,
                group2: globalState.currentGroups[groupIds[j]].name,
                chiSquare: pairwiseChiSquare,
                df: pairwiseDf,
                pValue: pairwisePValue,
                adjustedPValue: Math.min(1, pairwisePValue * (groupIds.length * (groupIds.length - 1) / 2)),
                significant: pairwisePValue < adjustedAlpha
            });
        }
    }
    
    postHocResults = {
        method: "Pairwise Chi-Square (Bonferroni)",
        comparisons: pairwiseComparisons,
        alpha: alpha,
        adjustedAlpha: alpha / (groupIds.length * (groupIds.length - 1) / 2)
    };
}

                    // Calculate power for chi-square test
const ncp = totalCount * cramersV * cramersV * minDim; // non-centrality parameter
const criticalValue = this.jstat.chisquare.inv(1 - alpha, df);
const power = 1 - this.jstat.chisquare.cdf(criticalValue - ncp, df);

                    return {
                        test: 'Chi-Square',
                        statistic: chiSquare,
                        pValue: pValue,
                        df: df,
                        significant: pValue < alpha,
                        alpha: alpha,
                        cramersV: cramersV,
                        observed: observed,
                        expected: expected,
                        categories: categories,
                        groups: groupIds.map(id => globalState.currentGroups[id].name),
                        warning: hasLowExpected ? 'Some expected frequencies are less than 5, consider using Fisher\'s exact test.' : null,
                        power: power,
                        postHoc: postHocResults
                    };
                } catch (error) {
                    return {
                        error: 'Chi-Square test calculation failed'
                    };
                }
            }

            // Fisher's Exact Test
            fisherExactTest(table, options = {}) {
                const alpha = options.alpha || 0.05;

                if (table.length !== 2 || table[0].length !== 2 || table[1].length !== 2) {
                    return {
                        error: "Fisher's exact test requires a 2x2 contingency table"
                    };
                }

                const a = table[0][0];
                const b = table[0][1];
                const c = table[1][0];
                const d = table[1][1];

                if (a < 0 || b < 0 || c < 0 || d < 0) {
                    return {
                        error: "Table values must be non-negative"
                    };
                }

                const n = a + b + c + d;
                if (n > 200) {
                    return {
                        error: "Fisher's exact test is not recommended for n > 200. Use Chi-square test instead."
                    };
                }

                try {
                    const pObserved = this.hypergeometricProbability(a, b, c, d);
                    let pValue = 0;
                    const rowSum1 = a + b;
                    const colSum1 = a + c;

                    for (let i = 0; i <= Math.min(rowSum1, colSum1); i++) {
                        const prob = this.hypergeometricProbability(
                            i,
                            rowSum1 - i,
                            colSum1 - i,
                            n - rowSum1 - colSum1 + i
                        );

                        if (prob <= pObserved + 1e-10) {
                            pValue += prob;
                        }
                    }

                    const oddsRatio = (a * d) / (b * c);

                    return {
                        test: "Fisher's Exact Test",
                        pValue: pValue,
                        significant: pValue < alpha,
                        alpha: alpha,
                        oddsRatio: oddsRatio,
                        table: [[a, b], [c, d]]
                    };
                } catch (error) {
                    return {
                        error: "Fisher's exact test calculation failed"
                    };
                }
            }

            hypergeometricProbability(a, b, c, d) {
                const n = a + b + c + d;
                const logProb =
                    this.logFactorial(a + b) +
                    this.logFactorial(c + d) +
                    this.logFactorial(a + c) +
                    this.logFactorial(b + d) -
                    this.logFactorial(n) -
                    this.logFactorial(a) -
                    this.logFactorial(b) -
                    this.logFactorial(c) -
                    this.logFactorial(d);
                return Math.exp(logProb);
            }

            logFactorial(n) {
                if (n <= 1) return 0;
                let sum = 0;
                for (let i = 2; i <= n; i++) {
                    sum += Math.log(i);
                }
                return sum;
            }

            // Korrelationen
            pearsonCorrelation(x, y, options = {}) {
                const alpha = options.alpha || 0.05;
                const pairs = [];
                for (let i = 0; i < Math.min(x.length, y.length); i++) {
                    if (!isNaN(x[i]) && !isNaN(y[i]) && isFinite(x[i]) && isFinite(y[i])) {
                        pairs.push({ x: x[i], y: y[i] });
                    }
                }

                if (pairs.length < 3) {
                    return {
                        error: 'Pearson correlation requires at least 3 paired observations'
                    };
                }

                try {
                    const xVals = pairs.map(p => p.x);
                    const yVals = pairs.map(p => p.y);
                    const r = this.ss.sampleCorrelation(xVals, yVals);
                    const n = pairs.length;
                    const t = r * Math.sqrt((n - 2) / (1 - r * r));
                    const df = n - 2;
                    const pValue = 2 * (1 - this.jstat.studentt.cdf(Math.abs(t), df));

                    // Calculate power for correlation
const z = 0.5 * Math.log((1 + Math.abs(r)) / (1 - Math.abs(r))); // Fisher's z
const se = 1 / Math.sqrt(n - 3);
const ncp = z / se;
const criticalZ = this.jstat.normal.inv(1 - alpha / 2, 0, 1);
const power = 1 - this.jstat.normal.cdf(criticalZ - ncp, 0, 1) + this.jstat.normal.cdf(-criticalZ - ncp, 0, 1);

                    return {
                        test: 'Pearson Correlation',
                        r: r,
                        r2: r * r,
                        pValue: pValue,
                        significant: pValue < alpha,
                        alpha: alpha,
                        n: n,
                        interpretation: this.interpretCorrelation(r),
                        power: power
                    };
                } catch (error) {
                    return {
                        error: 'Pearson correlation calculation failed'
                    };
                }
            }

            spearmanCorrelation(x, y, options = {}) {
                const alpha = options.alpha || 0.05;
                const pairs = [];
                for (let i = 0; i < Math.min(x.length, y.length); i++) {
                    if (!isNaN(x[i]) && !isNaN(y[i]) && isFinite(x[i]) && isFinite(y[i])) {
                        pairs.push({ x: x[i], y: y[i] });
                    }
                }

                if (pairs.length < 3) {
                    return {
                        error: 'Spearman correlation requires at least 3 paired observations'
                    };
                }

                try {
                    const xVals = pairs.map(p => p.x);
                    const yVals = pairs.map(p => p.y);
                    const ranksX = this.ss.rank(xVals);
                    const ranksY = this.ss.rank(yVals);
                    const rho = this.ss.sampleCorrelation(ranksX, ranksY);
                    const n = pairs.length;
                    const t = rho * Math.sqrt((n - 2) / (1 - rho * rho));
                    const df = n - 2;
                    const pValue = 2 * (1 - this.jstat.studentt.cdf(Math.abs(t), df));

                    // Calculate power for correlation
const z = 0.5 * Math.log((1 + Math.abs(r)) / (1 - Math.abs(r))); // Fisher's z
const se = 1 / Math.sqrt(n - 3);
const ncp = z / se;
const criticalZ = this.jstat.normal.inv(1 - alpha / 2, 0, 1);
const power = 1 - this.jstat.normal.cdf(criticalZ - ncp, 0, 1) + this.jstat.normal.cdf(-criticalZ - ncp, 0, 1);

                    return {
                        test: 'Spearman Correlation',
                        rho: rho,
                        pValue: pValue,
                        significant: pValue < alpha,
                        alpha: alpha,
                        n: n,
                        interpretation: this.interpretCorrelation(rho),
                        power: power
                    };
                } catch (error) {
                    return {
                        error: 'Spearman correlation calculation failed'
                    };
                }
            }

            interpretCorrelation(r) {
                const absR = Math.abs(r);
                let strength;
                if (absR < 0.1) strength = 'negligible';
                else if (absR < 0.3) strength = 'weak';
                else if (absR < 0.5) strength = 'moderate';
                else if (absR < 0.7) strength = 'strong';
                else strength = 'very strong';
                const direction = r > 0 ? 'positive' : 'negative';
                return `${strength} ${direction} correlation`;
            }

            // Kolmogorov-Smirnov Test
kolmogorovSmirnovTest(data) {
    const validData = data.filter(v => !isNaN(v) && isFinite(v));
    const n = validData.length;
    
    if (n < 5) {
        return {
            D: null,
            pValue: null,
            error: 'Kolmogorov-Smirnov test requires at least 5 observations'
        };
    }
    
    try {
        const sorted = [...validData].sort((a, b) => a - b);
        const mean = this.jstat.mean(sorted);
        const std = this.jstat.stdev(sorted, true);
        
        // Calculate D statistic
        let dPlus = 0;
        let dMinus = 0;
        
        for (let i = 0; i < n; i++) {
            const z = (sorted[i] - mean) / std;
            const Fn = (i + 1) / n;
            const F0 = this.jstat.normal.cdf(z, 0, 1);
            
            dPlus = Math.max(dPlus, Fn - F0);
            dMinus = Math.max(dMinus, F0 - (i / n));
        }
        
        const D = Math.max(dPlus, dMinus);
        
        // Approximate p-value using modified statistic
        const sqrtN = Math.sqrt(n);
        const lambda = (sqrtN + 0.12 + 0.11 / sqrtN) * D;
        
        // Kolmogorov distribution approximation
        let pValue = 0;
        for (let k = 1; k <= 100; k++) {
            pValue += 2 * Math.pow(-1, k - 1) * Math.exp(-2 * k * k * lambda * lambda);
        }
        pValue = Math.max(0, Math.min(1, pValue));
        
        return {
            D: D,
            pValue: pValue,
            n: n,
            normal: pValue > 0.05,
            test: 'Kolmogorov-Smirnov'
        };
    } catch (error) {
        return {
            D: null,
            pValue: null,
            error: 'Kolmogorov-Smirnov calculation failed'
        };
    }
}

// Anderson-Darling Test
andersonDarlingTest(data) {
    const validData = data.filter(v => !isNaN(v) && isFinite(v));
    const n = validData.length;
    
    if (n < 8) {
        return {
            A2: null,
            pValue: null,
            error: 'Anderson-Darling test requires at least 8 observations'
        };
    }
    
    try {
        const sorted = [...validData].sort((a, b) => a - b);
        const mean = this.jstat.mean(sorted);
        const std = this.jstat.stdev(sorted, true);
        
        // Calculate A² statistic
        let S = 0;
        for (let i = 0; i < n; i++) {
            const z = (sorted[i] - mean) / std;
            const F = this.jstat.normal.cdf(z, 0, 1);
            S += (2 * i + 1) * Math.log(F) + (2 * (n - i) - 1) * Math.log(1 - F);
        }
        
        const A2 = -n - S / n;
        
        // Modified statistic for normal distribution
        const A2star = A2 * (1 + 0.75 / n + 2.25 / (n * n));
        
        // Approximate p-value
        let pValue;
        if (A2star < 0.2) {
            pValue = 1 - Math.exp(-13.436 + 101.14 * A2star - 223.73 * A2star * A2star);
        } else if (A2star < 0.34) {
            pValue = 1 - Math.exp(-8.318 + 42.796 * A2star - 59.938 * A2star * A2star);
        } else if (A2star < 0.6) {
            pValue = Math.exp(0.9177 - 4.279 * A2star - 1.38 * A2star * A2star);
        } else {
            pValue = Math.exp(1.2937 - 5.709 * A2star + 0.0186 * A2star * A2star);
        }
        
        return {
            A2: A2,
            A2star: A2star,
            pValue: Math.max(0.001, Math.min(0.999, pValue)),
            n: n,
            normal: pValue > 0.05,
            test: 'Anderson-Darling'
        };
    } catch (error) {
        return {
            A2: null,
            pValue: null,
            error: 'Anderson-Darling calculation failed'
        };
    }
}

calculateFourfoldStatistics(table) {
    const [[a, b], [c, d]] = table;
    const n = a + b + c + d;
    
    return {
        n: n,
        odds: {
            oddsRatio: (a * d) / (b * c),
            oddsRatioCI: this.calculateOddsRatioCI(a, b, c, d)
        },
        risk: {
            riskDifference: (a / (a + b)) - (c / (c + d)),
            riskDifferenceCI: this.calculateRiskDifferenceCI(a, b, c, d),
            riskRatio: (a / (a + b)) / (c / (c + d)),
            nnt: Math.abs(1 / ((a / (a + b)) - (c / (c + d))))
        },
        chiSquare: this.calculateChiSquareForTable(table),
        fisherExact: this.fisherExactTest(table),
        phi: this.calculatePhiCoefficient(a, b, c, d)
    };
}

calculateDiagnosticMetrics(table) {
    const [[tp, fp], [fn, tn]] = table;
    const total = tp + fp + fn + tn;
    
    const sensitivity = tp / (tp + fn);
    const specificity = tn / (tn + fp);
    const ppv = tp / (tp + fp);
    const npv = tn / (tn + fn);
    const accuracy = (tp + tn) / total;
    const prevalence = (tp + fn) / total;
    
    return {
        sensitivity,
        specificity,
        ppv,
        npv,
        accuracy,
        prevalence,
        lrPositive: sensitivity / (1 - specificity),
        lrNegative: (1 - sensitivity) / specificity,
        youdenIndex: sensitivity + specificity - 1,
        f1Score: 2 * tp / (2 * tp + fp + fn),
        dor: (tp * tn) / (fp * fn),
        mcc: (tp * tn - fp * fn) / Math.sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn)),
        sensitivityCI: this.calculateProportionCI(sensitivity, tp + fn),
        specificityCI: this.calculateProportionCI(specificity, tn + fp),
        ppvCI: this.calculateProportionCI(ppv, tp + fp),
        npvCI: this.calculateProportionCI(npv, tn + fn)
    };
}

validateDiagnosticTestData(table) {
    const [[a, b], [c, d]] = table;
    const errors = [];
    const warnings = [];
    
    if (a + c === 0) errors.push("No positive cases in true condition");
    if (b + d === 0) errors.push("No negative cases in true condition");
    if (a + b === 0) errors.push("No positive test results");
    if (c + d === 0) errors.push("No negative test results");
    
    if (a < 5 || b < 5 || c < 5 || d < 5) {
        warnings.push("Some cells have counts < 5, results may be unreliable");
    }
    
    return {
        isValid: errors.length === 0,
        errors,
        warnings
    };
}

calculateProportionCI(proportion, n, alpha = 0.05) {
    const z = 1.96;
    const se = Math.sqrt(proportion * (1 - proportion) / n);
    return [
        Math.max(0, proportion - z * se),
        Math.min(1, proportion + z * se)
    ];
}

calculateOddsRatioCI(a, b, c, d) {
    const logOR = Math.log((a * d) / (b * c));
    const se = Math.sqrt(1/a + 1/b + 1/c + 1/d);
    const z = 1.96;
    return [
        Math.exp(logOR - z * se),
        Math.exp(logOR + z * se)
    ];
}

calculateRiskDifferenceCI(a, b, c, d) {
    const p1 = a / (a + b);
    const p2 = c / (c + d);
    const rd = p1 - p2;
    const se = Math.sqrt(p1 * (1 - p1) / (a + b) + p2 * (1 - p2) / (c + d));
    const z = 1.96;
    return [rd - z * se, rd + z * se];
}

calculateChiSquareForTable(table) {
    const [[a, b], [c, d]] = table;
    const n = a + b + c + d;
    const chiSquare = n * Math.pow(a * d - b * c, 2) / ((a + b) * (c + d) * (a + c) * (b + d));
    const chiSquareYates = n * Math.pow(Math.abs(a * d - b * c) - n/2, 2) / ((a + b) * (c + d) * (a + c) * (b + d));
    
    return {
        statistic: chiSquare,
        pValue: 1 - this.jstat.chisquare.cdf(chiSquare, 1),
        statisticYates: chiSquareYates,
        pValueYates: 1 - this.jstat.chisquare.cdf(chiSquareYates, 1)
    };
}

calculatePhiCoefficient(a, b, c, d) {
    const n = a + b + c + d;
    return (a * d - b * c) / Math.sqrt((a + b) * (c + d) * (a + c) * (b + d));
}

            // Regression
            linearRegression(points) {
                const validPoints = points.filter(p => !isNaN(p.x) && !isNaN(p.y) && isFinite(p.x) && isFinite(p.y));
                if (validPoints.length < 2) return null;

                try {
                    const x = validPoints.map(p => p.x);
                    const y = validPoints.map(p => p.y);
                    const regression = this.ss.linearRegression(x, y);
                    const line = this.ss.linearRegressionLine(regression);
                    const r = this.ss.sampleCorrelation(x, y);

                    return {
                        slope: regression.m,
                        intercept: regression.b,
                        r: r,
                        r2: r * r,
                        n: validPoints.length,
                        standardError: 0, // Placeholder
                        equation: `y = ${regression.m.toFixed(4)}x + ${regression.b.toFixed(4)}`,
                        points: validPoints,
                        predict: (xVal) => line(xVal)
                    };
                } catch (error) {
                    return null;
                }
            }

            polynomialRegression(points, order) {
    const validPoints = points.filter(p => !isNaN(p.x) && !isNaN(p.y) && isFinite(p.x) && isFinite(p.y));
    if (validPoints.length < order + 1) return null;
    
    try {
        const x = validPoints.map(p => p.x);
        const y = validPoints.map(p => p.y);
        
        // Create design matrix for polynomial regression
        const designMatrix = [];
        for (let i = 0; i < x.length; i++) {
            const row = [];
            for (let j = 0; j <= order; j++) {
                row.push(Math.pow(x[i], j));
            }
            designMatrix.push(row);
        }
        
        // Use simple-statistics for matrix operations
        // Transpose design matrix
        const designMatrixT = designMatrix[0].map((_, colIndex) => 
            designMatrix.map(row => row[colIndex])
        );
        
        // Calculate (X'X)
        const XtX = [];
        for (let i = 0; i <= order; i++) {
            XtX[i] = [];
            for (let j = 0; j <= order; j++) {
                let sum = 0;
                for (let k = 0; k < x.length; k++) {
                    sum += designMatrix[k][i] * designMatrix[k][j];
                }
                XtX[i][j] = sum;
            }
        }
        
        // Calculate (X'y)
        const Xty = [];
        for (let i = 0; i <= order; i++) {
            let sum = 0;
            for (let k = 0; k < x.length; k++) {
                sum += designMatrix[k][i] * y[k];
            }
            Xty[i] = sum;
        }
        
        // Solve using Gaussian elimination (simple implementation)
        const coefficients = this.solveLinearSystem(XtX, Xty);
        
        if (!coefficients) return null;
        
        // Calculate R²
        const meanY = this.ss.mean(y);
        let ssTotal = 0;
        let ssResidual = 0;
        
        for (let i = 0; i < x.length; i++) {
            const predicted = coefficients.reduce((sum, coef, power) => 
                sum + coef * Math.pow(x[i], power), 0
            );
            ssTotal += Math.pow(y[i] - meanY, 2);
            ssResidual += Math.pow(y[i] - predicted, 2);
        }
        
        const r2 = 1 - (ssResidual / ssTotal);
        
        // Create equation string
        let equation = 'y = ';
        for (let i = order; i >= 0; i--) {
            const coef = coefficients[i];
            if (Math.abs(coef) < 1e-10) continue;
            
            if (i < order && coef > 0) equation += ' + ';
            else if (coef < 0) equation += ' - ';
            
            equation += Math.abs(coef).toFixed(4);
            if (i > 1) equation += `x^${i}`;
            else if (i === 1) equation += 'x';
        }
        
        return {
            coefficients: coefficients,
            order: order,
            r2: r2,
            n: validPoints.length,
            equation: equation,
            points: validPoints,
            predict: (xVal) => {
                return coefficients.reduce((sum, coef, power) => 
                    sum + coef * Math.pow(xVal, power), 0
                );
            }
        };
    } catch (error) {
        console.error('Polynomial regression error:', error);
utils.showError(`Polynomial regression failed: ${error.message}`);
        return null;
    }
}

// Helper function for solving linear systems
solveLinearSystem(A, b) {
    const n = b.length;
    const augmented = A.map((row, i) => [...row, b[i]]);
    
    // Gaussian elimination
    for (let i = 0; i < n; i++) {
        // Find pivot
        let maxRow = i;
        for (let k = i + 1; k < n; k++) {
            if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                maxRow = k;
            }
        }
        
        // Swap rows
        [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
        
        // Make all rows below this one 0 in current column
        for (let k = i + 1; k < n; k++) {
            const factor = augmented[k][i] / augmented[i][i];
            for (let j = i; j <= n; j++) {
                augmented[k][j] -= factor * augmented[i][j];
            }
        }
    }
    
    // Back substitution
    const solution = new Array(n);
    for (let i = n - 1; i >= 0; i--) {
        solution[i] = augmented[i][n];
        for (let j = i + 1; j < n; j++) {
            solution[i] -= augmented[i][j] * solution[j];
        }
        solution[i] /= augmented[i][i];
    }
    
    return solution;
}

            logarithmicRegression(points) {
                const validPoints = points.filter(p => !isNaN(p.x) && !isNaN(p.y) && isFinite(p.x) && isFinite(p.y) && p.x > 0);
                if (validPoints.length < 2) return null;

                try {
                    const transformedPoints = validPoints.map(p => ({ x: Math.log(p.x), y: p.y }));
                    const linear = this.linearRegression(transformedPoints);
                    if (!linear) return null;

                    const a = linear.slope;
                    const b = linear.intercept;

                    return {
                        a: a,
                        b: b,
                        r2: linear.r2,
                        n: linear.n,
                        equation: `y = ${a.toFixed(4)}·ln(x) + ${b.toFixed(4)}`,
                        points: validPoints,
                        predict: (x) => a * Math.log(x) + b
                    };
                } catch (error) {
                    return null;
                }
            }

            exponentialRegression(points) {
                const validPoints = points.filter(p => !isNaN(p.x) && !isNaN(p.y) && isFinite(p.x) && isFinite(p.y) && p.y > 0);
                if (validPoints.length < 2) return null;

                try {
                    const transformedPoints = validPoints.map(p => ({ x: p.x, y: Math.log(p.y) }));
                    const linear = this.linearRegression(transformedPoints);
                    if (!linear) return null;

                    const b = linear.slope;
                    const lnA = linear.intercept;
                    const a = Math.exp(lnA);

                    const meanY = validPoints.reduce((sum, p) => sum + p.y, 0) / validPoints.length;
                    let ssTotal = 0;
                    let ssResidual = 0;

                    validPoints.forEach(p => {
                        const predicted = a * Math.exp(b * p.x);
                        ssTotal += Math.pow(p.y - meanY, 2);
                        ssResidual += Math.pow(p.y - predicted, 2);
                    });

                    const r2 = 1 - (ssResidual / ssTotal);

                    return {
                        a: a,
                        b: b,
                        r2: r2,
                        n: linear.n,
                        equation: `y = ${a.toFixed(4)}·e^(${b.toFixed(4)}x)`,
                        points: validPoints,
                        predict: (x) => a * Math.exp(b * x)
                    };
                } catch (error) {
                    return null;
                }
            }

            testRegressionSignificance(regression, type, alpha = 0.05) {
                if (!regression || !regression.n || regression.n < 3) {
                    return {
                        significant: false,
                        error: 'Insufficient data for significance testing'
                    };
                }

                const df = regression.n - 2;
                const fStat = (regression.r2 / (1 - regression.r2)) * df;
                const pValue = 1 - this.jstat.centralF.cdf(fStat, 1, df);

                return {
                    fStatistic: fStat,
                    pValue: pValue,
                    significant: pValue < alpha,
                    df1: 1,
                    df2: df
                };
            }
        }

        /**
 * Intelligent Test Selection System
 */
        class IntelligentTestSelector {
            constructor(statisticalLibrary) {
                this.stats = statisticalLibrary;
                this.tests = statisticalLibrary.testDefinitions;
            }

            selectOptimalTest(parameterName, selectedGroups, options = {}) {
                const forceTest = options.forceTest || false;
                const alpha = options.alpha || 0.05;

                try {
                    const basicCriteria = this.analyzeBasicCriteria(parameterName, selectedGroups);
                    if (basicCriteria.error) {
                        return { error: basicCriteria.error };
                    }

                    const eligibleTests = this.filterEligibleTests(basicCriteria);
                    if (eligibleTests.length === 0) {
                        return { error: 'No suitable tests available for this data combination' };
                    }

                    const prerequisiteResults = this.runPrerequisiteTests(parameterName, selectedGroups);
                    const rankedTests = this.rankTests(eligibleTests, prerequisiteResults, forceTest);
                    const recommendation = this.generateRecommendation(rankedTests, prerequisiteResults);

                    return {
                        success: true,
                        recommended: recommendation.primary,
                        alternatives: recommendation.alternatives,
                        prerequisites: prerequisiteResults,
                        explanation: recommendation.explanation,
                        canProceed: recommendation.canProceed || forceTest
                    };
                } catch (error) {
                    return { error: `Test selection failed: ${error.message}` };
                }
            }

            analyzeBasicCriteria(parameterName, selectedGroups) {
                const parameterType = globalState.columnTypes[parameterName];
                const scaleInfo = scaleTypes[parameterType];
                const groupCount = selectedGroups.length;

                if (!parameterType) {
                    return { error: 'Unknown parameter type' };
                }
                if (groupCount < 1) {
                    return { error: 'At least one group required' };
                }

                const groupSizes = selectedGroups.map(groupId => {
                    const data = globalState.processedData[groupId]
                        .map(row => scaleInfo.numeric ? utils.parseNumericValue(row[parameterName]) : row[parameterName])
                        .filter(val => val !== null && val !== undefined && (scaleInfo.numeric ? !isNaN(val) : val !== ''));
                    return { groupId, size: data.length, data };
                });

                const minGroupSize = Math.min(...groupSizes.map(g => g.size));
                if (minGroupSize < 2) {
                    return { error: 'At least 2 valid observations per group required' };
                }

                return {
                    parameterType,
                    scaleInfo,
                    groupCount,
                    groupSizes,
                    minGroupSize,
                    totalN: groupSizes.reduce((sum, g) => sum + g.size, 0)
                };
            }

            filterEligibleTests(criteria) {
                const eligible = [];
                Object.entries(this.tests).forEach(([testKey, test]) => {
                    if (test.scaleTypes.includes(criteria.parameterType) &&
                        criteria.groupCount >= test.groups.min &&
                        criteria.groupCount <= test.groups.max) {
                        eligible.push({ key: testKey, ...test });
                    }
                });
                return eligible;
            }

            runPrerequisiteTests(parameterName, selectedGroups) {
                const parameterType = globalState.columnTypes[parameterName];
                const scaleInfo = scaleTypes[parameterType];

                const results = {
                    normality: { tested: false, results: {}, allGroupsNormal: false },
                    variance: { tested: false, result: null, homogeneous: false },
                    sampleSize: { adequate: true, warnings: [] }
                };

                // Check for manual overrides
if (globalState.assumptionOverrides.normality[parameterName]) {
    Object.keys(globalState.assumptionOverrides.normality[parameterName]).forEach(groupId => {
        if (globalState.assumptionOverrides.normality[parameterName][groupId]) {
            const groupName = globalState.currentGroups[groupId].name;
            if (results.normality.results[groupName]) {
                results.normality.results[groupName].normal = true;
                results.normality.results[groupName].overridden = true;
            }
        }
    });
    
    // Recalculate allGroupsNormal
    results.normality.allGroupsNormal = Object.values(results.normality.results)
        .every(result => result.normal || result.overridden);
}

// Check for variance homogeneity override
if (globalState.assumptionOverrides.homogeneity[parameterName]) {
    if (results.variance.result) {
        results.variance.result.equalVariances = true;
        results.variance.result.overridden = true;
        results.variance.homogeneous = true;
    }
}

                if (!scaleInfo.numeric) {
                    return results;
                }

                try {
                    const groupData = selectedGroups.map(groupId => {
                        return globalState.processedData[groupId]
                            .map(row => utils.parseNumericValue(row[parameterName]))
                            .filter(val => !isNaN(val) && isFinite(val));
                    });

                    results.normality.tested = true;
                    let allNormal = true;

                    groupData.forEach((data, index) => {
                        const groupName = globalState.currentGroups[selectedGroups[index]].name;
                        const normalityResult = this.stats.shapiroWilkTest(data);
                        results.normality.results[groupName] = normalityResult;

                        if (!normalityResult.error && !normalityResult.normal) {
                            allNormal = false;
                        }
                    });

                    results.normality.allGroupsNormal = allNormal;

                    if (groupData.length >= 2) {
                        results.variance.tested = true;
                        const varianceResult = this.stats.fTest(groupData[0], groupData[1]);
                        results.variance.result = varianceResult;
                        results.variance.homogeneous = !varianceResult.error && varianceResult.equalVariances;
                    }

                    groupData.forEach((data, index) => {
                        const groupName = globalState.currentGroups[selectedGroups[index]].name;
                        if (data.length < 10) {
                            results.sampleSize.warnings.push(`Group "${groupName}" has only ${data.length} observations (< 10)`);
                            results.sampleSize.adequate = false;
                        }
                    });

                } catch (error) {
console.warn('Error in prerequisite tests:', error);
utils.showError(`Error checking prerequisites: ${error.message}`);
                }

                // Check for manual overrides
if (globalState.assumptionOverrides.normality[parameterName]) {
    selectedGroups.forEach(groupId => {
        if (globalState.assumptionOverrides.normality[parameterName][groupId]) {
            const groupName = globalState.currentGroups[groupId].name;
            if (results.normality.results[groupName]) {
                results.normality.results[groupName].normal = true;
                results.normality.results[groupName].overridden = true;
            }
        }
    });
    
    // Recalculate allGroupsNormal
    results.normality.allGroupsNormal = Object.values(results.normality.results)
        .every(result => result.normal || result.overridden);
}

                return results;
            }

            rankTests(eligibleTests, prerequisiteResults, forceTest) {
                return eligibleTests.map(test => {
                    let score = 100;
                    const violations = [];
                    const warnings = [];

                    if (test.requirements.includes('normal_distribution')) {
                        if (prerequisiteResults.normality.tested && !prerequisiteResults.normality.allGroupsNormal) {
                            score -= 40;
                            violations.push('Normal distribution not met in all groups');
                        }
                    }

                    if (test.requirements.includes('equal_variances')) {
                        if (prerequisiteResults.variance.tested && !prerequisiteResults.variance.homogeneous) {
                            score -= 30;
                            violations.push('Variance homogeneity not met');
                        }
                    }

                    if (violations.length > 0) {
                        if (test.category === 'nonparametric') {
                            score += 25;
                        }
                        if (test.key === 'welch') {
                            score += 20;
                        }
                    }

                    if (!prerequisiteResults.sampleSize.adequate) {
                        if (test.category === 'nonparametric') {
                            score += 10;
                        } else {
                            score -= 15;
                            warnings.push('Small sample size may affect test results');
                        }
                    }

                    const canRun = forceTest || violations.length === 0 || test.category === 'nonparametric';

                    return {
                        test: test,
                        score: Math.max(0, score),
                        violations: violations,
                        warnings: warnings,
                        canRun: canRun,
                        confidence: Math.max(10, Math.min(100, score - violations.length * 15 - warnings.length * 5))
                    };
                }).sort((a, b) => b.score - a.score);
            }

            generateRecommendation(rankedTests, prerequisiteResults) {
                const primary = rankedTests[0];
                const alternatives = rankedTests.slice(1, 3);

                let explanation = `**${primary.test.name}** wird empfohlen:\n\n`;
                explanation += `• ${primary.test.indication}\n`;

                if (primary.violations.length === 0) {
                    explanation += '• ✅ All test prerequisites are met\n';
                } else {
                    explanation += `• ⚠️ Prerequisite violations: ${primary.violations.join(', ')}\n`;
                    if (primary.test.category === 'nonparametric') {
                        explanation += '• ✅ Non-parametric test is robust against these violations\n';
                    }
                }

                if (primary.warnings.length > 0) {
                    explanation += `• ⚠️ Notes: ${primary.warnings.join(', ')}\n`;
                }

                return {
                    primary: primary,
                    alternatives: alternatives,
                    explanation: explanation,
                    canProceed: primary.canRun
                };
            }
        }

        // Global instance - will be initialized after libraries load
let statistics;

// Interpretation Engine
const interpretationEngine = {
    effectSize: {
        cohen_d: (d) => {
            const absD = Math.abs(d);
            if (absD < 0.2) return { level: 'negligible', description: 'Negligible effect' };
            if (absD < 0.5) return { level: 'small', description: 'Small effect' };
            if (absD < 0.8) return { level: 'medium', description: 'Medium effect' };
            return { level: 'large', description: 'Large effect' };
        },
        eta_squared: (eta2) => {
            if (eta2 < 0.01) return { level: 'negligible', description: 'Negligible effect' };
            if (eta2 < 0.06) return { level: 'small', description: 'Small effect' };
            if (eta2 < 0.14) return { level: 'medium', description: 'Medium effect' };
            return { level: 'large', description: 'Large effect' };
        },
        correlation: (r) => {
            const absR = Math.abs(r);
            if (absR < 0.1) return { level: 'negligible', description: 'Negligible correlation' };
            if (absR < 0.3) return { level: 'weak', description: 'Weak correlation' };
            if (absR < 0.5) return { level: 'moderate', description: 'Moderate correlation' };
            if (absR < 0.7) return { level: 'strong', description: 'Strong correlation' };
            return { level: 'very_strong', description: 'Very strong correlation' };
        }
    },
    
    power: (power) => {
        if (power < 0.5) return { adequate: false, description: 'Very low power - high risk of Type II error' };
        if (power < 0.8) return { adequate: false, description: 'Low power - moderate risk of Type II error' };
        if (power < 0.95) return { adequate: true, description: 'Adequate power' };
        return { adequate: true, description: 'Excellent power' };
    },
    
    pValue: (p, alpha) => {
        if (p < 0.001) return { significant: true, description: 'Highly significant (p < 0.001)' };
        if (p < 0.01) return { significant: true, description: 'Very significant (p < 0.01)' };
        if (p < alpha) return { significant: true, description: `Significant (p < ${alpha})` };
        return { significant: false, description: `Not significant (p ≥ ${alpha})` };
    }
};
        
/**
 * Initialize the application after all libraries are loaded
 */
function initializeApplication() {
    // Create the statistics instance
    statistics = new StatisticalLibrary();
    
    // Set up all event listeners and UI components
    setupEventListeners();
    setupDragAndDrop();
    setupTabs();
    setupAboutModal();
    setupSignificanceTestOptions();
    setupTestInfoDisplay();
    
    console.log('Application initialized successfully');
}

/**
 * Wait for all libraries to load
 */
function waitForLibraries() {
    const loadingDiv = document.getElementById('library-loading');
    let loadingMessage = loadingDiv ? loadingDiv.querySelector('.loading') : null;
    
    // Update loading message
    const updateLoadingMessage = (message) => {
        if (loadingMessage) {
            loadingMessage.innerHTML = `<div class="loading">${message}</div>`;
        }
    };
    
    // Check if loader promises exist (CDN mode)
    if (window.libraryLoader) {
        const promises = [];
        const libraryNames = [];
        
        // Collect all library promises
        if (window.libraryLoader.papaparse) {
            promises.push(window.libraryLoader.papaparse);
            libraryNames.push('PapaParse');
        }
        if (window.libraryLoader.chartjs) {
            promises.push(window.libraryLoader.chartjs);
            libraryNames.push('Chart.js');
        }
        if (window.libraryLoader.jstat) {
            promises.push(window.libraryLoader.jstat);
            libraryNames.push('jStat');
        }
        if (window.libraryLoader.html2canvas) {
            promises.push(window.libraryLoader.html2canvas);
            libraryNames.push('html2canvas');
        }
        if (window.libraryLoader.simplestatistics) {
            promises.push(window.libraryLoader.simplestatistics);
            libraryNames.push('Simple Statistics');
        }
        
        if (promises.length > 0) {
            updateLoadingMessage(`Loading libraries (0/${libraryNames.length})...`);
            
            // Track loading progress
            let loadedCount = 0;
            promises.forEach((promise, index) => {
                promise.then(() => {
                    loadedCount++;
                    updateLoadingMessage(`Loading libraries (${loadedCount}/${libraryNames.length})...`);
                });
            });
            
            // Wait for all CDN libraries with timeout
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Loading timeout')), 30000); // 30 seconds timeout
            });
            
            Promise.race([
                Promise.all(promises),
                timeoutPromise
            ])
            .then(() => {
                console.log('All libraries loaded from CDN');
                initializeApplication();
            })
            .catch(error => {
                console.error('Failed to load libraries:', error);
                updateLoadingMessage('Failed to load libraries. Retrying...');
                
                // Retry mechanism
                setTimeout(() => {
                    if (typeof Papa !== 'undefined' && 
                        typeof Chart !== 'undefined' && 
                        typeof jStat !== 'undefined' && 
                        typeof html2canvas !== 'undefined' && 
                        typeof ss !== 'undefined') {
                        console.log('Libraries loaded after retry');
                        initializeApplication();
                    } else {
                        alert('Failed to load required libraries. Please check your internet connection and refresh the page.');
                    }
                }, 2000);
            });
            return;
        }
    }
    
    // If no loader promises, check if libraries are already loaded (offline mode)
    if (typeof Papa !== 'undefined' && 
        typeof Chart !== 'undefined' && 
        typeof jStat !== 'undefined' && 
        typeof html2canvas !== 'undefined' && 
        typeof ss !== 'undefined') {
        console.log('All libraries loaded (offline mode)');
        initializeApplication();
    } else {
        // Libraries not loaded yet, show error
        console.error('Libraries not loaded. Make sure to either use CDN loaders or download actual library files.');
        alert('Required libraries are not loaded. Please check your library files.');
    }
}

/**
 * Start the application when DOM is ready
 */
document.addEventListener('DOMContentLoaded', function() {
    // Add loading indicator
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'library-loading';
    loadingDiv.innerHTML = '<div class="loading">Loading libraries...</div>';
    loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--card-background); padding: 40px; border-radius: 12px; box-shadow: var(--box-shadow); z-index: 9999;';
    document.body.appendChild(loadingDiv);
    
    // Start loading process
    waitForLibraries();
    
    // Remove loading indicator when done
    window.addEventListener('load', () => {
        setTimeout(() => {
            const loader = document.getElementById('library-loading');
            if (loader) loader.remove();
        }, 1000);
    });
});

        /**
         * Set up all event listeners for the application
         */
        function setupEventListeners() {
            // File upload
            document.getElementById('csv-file').addEventListener('change', handleFileUpload);

            // Data pagination
            document.getElementById('rows-per-page').addEventListener('change', updateDataPagination);
            document.getElementById('export-preview-csv').addEventListener('click', exportDataPreview);

            // Parameter constellations
            document.getElementById('add-constellation').addEventListener('click', addNewConstellation);

            // Group management
            document.getElementById('add-group').addEventListener('click', addNewGroup);
            document.getElementById('apply-groups').addEventListener('click', applyGroupsAndAnalyze);
            document.getElementById('reset-groups').addEventListener('click', resetGroups);
            document.getElementById('import-groups').addEventListener('click', importGroupDefinitions);
            document.getElementById('export-groups').addEventListener('click', exportGroupDefinitions);

            // Analysis tabs
            document.getElementById('detail-parameter-select').addEventListener('change', updateDetailAnalysis);
            document.getElementById('run-significance-test').addEventListener('click', runSignificanceTest);
            document.getElementById('clear-significance-results').addEventListener('click', clearSignificanceResults);
            document.getElementById('generate-visualization').addEventListener('click', generateCustomVisualization);

            // Prerequisite tests
            document.getElementById('check-prerequisites').addEventListener('click', checkAllPrerequisites);

            // Override checkboxes
document.getElementById('override-normality').addEventListener('change', updateRecommendationBasedOnOverrides);
document.getElementById('override-homogeneity').addEventListener('change', updateRecommendationBasedOnOverrides);
            
            // Visualization controls
            document.getElementById('viz-chart-type').addEventListener('change', updateVisualizationControls);
            document.getElementById('viz-parameter-x').addEventListener('change', updateVisualizationControls);
            document.getElementById('viz-parameter-y').addEventListener('change', updateVisualizationControls);

            // Regression controls
            document.getElementById('regression-type').addEventListener('change', updateRegressionInfo);
            document.getElementById('regression-alpha').addEventListener('change', function() {
    const customInput = document.getElementById('regression-custom-alpha');
    customInput.style.display = this.value === 'custom' ? 'inline-block' : 'none';
    updateRegressionInfo();
});

document.getElementById('regression-custom-alpha').addEventListener('change', updateRegressionInfo);
            document.getElementById('show-regression').addEventListener('change', updateRegressionInfo);

            // Fourfold table
            document.getElementById('generate-fourfold').addEventListener('click', generateFourfoldTable);

            // Export functionality
            document.getElementById('export-csv-data').addEventListener('click', exportAnalysisResults);
            document.getElementById('fourfold-constellation-1').addEventListener('focus', updateConstellationState);
            document.getElementById('fourfold-constellation-2').addEventListener('focus', updateConstellationState);

            // Parameter and group selection change listeners
    document.getElementById('sig-parameter-select').addEventListener('change', updateTestSelectionUI);

    // Test type change listener
    document.getElementById('sig-test-type').addEventListener('change', function() {
    updateTestSelectionUI();
});
        }

        /**
         * Set up drag and drop functionality for file upload
         */
        function setupDragAndDrop() {
            const fileInputArea = document.getElementById('file-input-area');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                fileInputArea.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                fileInputArea.addEventListener(eventName, () => {
                    fileInputArea.classList.add('dragover');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                fileInputArea.addEventListener(eventName, () => {
                    fileInputArea.classList.remove('dragover');
                }, false);
            });

            fileInputArea.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    document.getElementById('csv-file').files = files;
                    handleFileUpload({ target: { files: files } });
                }
            }, false);
        }

        /**
         * Set up tab navigation
         */
        function setupTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
    // Deactivate all tabs
    tabButtons.forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
    document.body.classList.remove('significance-tab-active');

    // Activate selected tab
    button.classList.add('active');
    const tabId = button.getAttribute('data-tab');
    document.getElementById(tabId).classList.add('active');
    
    // Add special class for significance tab
    if (tabId === 'significance') {
        document.body.classList.add('significance-tab-active');
    }

                    // Resize charts in active tab
                    setTimeout(() => {
                        Object.keys(globalState.charts).forEach(chartId => {
                            if (globalState.charts[chartId] && document.getElementById(chartId)) {
                                try {
                                    globalState.charts[chartId].resize();
                                } catch (e) {
                                    console.warn('Chart resize error:', e);
                                }
                            }
                        });
                    }, 100);
                });
            });
        }

        /**
         * Set up the about modal
         */
        function setupAboutModal() {
            const aboutBtn = document.getElementById('about-btn');
            const aboutModal = document.getElementById('about-modal');
            const closeAbout = document.getElementById('close-about');

            aboutBtn.addEventListener('click', () => {
                aboutModal.style.display = 'block';
            });

            closeAbout.addEventListener('click', () => {
                aboutModal.style.display = 'none';
            });

            window.addEventListener('click', (e) => {
                if (e.target === aboutModal) {
                    aboutModal.style.display = 'none';
                }
            });
        }

        /**
         * Set up significance test option interactions
         */
        function setupSignificanceTestOptions() {
            const alphaSelect = document.getElementById('sig-alpha');
            const customAlphaInput = document.getElementById('sig-custom-alpha');

            alphaSelect.addEventListener('change', () => {
                if (alphaSelect.value === 'custom') {
                    customAlphaInput.style.display = 'block';
                } else {
                    customAlphaInput.style.display = 'none';
                }
            });
        }

        /**
         * Set up test info display
         */
        function setupTestInfoDisplay() {
    const testTypeSelect = document.getElementById('sig-test-type');
    const testInfoDiv = document.getElementById('test-info');
    
    if (!testTypeSelect || !testInfoDiv) {
        console.warn('Test type select or info div not found');
        return;
    }

    testTypeSelect.addEventListener('change', () => {
        const selectedTest = testTypeSelect.value;
        if (selectedTest && testInfo[selectedTest]) {
            const info = testInfo[selectedTest];
            testInfoDiv.innerHTML = `
                <strong>${info.name}</strong><br>
                ${info.description}<br>
                ${info.requirements ? `<em>Requirements: ${info.requirements}</em>` : ''}
            `;
            testInfoDiv.style.display = 'block';
        } else {
            testInfoDiv.style.display = 'none';
        }
    });
}

        function getIntelligentTestRecommendation() {
    const paramName = document.getElementById('sig-parameter-select').value;
    if (!paramName) {
        utils.showError("Please select a parameter first.");
        return;
    }

    const selectedGroups = [];
    document.querySelectorAll('#sig-group-selection input:checked').forEach(checkbox => {
        selectedGroups.push(checkbox.value);
    });

    if (selectedGroups.length < 1) {
        utils.showError("Please select at least one group.");
        return;
    }

    const testSelector = new IntelligentTestSelector(statistics);
    const recommendation = testSelector.selectOptimalTest(paramName, selectedGroups);

    if (recommendation.error) {
        utils.showError(recommendation.error);
        return;
    }

    displayTestRecommendation(recommendation, paramName, selectedGroups);
}

        function displayTestRecommendation(recommendation, paramName, selectedGroups) {
    // Display inline recommendation
    const inlineDisplay = document.getElementById('test-recommendation-inline');
    if (inlineDisplay) {
        const primary = recommendation.recommended;
        let inlineHtml = `
            <div style="display: flex; align-items: center; justify-content: space-between;">
                <div>
                    <strong style="color: var(--primary-color);">🎯 Recommended Test: ${primary.test.name}</strong>
                    <div style="font-size: 14px; color: var(--text-light); margin-top: 5px;">
                        ${primary.test.indication}
                    </div>
                </div>
                <div style="text-align: right;">
                    <div class="confidence-indicator">
                        <span style="font-size: 12px; color: var(--text-light);">Confidence:</span>
                        <span style="font-weight: bold; color: ${primary.confidence >= 80 ? 'var(--success-color)' : primary.confidence >= 60 ? 'var(--warning-color)' : 'var(--danger-color)'};">
                            ${primary.confidence}%
                        </span>
                    </div>
                </div>
            </div>
        `;
        
        if (primary.violations.length > 0) {
            inlineHtml += `
                <div style="margin-top: 10px; padding: 10px; background-color: rgba(212, 162, 90, 0.1); border-radius: 6px;">
                    <strong style="color: var(--warning-color);">⚠️ Violations:</strong>
                    <ul style="margin: 5px 0 0 20px; font-size: 14px;">
                        ${primary.violations.map(v => `<li>${v}</li>`).join('')}
                    </ul>
                </div>
            `;
        }
        
        inlineDisplay.innerHTML = inlineHtml;
        inlineDisplay.style.display = 'block';
    }

    const primary = recommendation.recommended;
    const groupNames = selectedGroups.map(id => globalState.currentGroups[id].name);

    // Simple recommendation display
const displayDiv = document.getElementById('test-recommendation-display');
const contentDiv = document.getElementById('recommendation-content');

if (displayDiv && contentDiv) {
    contentDiv.innerHTML = `
        <p><strong>${primary.test.name}</strong></p>
        <p style="margin: 10px 0; color: var(--text-light);">${primary.test.indication}</p>
        <p><strong>Confidence:</strong> ${primary.confidence}%</p>
        ${primary.violations.length > 0 ? 
            `<p style="color: var(--warning-color);"><strong>Note:</strong> ${primary.violations.join(', ')}</p>` : 
            '<p style="color: var(--success-color);"><strong>✓ All prerequisites met</strong></p>'
        }
    `;
    displayDiv.style.display = 'block';
    
    // Auto-select the recommended test
    document.getElementById('sig-test-type').value = primary.test.key;
}

// Don't display prerequisites again - they're already shown above
return;

    // Add prerequisite overview
    if (recommendation.prerequisites) {
        html += '<div class="prerequisite-summary" style="margin-top: 20px;">';
        
        if (recommendation.prerequisites.normality.tested) {
            html += '<div class="prerequisite-section">';
            html += '<h6>📊 Normality Tests:</h6>';

            Object.entries(recommendation.prerequisites.normality.results).forEach(([groupName, result]) => {
                const status = result.error ? 'error' : (result.normal ? 'pass' : 'fail');
                const icon = status === 'pass' ? '✅' : (status === 'fail' ? '❌' : '⚠️');

                html += `
                    <div class="prerequisite-item ${status}">
                        ${icon} <strong>${groupName}:</strong> 
                        ${result.error || `${result.test || 'Shapiro-Wilk'} (p = ${result.pValue?.toFixed(4) || 'N/A'})`}
                    </div>
                `;
            });

            html += '</div>';
        }

        if (recommendation.prerequisites.variance.tested) {
            const result = recommendation.prerequisites.variance.result;
            const status = result.error ? 'error' : (result.equalVariances ? 'pass' : 'fail');
            const icon = status === 'pass' ? '✅' : (status === 'fail' ? '❌' : '⚠️');

            html += '<div class="prerequisite-section">';
            html += '<h6>📏 Variance Homogeneity:</h6>';
            html += `
                <div class="prerequisite-item ${status}">
                    ${icon} <strong>F-Test:</strong> 
                    ${result.error || `p = ${result.pValue?.toFixed(4) || 'N/A'}`}
                </div>
            `;
            html += '</div>';
        }

        if (recommendation.prerequisites.sampleSize.warnings.length > 0) {
            html += '<div class="prerequisite-section">';
            html += '<h6>👥 Sample Size:</h6>';

            recommendation.prerequisites.sampleSize.warnings.forEach(warning => {
                html += `
                    <div class="prerequisite-item warning">
                        ⚠️ ${warning}
                    </div>
                `;
            });

            html += '</div>';
        }

        html += '</div>';
    }

    // Find or create the display div
    displayDiv = document.getElementById('test-recommendation-display');
    if (!displayDiv) {
        // If it doesn't exist, create it after the prerequisite results
        displayDiv = document.createElement('div');
        displayDiv.id = 'test-recommendation-display';
        displayDiv.className = 'recommendation-display';
        const prereqResults = document.getElementById('prerequisite-results');
        if (prereqResults && prereqResults.parentNode) {
            prereqResults.parentNode.insertBefore(displayDiv, prereqResults.nextSibling);
        }
    }

    displayDiv.innerHTML = html;
    displayDiv.style.display = 'block';
}

        function displayPrerequisiteOverview(prerequisites, container) {
            let html = '<div class="prerequisite-summary">';

            if (prerequisites.normality.tested) {
                html += '<div class="prerequisite-section">';
                html += '<h6>📊 Normalitätstests:</h6>';

                Object.entries(prerequisites.normality.results).forEach(([groupName, result]) => {
                    const status = result.error ? 'error' : (result.normal ? 'pass' : 'fail');
                    const icon = status === 'pass' ? '✅' : (status === 'fail' ? '❌' : '⚠️');

                    html += `
                <div class="prerequisite-item ${status}">
                    ${icon} <strong>${groupName}:</strong> 
                    ${result.error || `Shapiro-Wilk (p = ${result.pValue?.toFixed(4) || 'N/A'})`}
                </div>
            `;
                });

                html += '</div>';
            }

            if (prerequisites.variance.tested) {
                const result = prerequisites.variance.result;
                const status = result.error ? 'error' : (result.equalVariances ? 'pass' : 'fail');
                const icon = status === 'pass' ? '✅' : (status === 'fail' ? '❌' : '⚠️');

                html += '<div class="prerequisite-section">';
                html += '<h6>📏 Varianzhomogenität:</h6>';
                html += `
            <div class="prerequisite-item ${status}">
                ${icon} <strong>F-Test:</strong> 
                ${result.error || `p = ${result.pValue?.toFixed(4) || 'N/A'}`}
            </div>
        `;
                html += '</div>';
            }

            if (prerequisites.sampleSize.warnings.length > 0) {
                html += '<div class="prerequisite-section">';
                html += '<h6>👥 Stichprobengröße:</h6>';

                prerequisites.sampleSize.warnings.forEach(warning => {
                    html += `
                <div class="prerequisite-item warning">
                    ⚠️ ${warning}
                </div>
            `;
                });

                html += '</div>';
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function getConfidenceClass(confidence) {
    if (confidence >= 80) return 'high';
    if (confidence >= 60) return 'medium';
    return 'low';
}

function getTestCategoryName(category) {
    const names = {
        'parametric': 'Parametric',
        'nonparametric': 'Non-parametric',
        'categorical': 'Categorical'
    };
    return names[category] || category;
}

        /**
 * Update test recommendation based on parameter and group selection
 */
function updateTestRecommendation() {
    const paramName = document.getElementById('sig-parameter-select').value;
    const selectedGroups = [];
    document.querySelectorAll('#sig-group-selection input:checked').forEach(checkbox => {
        selectedGroups.push(checkbox.value);
    });

    if (paramName && selectedGroups.length > 0) {
        clearTimeout(updateTestRecommendation.timeout);
        updateTestRecommendation.timeout = setTimeout(() => {
            getIntelligentTestRecommendation();
        }, 500);
    }
}

        /**
 * Update test selection UI based on parameter and group selection
 */
function updateTestSelectionUI() {
    const paramName = document.getElementById('sig-parameter-select').value;
    const selectedGroups = [];
    document.querySelectorAll('#sig-group-selection input:checked').forEach(checkbox => {
        selectedGroups.push(checkbox.value);
    });
    
    const hasValidSelection = paramName && selectedGroups.length >= 1;
}

        function updateRecommendationBasedOnOverrides() {
    const paramName = document.getElementById('sig-parameter-select').value;
    if (!paramName) return;
    
    const selectedGroups = [];
    document.querySelectorAll('#sig-group-selection input:checked').forEach(checkbox => {
        selectedGroups.push(checkbox.value);
    });
    
    if (selectedGroups.length === 0) return;
    
    // Update stored overrides
    const normalityOverride = document.getElementById('override-normality').checked;
    const homogeneityOverride = document.getElementById('override-homogeneity').checked;
    
    if (!globalState.assumptionOverrides.normality[paramName]) {
        globalState.assumptionOverrides.normality[paramName] = {};
    }
    
    selectedGroups.forEach(groupId => {
        globalState.assumptionOverrides.normality[paramName][groupId] = normalityOverride;
    });
    
    globalState.assumptionOverrides.homogeneity[paramName] = homogeneityOverride;
    
    // Re-run test recommendation
    const testSelector = new IntelligentTestSelector(statistics);
    const recommendation = testSelector.selectOptimalTest(paramName, selectedGroups);
    
    if (!recommendation.error) {
        displayTestRecommendation(recommendation, paramName, selectedGroups);
        
        // Pre-select the recommended test
        if (recommendation.recommended && recommendation.recommended.test) {
            document.getElementById('sig-test-type').value = recommendation.recommended.test.key;
        }
        
        // Update inline display
        const inlineDisplay = document.getElementById('test-recommendation-inline');
        if (inlineDisplay && recommendation.recommended) {
            const primary = recommendation.recommended;
            let inlineHtml = `
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div>
                        <strong style="color: var(--primary-color);">🎯 Recommended Test: ${primary.test.name}</strong>
                        <div style="font-size: 14px; color: var(--text-light); margin-top: 5px;">
                            ${primary.test.indication}
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div class="confidence-indicator">
                            <span style="font-size: 12px; color: var(--text-light);">Confidence:</span>
                            <span style="font-weight: bold; color: ${primary.confidence >= 80 ? 'var(--success-color)' : primary.confidence >= 60 ? 'var(--warning-color)' : 'var(--danger-color)'};">
                                ${primary.confidence}%
                            </span>
                        </div>
                    </div>
                </div>
            `;
            
            if (primary.violations.length > 0) {
                inlineHtml += `
                    <div style="margin-top: 10px; padding: 10px; background-color: rgba(212, 162, 90, 0.1); border-radius: 6px;">
                        <strong style="color: var(--warning-color);">⚠️ Violations:</strong>
                        <ul style="margin: 5px 0 0 20px; font-size: 14px;">
                            ${primary.violations.map(v => `<li>${v}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }
            
            inlineDisplay.innerHTML = inlineHtml;
            inlineDisplay.style.display = 'block';
        }
    }
}

        /**
         * Update visualization controls based on chart type and selected parameters
         */
        function updateVisualizationControls() {
            const chartType = document.getElementById('viz-chart-type').value;
            const regressionControls = document.getElementById('regression-controls');
            const paramX = document.getElementById('viz-parameter-x').value;
            const paramY = document.getElementById('viz-parameter-y').value;

            // Only show regression controls for scatter plots with numeric parameters on both axes
            if (chartType === 'scatter' &&
                paramX && paramY &&
                scaleTypes[globalState.columnTypes[paramX]].numeric &&
                scaleTypes[globalState.columnTypes[paramY]].numeric) {
                regressionControls.style.display = 'block';
            } else {
                regressionControls.style.display = 'none';
            }
        }

        /**
         * Update regression info display
         */
        function updateRegressionInfo() {
            // This will be called when regression type changes
            // The actual update happens when the chart is generated
        }

        /**
         * Check normality for selected parameter and groups
         */
        function checkNormality() {
            
    const paramName = document.getElementById('sig-parameter-select').value;
    if (!paramName) {
        utils.showError("Please select a parameter first.");
        return;
    }

    const paramType = globalState.columnTypes[paramName];
    if (!scaleTypes[paramType].numeric) {
        utils.showError("Normality test requires a numeric parameter (ordinal, interval, or ratio scale).");
        return;
    }

    // Get selected groups
    const selectedGroups = [];
    document.querySelectorAll('#sig-group-selection input:checked').forEach(checkbox => {
        selectedGroups.push(checkbox.value);
    });

    if (selectedGroups.length === 0) {
        utils.showError("Please select at least one group.");
        return;
    }

    // Clear previous results
    const resultsContainer = document.getElementById('prerequisite-results');
    resultsContainer.innerHTML = '';

    // Store results
    if (!globalState.prerequisiteResults[paramName]) {
        globalState.prerequisiteResults[paramName] = {};
    }

    // Test each group
    selectedGroups.forEach(groupId => {
        const groupData = globalState.processedData[groupId]
            .map(row => utils.parseNumericValue(row[paramName]))
            .filter(val => !isNaN(val));

        const groupName = globalState.currentGroups[groupId].name;
        
        // Perform multiple normality tests
        const shapiroResult = statistics.shapiroWilkTest(groupData);
        const ksResult = statistics.kolmogorovSmirnovTest(groupData);
        const adResult = statistics.andersonDarlingTest(groupData);
        
        // Check if override is active
        const overrideCheckbox = document.getElementById('override-normality');
        const isOverridden = overrideCheckbox && overrideCheckbox.checked;
        
        // Store results
        globalState.prerequisiteResults[paramName][groupId] = {
            normality: shapiroResult,
            kolmogorovSmirnov: ksResult,
            andersonDarling: adResult,
            overridden: isOverridden
        };
        
        // Store override in global state
        if (!globalState.assumptionOverrides.normality[paramName]) {
            globalState.assumptionOverrides.normality[paramName] = {};
        }
        globalState.assumptionOverrides.normality[paramName][groupId] = isOverridden;

        // Display results
        const resultDiv = document.createElement('div');
        resultDiv.className = 'prerequisite-result';
        resultDiv.style.marginBottom = '15px';
        resultDiv.style.padding = '15px';
        resultDiv.style.backgroundColor = 'var(--background-light)';
        resultDiv.style.borderRadius = '6px';
        
        let html = `<strong>${groupName} (n=${groupData.length}):</strong><br>`;
        
        // Display all test results
        if (!shapiroResult.error) {
            html += `• ${shapiroResult.test || 'Shapiro-Wilk'}: `;
            if (shapiroResult.W !== null) {
                html += `W = ${utils.formatNumber(shapiroResult.W, 4)}, `;
            }
            html += `p = ${utils.formatNumber(shapiroResult.pValue, 4)}`;
            html += shapiroResult.normal ? ' ✓' : ' ✗';
            if (shapiroResult.warning) {
                html += ` <em>(${shapiroResult.warning})</em>`;
            }
            html += '<br>';
        }
        
        if (!ksResult.error) {
            html += `• Kolmogorov-Smirnov: D = ${utils.formatNumber(ksResult.D, 4)}, p = ${utils.formatNumber(ksResult.pValue, 4)}`;
            html += ksResult.normal ? ' ✓' : ' ✗';
            html += '<br>';
        }
        
        if (!adResult.error) {
            html += `• Anderson-Darling: A² = ${utils.formatNumber(adResult.A2, 4)}, p = ${utils.formatNumber(adResult.pValue, 4)}`;
            html += adResult.normal ? ' ✓' : ' ✗';
            html += '<br>';
        }
        
        // Overall assessment - use Shapiro-Wilk as primary test
const shapiroNormal = shapiroResult.normal && !shapiroResult.error;
const overallNormal = isOverridden || shapiroNormal;

if (isOverridden) {
    html += '<br><strong style="color: var(--warning-color);">⚠️ Normality assumption manually overridden</strong>';
    resultDiv.className = 'prerequisite-result pass';
} else if (overallNormal) {
const testName = shapiroResult.test || 'Shapiro-Wilk';
html += `<br><strong style="color: var(--success-color);">✓ Normal distribution (${testName} test passed)</strong>`;    resultDiv.className = 'prerequisite-result pass';
} else {
const testName = shapiroResult.test || 'Shapiro-Wilk';
html += `<br><strong style="color: var(--danger-color);">✗ Not normally distributed (${testName} test failed)</strong>`;    resultDiv.className = 'prerequisite-result fail';
}

        resultDiv.innerHTML = html;
resultsContainer.appendChild(resultDiv);

// Update the stored result to use Shapiro-Wilk as primary
if (globalState.prerequisiteResults[paramName][groupId]) {
    globalState.prerequisiteResults[paramName][groupId].normality.normal = overallNormal;
}
    });
}

        /**
         * Check variance homogeneity between groups
         */
        function checkVarianceHomogeneity() {
            
            const paramName = document.getElementById('sig-parameter-select').value;
            if (!paramName) {
                utils.showError("Please select a parameter first.");
                return;
            }

            const paramType = globalState.columnTypes[paramName];
            if (!scaleTypes[paramType].numeric) {
                utils.showError("Variance test requires a numeric parameter (ordinal, interval, or ratio scale).");
                return;
            }

            // Get selected groups
            const selectedGroups = [];
            document.querySelectorAll('#sig-group-selection input:checked').forEach(checkbox => {
                selectedGroups.push(checkbox.value);
            });

            if (selectedGroups.length !== 2) {
                utils.showError("Variance homogeneity test requires exactly 2 groups.");
                return;
            }

            // Get data for both groups
            const group1Data = globalState.processedData[selectedGroups[0]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            const group2Data = globalState.processedData[selectedGroups[1]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            const result = statistics.fTest(group1Data, group2Data);

            // Store result
            if (!globalState.prerequisiteResults[paramName]) {
                globalState.prerequisiteResults[paramName] = {};
            }
            globalState.prerequisiteResults[paramName].varianceTest = result;

            // Display result
            const resultsContainer = document.getElementById('prerequisite-results');
            const resultDiv = document.createElement('div');
            resultDiv.className = `prerequisite-result ${result.equalVariances ? 'pass' : 'fail'}`;

            if (result.error) {
                resultDiv.innerHTML = `<strong>F-Test:</strong> ${result.error}`;
            } else {
                const group1Name = globalState.currentGroups[selectedGroups[0]].name;
                const group2Name = globalState.currentGroups[selectedGroups[1]].name;

                resultDiv.innerHTML = `
                    <strong>F-Test for Equal Variances:</strong><br>
                    ${group1Name} variance: ${utils.formatNumber(result.variance1, 4)}<br>
                    ${group2Name} variance: ${utils.formatNumber(result.variance2, 4)}<br>
                    F = ${utils.formatNumber(result.F, 4)}, p = ${utils.formatNumber(result.pValue, 4)}
                    ${result.equalVariances ?
                        ' ✓ Equal variances (p > 0.05)' :
                        ' ✗ Unequal variances (p ≤ 0.05) - Consider Welch\'s t-test'}
                `;
            }

            // Check if override is active
const overrideCheckbox = document.getElementById('override-homogeneity');
const isOverridden = overrideCheckbox && overrideCheckbox.checked;

// Store override in global state
globalState.assumptionOverrides.homogeneity[paramName] = isOverridden;

if (isOverridden) {
    resultDiv.innerHTML += '<br><strong style="color: var(--warning-color);">⚠️ Variance homogeneity assumption manually overridden</strong>';
    resultDiv.className = `prerequisite-result variance-test-result`;
}

            resultsContainer.appendChild(resultDiv);
        }

        /**
 * Check all prerequisites at once
 */
function checkAllPrerequisites() {
    const paramName = document.getElementById('sig-parameter-select').value;
    if (!paramName) {
        utils.showError("Please select a parameter first.");
        return;
    }

    const paramType = globalState.columnTypes[paramName];
    if (!scaleTypes[paramType].numeric) {
        utils.showError("Prerequisite tests require a numeric parameter (ordinal, interval, or ratio scale).");
        return;
    }

    const selectedGroups = [];
    document.querySelectorAll('#sig-group-selection input:checked').forEach(checkbox => {
        selectedGroups.push(checkbox.value);
    });

    if (selectedGroups.length === 0) {
        utils.showError("Please select at least one group.");
        return;
    }

    const resultsContainer = document.getElementById('prerequisite-results');
    resultsContainer.innerHTML = '';
    
    if (!globalState.prerequisiteResults[paramName]) {
        globalState.prerequisiteResults[paramName] = {};
    }

    // Check normality
    const headerDiv = document.createElement('div');
    headerDiv.innerHTML = '<h5>Normality Test Results:</h5>';
    resultsContainer.appendChild(headerDiv);
    checkNormality();
    
    // Check variance homogeneity if exactly 2 groups
    // Check variance homogeneity if exactly 2 groups
    if (selectedGroups.length === 2) {
        // Get data for both groups
        const group1Data = globalState.processedData[selectedGroups[0]]
            .map(row => utils.parseNumericValue(row[paramName]))
            .filter(val => !isNaN(val));
        
        const group2Data = globalState.processedData[selectedGroups[1]]
            .map(row => utils.parseNumericValue(row[paramName]))
            .filter(val => !isNaN(val));
        
        const varianceResult = statistics.fTest(group1Data, group2Data);
        
        // Store result
        if (!globalState.prerequisiteResults[paramName]) {
            globalState.prerequisiteResults[paramName] = {};
        }
        globalState.prerequisiteResults[paramName].varianceTest = varianceResult;
        
        // Display result
        const varianceDiv = document.createElement('div');
        varianceDiv.innerHTML = '<h5 style="margin-top: 20px;">Variance Homogeneity Test:</h5>';
        resultsContainer.appendChild(varianceDiv);
        
        const resultDiv = document.createElement('div');
        resultDiv.className = `prerequisite-result ${varianceResult.equalVariances ? 'pass' : 'fail'}`;
        resultDiv.style.marginBottom = '15px';
        resultDiv.style.padding = '15px';
        resultDiv.style.backgroundColor = 'var(--background-light)';
        resultDiv.style.borderRadius = '6px';
        
        if (varianceResult.error) {
            resultDiv.innerHTML = `<strong>F-Test:</strong> ${varianceResult.error}`;
        } else {
            const group1Name = globalState.currentGroups[selectedGroups[0]].name;
            const group2Name = globalState.currentGroups[selectedGroups[1]].name;
            
            let html = `<strong>F-Test for Equal Variances:</strong><br>`;
            html += `${group1Name} variance: ${utils.formatNumber(varianceResult.variance1, 4)}<br>`;
            html += `${group2Name} variance: ${utils.formatNumber(varianceResult.variance2, 4)}<br>`;
            html += `F = ${utils.formatNumber(varianceResult.F, 4)}, p = ${utils.formatNumber(varianceResult.pValue, 4)}<br>`;
            html += varianceResult.equalVariances ? 
                '<strong style="color: var(--success-color);">✓ Equal variances (p > 0.05)</strong>' : 
                '<strong style="color: var(--danger-color);">✗ Unequal variances (p ≤ 0.05) - Consider Welch\'s t-test</strong>';
            
            // Check if override is active
            const overrideCheckbox = document.getElementById('override-homogeneity');
            const isOverridden = overrideCheckbox && overrideCheckbox.checked;
            
            if (isOverridden) {
                html += '<br><strong style="color: var(--warning-color);">⚠️ Variance homogeneity assumption manually overridden</strong>';
            }
            
            resultDiv.innerHTML = html;
        }
        
        resultsContainer.appendChild(resultDiv);
    }
    
    // Automatically get test recommendation
    setTimeout(() => {
        const testSelector = new IntelligentTestSelector(statistics);
        const recommendation = testSelector.selectOptimalTest(paramName, selectedGroups);
        
        if (!recommendation.error) {
            displayTestRecommendation(recommendation, paramName, selectedGroups);
            
            // Pre-select the recommended test
            if (recommendation.recommended && recommendation.recommended.test) {
                document.getElementById('sig-test-type').value = recommendation.recommended.test.key;
            }
        }
    }, 100);
}

        /**
         * Handle file upload event
         */
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (globalState.isProcessing) {
                utils.showError("A file is already being processed. Please wait.");
                return;
            }

            utils.setLoading(true);
            utils.destroyAllCharts();

            const reader = new FileReader();

            reader.onload = function (e) {
                try {
                    // Detect delimiter and decimal separator
                    const firstLines = e.target.result.split('\n').slice(0, 5).join('\n');

                    // Use delimiter detection
                    globalState.csvDelimiter = utils.detectDelimiter(firstLines);

                    // Detect decimal separator by looking for numeric patterns
                    if (firstLines.match(/\d+,\d+/) && !firstLines.match(/\d+\.\d+/)) {
                        globalState.decimalSeparator = ',';
                    } else {
                        globalState.decimalSeparator = '.';
                    }

                    // Parse CSV with detected delimiter
                    Papa.parse(e.target.result, {
                        delimiter: globalState.csvDelimiter,
                        header: false,
                        skipEmptyLines: true,
                        complete: function (results) {
                            if (results.errors.length > 0) {
                                utils.showError("CSV parsing error: " + results.errors[0].message);
                                utils.setLoading(false);
                                return;
                            }

                            processCSVData(results.data);
                        },
                        error: function (error) {
                            utils.showError("Error reading CSV file: " + error.message);
                            utils.setLoading(false);
                        }
                    });
                } catch (error) {
                    utils.showError("Unexpected error processing file: " + error.message);
                    utils.setLoading(false);
                }
            };

            reader.onerror = function () {
                utils.showError("Error reading file");
                utils.setLoading(false);
            };

            reader.readAsText(file);
        }

        /**
         * Process CSV data after parsing with validation
         */
        function processCSVData(csvRows) {
            try {
                if (csvRows.length < 3) {
                    throw new Error("CSV file must contain at least 3 rows (header, types, data)");
                }

                // Extract header and types
                globalState.columnNames = csvRows[0];
                const typeRow = csvRows[1];

                // Map column types
                globalState.columnTypes = {};
                for (let i = 0; i < globalState.columnNames.length; i++) {
                    const columnName = globalState.columnNames[i];
                    const typeCode = typeRow[i] ? typeRow[i].toLowerCase().trim() : 'k';

                    if (['k', 'o', 'i', 'r'].includes(typeCode)) {
                        globalState.columnTypes[columnName] = typeCode;
                    } else {
                        globalState.columnTypes[columnName] = 'k'; // Default to nominal
                    }
                }

                // Process data rows
                globalState.rawData = [];
                for (let i = 2; i < csvRows.length; i++) {
                    const row = csvRows[i];
                    const dataRow = {};

                    for (let j = 0; j < globalState.columnNames.length; j++) {
                        const columnName = globalState.columnNames[j];
                        const cellValue = row[j] || '';
                        const columnType = globalState.columnTypes[columnName];

                        // Type-specific conversion
                        if (scaleTypes[columnType].numeric) {
                            dataRow[columnName] = utils.parseNumericValue(cellValue);
                        } else {
                            dataRow[columnName] = cellValue;
                        }
                    }

                    globalState.rawData.push(dataRow);
                }

                // Validate data consistency
                const validationIssues = validateDataConsistency();

                // Update UI
                displayDataPreview();
                initializeGroupDefinition();

                // Show containers
                document.getElementById('data-preview-container').style.display = 'block';
                document.getElementById('group-definition-container').style.display = 'block';

                // Show validation warnings if any
                if (validationIssues.length > 0) {
                    displayValidationWarnings(validationIssues);
                }

                utils.showSuccess(`File successfully loaded: ${globalState.rawData.length} records with ${globalState.columnNames.length} parameters.`);

            } catch (error) {
                utils.showError("Error processing CSV data: " + error.message);
            } finally {
                utils.setLoading(false);
            }
        }

        /**
         * Validate data consistency
         */
        function validateDataConsistency() {
            const issues = [];

            // Check column count consistency
            const expectedCount = globalState.columnNames.length;
            const inconsistentRows = [];

            globalState.rawData.forEach((row, index) => {
                const actualCount = Object.keys(row).length;
                if (actualCount !== expectedCount) {
                    inconsistentRows.push(index + 3);
                }
            });

            if (inconsistentRows.length > 0) {
                issues.push(`Inconsistent column count in rows: ${inconsistentRows.slice(0, 5).join(', ')}${inconsistentRows.length > 5 ? '...' : ''}`);
            }

            // Check data type consistency for numeric columns
            globalState.columnNames.forEach(colName => {
                const colType = globalState.columnTypes[colName];
                if (scaleTypes[colType].numeric) {
                    const invalidRows = [];
                    let validCount = 0;

                    globalState.rawData.forEach((row, index) => {
                        const value = row[colName];
                        if (value !== '' && value !== null && value !== undefined) {
                            if (isNaN(utils.parseNumericValue(value))) {
                                invalidRows.push(index + 3);
                            } else {
                                validCount++;
                            }
                        }
                    });

                    if (invalidRows.length > 0) {
                        issues.push(`Column "${colName}" (${scaleTypes[colType].name}) has non-numeric values in rows: ${invalidRows.slice(0, 5).join(', ')}${invalidRows.length > 5 ? '...' : ''}`);
                    }

                    if (validCount === 0) {
                        issues.push(`Column "${colName}" (${scaleTypes[colType].name}) contains no valid numeric data`);
                    }
                }
            });

            return issues;
        }

        /**
         * Display validation warnings
         */
        function displayValidationWarnings(issues) {
            const warningsDiv = document.getElementById('validation-warnings');
            const warningsList = document.getElementById('validation-warnings-list');

            warningsList.innerHTML = '';
            issues.forEach(issue => {
                const li = document.createElement('li');
                li.textContent = issue;
                warningsList.appendChild(li);
            });

            warningsDiv.style.display = 'block';
        }

        /**
         * Display data preview
         */
        function displayDataPreview() {
            const table = document.getElementById('data-preview-table');
            table.innerHTML = '';

            // Create header row
            const thead = document.createElement('thead');
            let headerRow = document.createElement('tr');

            globalState.columnNames.forEach(name => {
                const th = document.createElement('th');
                th.textContent = name;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            // Create type row
            headerRow = document.createElement('tr');
            globalState.columnNames.forEach(name => {
                const th = document.createElement('th');
                const type = globalState.columnTypes[name];
                const scaleInfo = utils.getScaleInfo(type);

                const typeSpan = document.createElement('span');
                typeSpan.textContent = scaleInfo.name;

                const badge = document.createElement('span');
                badge.className = `scale-badge ${scaleInfo.class}`;
                badge.textContent = type.toUpperCase();

                th.appendChild(typeSpan);
                th.appendChild(badge);
                th.style.fontStyle = 'italic';
                th.style.fontSize = '12px';
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create data rows (paginated)
            updateDataPagination();

            // Update summary
            const summary = document.getElementById('data-summary');
            const scaleTypeCounts = { k: 0, o: 0, i: 0, r: 0 };
            globalState.columnNames.forEach(name => {
                const type = globalState.columnTypes[name];
                if (scaleTypeCounts.hasOwnProperty(type)) {
                    scaleTypeCounts[type]++;
                }
            });

            let summaryText = `📊 <strong>${globalState.rawData.length}</strong> records with <strong>${globalState.columnNames.length}</strong> parameters loaded`;
            summaryText += ` (${scaleTypeCounts.k} nominal, ${scaleTypeCounts.o} ordinal, ${scaleTypeCounts.i} interval, ${scaleTypeCounts.r} ratio)`;

            summary.innerHTML = summaryText;
        }

        /**
         * Update data pagination
         */
        function updateDataPagination() {
            // Get pagination settings
            const rowsPerPage = parseInt(document.getElementById('rows-per-page').value);
            globalState.rowsPerPage = rowsPerPage;

            // Calculate total pages
            const totalPages = Math.ceil(globalState.rawData.length / rowsPerPage);

            // Ensure current page is valid
            if (globalState.currentPage > totalPages) {
                globalState.currentPage = totalPages;
            }
            if (globalState.currentPage < 1) {
                globalState.currentPage = 1;
            }

            // Update table content
            const table = document.getElementById('data-preview-table');
            const tbody = document.createElement('tbody');

            const startIndex = (globalState.currentPage - 1) * rowsPerPage;
            const endIndex = Math.min(startIndex + rowsPerPage, globalState.rawData.length);

            for (let i = startIndex; i < endIndex; i++) {
                const row = globalState.rawData[i];
                const tr = document.createElement('tr');

                globalState.columnNames.forEach(columnName => {
                    const td = document.createElement('td');
                    const cellValue = row[columnName];
                    const columnType = globalState.columnTypes[columnName];

                    if (scaleTypes[columnType].numeric && !isNaN(cellValue)) {
                        td.textContent = utils.formatNumber(cellValue, 2);
                    } else {
                        td.textContent = cellValue || '';
                    }

                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            }

            // Replace tbody if it exists, otherwise append new one
            const existingTbody = table.querySelector('tbody');
            if (existingTbody) {
                table.removeChild(existingTbody);
            }
            table.appendChild(tbody);

            // Update pagination controls
            updatePaginationControls(totalPages);
        }

        /**
         * Update pagination control buttons
         */
        function updatePaginationControls(totalPages) {
            const paginationContainer = document.getElementById('data-pagination');
            paginationContainer.innerHTML = '';

            // "First" and "Previous" buttons
            const firstBtn = document.createElement('button');
            firstBtn.textContent = '««';
            firstBtn.disabled = globalState.currentPage === 1;
            firstBtn.addEventListener('click', () => {
                globalState.currentPage = 1;
                updateDataPagination();
            });
            paginationContainer.appendChild(firstBtn);

            const prevBtn = document.createElement('button');
            prevBtn.textContent = '«';
            prevBtn.disabled = globalState.currentPage === 1;
            prevBtn.addEventListener('click', () => {
                globalState.currentPage--;
                updateDataPagination();
            });
            paginationContainer.appendChild(prevBtn);

            // Page number buttons
            const maxButtons = 5;
            let startPage = Math.max(1, globalState.currentPage - Math.floor(maxButtons / 2));
            let endPage = Math.min(totalPages, startPage + maxButtons - 1);

            // Adjust if we're near the end
            if (endPage - startPage + 1 < maxButtons && startPage > 1) {
                startPage = Math.max(1, endPage - maxButtons + 1);
            }

            for (let i = startPage; i <= endPage; i++) {
                const pageBtn = document.createElement('button');
                pageBtn.textContent = i;
                pageBtn.className = i === globalState.currentPage ? 'active' : '';
                pageBtn.addEventListener('click', () => {
                    globalState.currentPage = i;
                    updateDataPagination();
                });
                paginationContainer.appendChild(pageBtn);
            }

            // "Next" and "Last" buttons
            const nextBtn = document.createElement('button');
            nextBtn.textContent = '»';
            nextBtn.disabled = globalState.currentPage === totalPages;
            nextBtn.addEventListener('click', () => {
                globalState.currentPage++;
                updateDataPagination();
            });
            paginationContainer.appendChild(nextBtn);

            const lastBtn = document.createElement('button');
            lastBtn.textContent = '»»';
            lastBtn.disabled = globalState.currentPage === totalPages;
            lastBtn.addEventListener('click', () => {
                globalState.currentPage = totalPages;
                updateDataPagination();
            });
            paginationContainer.appendChild(lastBtn);

            // Page info
            const pageInfo = document.createElement('span');
            pageInfo.textContent = ` Page ${globalState.currentPage} of ${totalPages} `;
            pageInfo.style.margin = '0 10px';
            paginationContainer.appendChild(pageInfo);
        }

        /**
         * Export data preview as CSV
         */
        function exportDataPreview() {
            if (globalState.rawData.length === 0) {
                utils.showError("No data to export.");
                return;
            }

            let csvContent = '\uFEFF'; // UTF-8 BOM for Excel

            // Headers
            csvContent += globalState.columnNames.join(globalState.csvDelimiter) + '\n';

            // Type row
            csvContent += globalState.columnNames.map(name => globalState.columnTypes[name]).join(globalState.csvDelimiter) + '\n';

            // Data rows
            globalState.rawData.forEach(row => {
                let rowData = globalState.columnNames.map(columnName => {
                    let cellValue = '';
                    const value = row[columnName];
                    const columnType = globalState.columnTypes[columnName];

                    if (value !== undefined && value !== null) {
                        if (scaleTypes[columnType].numeric && !isNaN(value)) {
                            cellValue = utils.formatNumberForCSV(value);
                        } else {
                            cellValue = String(value);
                        }

                        // Escape delimiter in data
                        if (cellValue.includes(globalState.csvDelimiter) || cellValue.includes('"')) {
                            cellValue = `"${cellValue.replace(/"/g, '""')}"`;
                        }
                    }

                    return cellValue;
                }).join(globalState.csvDelimiter);

                csvContent += rowData + '\n';
            });

            //Prerequisite test results
            if (Object.keys(globalState.prerequisiteResults).length > 0) {
                csvContent += '\nPREREQUITE TEST RESULTS\n';
                csvContent += 'Parameter' + globalState.csvDelimiter + 'Group' + globalState.csvDelimiter + 'Normality_Test' + globalState.csvDelimiter + 'W_Statistic' + globalState.csvDelimiter + 'p_value' + globalState.csvDelimiter + 'Normal' + globalState.csvDelimiter + 'Overridden\n';
                
                Object.entries(globalState.prerequisiteResults).forEach(([paramName, results]) => {
                    Object.entries(results).forEach(([groupId, result]) => {
                        if (result.normality && globalState.currentGroups[groupId]) {
                            csvContent += paramName + globalState.csvDelimiter;
                            csvContent += globalState.currentGroups[groupId].name + globalState.csvDelimiter;
                            csvContent += (result.normality.test || 'Shapiro-Wilk') + globalState.csvDelimiter;
                            csvContent += (result.normality.W ? utils.formatNumberForCSV(result.normality.W) : '') + globalState.csvDelimiter;
                            csvContent += (result.normality.pValue ? utils.formatNumberForCSV(result.normality.pValue) : '') + globalState.csvDelimiter;
                            csvContent += result.normality.normal + globalState.csvDelimiter;
                            csvContent += (result.overridden || false) + '\n';
                        }
                    });
                });
                csvContent += '\n';
            }

        // Create download with timestamp
            const timestamp = utils.getTimestamp();
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `sra-${timestamp}-data-export.csv`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            URL.revokeObjectURL(url);
            utils.showSuccess('Data successfully exported!');
        }

        /**
         * Initialize group definition interface
         */
        function initializeGroupDefinition() {
            const container = document.getElementById('parameter-groups');
            container.innerHTML = '';

            globalState.groupDefinitions = [];
            globalState.currentGroups = {};
            globalState.processedData = {};
            globalState.prerequisiteResults = {};
            globalState.parameterConstellations = [];

            // Clear constellation list
            document.getElementById('constellation-list').innerHTML = '';

            // Add first group
            addNewGroup();
        }

        /**
         * Add a new parameter constellation
         */
        function addNewConstellation() {
            const constellationList = document.getElementById('constellation-list');
            const constellationIndex = globalState.parameterConstellations.length;

            const constellationDiv = document.createElement('div');
            constellationDiv.className = 'constellation-item';
            constellationDiv.dataset.constellationIndex = constellationIndex;

            // Constellation header
            const header = document.createElement('div');
            header.className = 'constellation-header';

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'constellation-name';
            nameInput.value = `Constellation ${constellationIndex + 1}`;
            nameInput.placeholder = 'Enter constellation name';

            // Add event listener to update state when name changes
            nameInput.addEventListener('input', () => {
                updateConstellationState();
            });

            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => {
                constellationList.removeChild(constellationDiv);
                updateConstellationIndices();
            });

            header.appendChild(nameInput);
            header.appendChild(removeBtn);
            constellationDiv.appendChild(header);

            // Parameter container
            const paramContainer = document.createElement('div');
            paramContainer.className = 'parameter-controls';
            constellationDiv.appendChild(paramContainer);

            // Add first parameter control with "All Data" selected
            addConstellationParameterControl(paramContainer, true);

            // Add parameter button
            const addParamBtn = document.createElement('button');
            addParamBtn.className = 'btn btn-accent btn-small';
            addParamBtn.textContent = 'Add Parameter';
            addParamBtn.addEventListener('click', () => {
                addConstellationParameterControl(paramContainer, false);
            });
            constellationDiv.appendChild(addParamBtn);

            constellationList.appendChild(constellationDiv);

            // Update constellation in state
            updateConstellationState();
        }

        /**
         * Add a parameter control to a constellation
         */
        function addConstellationParameterControl(container, selectAllData = false) {
            const controlDiv = document.createElement('div');
            controlDiv.className = 'parameter-control';

            // Parameter select
            const paramLabel = document.createElement('label');
            paramLabel.textContent = 'Parameter:';
            controlDiv.appendChild(paramLabel);

            const paramSelect = document.createElement('select');
            paramSelect.className = 'param-select';

            // Add "All Data" option
            const allDataOption = document.createElement('option');
            allDataOption.value = '__all_data__';
            allDataOption.textContent = 'All Data';
            if (selectAllData) {
                allDataOption.selected = true;
            }
            paramSelect.appendChild(allDataOption);

            // Default "no parameter" option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select parameter...';
            paramSelect.appendChild(defaultOption);

            // Add available parameters
            globalState.columnNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                const scaleInfo = utils.getScaleInfo(globalState.columnTypes[name]);
                option.textContent = `${name} (${scaleInfo.name})`;
                paramSelect.appendChild(option);
            });

            controlDiv.appendChild(paramSelect);

            // Condition container
            const conditionContainer = document.createElement('div');
            conditionContainer.className = 'condition-controls';
            controlDiv.appendChild(conditionContainer);

            // Distribution info container
            const groupDistribution = document.createElement('div');
            groupDistribution.className = 'group-distribution';
            groupDistribution.style.display = 'none';
            controlDiv.appendChild(groupDistribution);

            // Info container
            const infoDiv = document.createElement('div');
            infoDiv.className = 'parameter-info';
            controlDiv.appendChild(infoDiv);

            // Set up condition controls for "All Data" if selected
            if (selectAllData) {
                updateConditionControls(conditionContainer, infoDiv, groupDistribution, '__all_data__');
            }

            // Event listener for parameter change
            paramSelect.addEventListener('change', () => {
                const selectedParam = paramSelect.value;
                updateConditionControls(conditionContainer, infoDiv, groupDistribution, selectedParam);
                updateConstellationState(); // Update state when parameter changes
            });

            // Add change listeners to update constellation state when conditions change
            conditionContainer.addEventListener('change', () => {
                updateConstellationState();
            });

            conditionContainer.addEventListener('input', () => {
                updateConstellationState();
            });

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove Parameter';
            removeBtn.style.marginTop = '10px';
            removeBtn.addEventListener('click', () => {
                container.removeChild(controlDiv);
                updateConstellationState(); // Update state when parameter is removed
            });
            controlDiv.appendChild(removeBtn);

            container.appendChild(controlDiv);
        }

        /**
         * Update constellation indices after removal
         */
        function updateConstellationIndices() {
            const constellations = document.querySelectorAll('.constellation-item');
            constellations.forEach((constellation, index) => {
                constellation.dataset.constellationIndex = index;
                const nameInput = constellation.querySelector('.constellation-name');
                // Only update the name if it still has the default pattern
                if (nameInput.value.match(/^Constellation \d+$/)) {
                    nameInput.value = `Constellation ${index + 1}`;
                }
            });
            updateConstellationState();
        }

        /**
         * Update constellation state in global state
         */
        function updateConstellationState() {
            globalState.parameterConstellations = [];

            const constellations = document.querySelectorAll('.constellation-item');

            for (let constIndex = 0; constIndex < constellations.length; constIndex++) {
                const constellation = constellations[constIndex];
                const nameInput = constellation.querySelector('.constellation-name');
                const userEnteredName = nameInput ? nameInput.value.trim() : '';

                if (!userEnteredName) {
                    continue;
                }

                const conditions = [];
                const controlDivs = constellation.querySelectorAll('.parameter-control');

                for (let controlIndex = 0; controlIndex < controlDivs.length; controlIndex++) {
                    const controlDiv = controlDivs[controlIndex];
                    const paramSelect = controlDiv.querySelector('.param-select');

                    if (!paramSelect || !paramSelect.value) {
                        continue;
                    }

                    const paramName = paramSelect.value;

                    if (paramName === '__all_data__') {
                        conditions.push({
                            parameter: '__all_data__',
                            operator: '=',
                            value: true,
                            type: 'special'
                        });
                        continue;
                    }

                    const operatorSelect = controlDiv.querySelector('.condition-operator');
                    const valueElement = controlDiv.querySelector('.condition-value');

                    if (!operatorSelect || !valueElement) {
                        continue;
                    }

                    const paramType = globalState.columnTypes[paramName];
                    let value;

                    if (scaleTypes[paramType] && scaleTypes[paramType].numeric) {
                        value = utils.parseNumericValue(valueElement.value);
                        if (isNaN(value)) {
                            continue;
                        }
                    } else {
                        value = valueElement.value;
                        if (!value) {
                            continue;
                        }
                    }

                    conditions.push({
                        parameter: paramName,
                        operator: operatorSelect.value,
                        value: value,
                        type: paramType
                    });
                }

                if (conditions.length > 0) {
                    globalState.parameterConstellations.push({
                        name: userEnteredName,
                        conditions: conditions
                    });
                }
            }

            updateConstellationSelectors();
        }

        /**
         * Update constellation selectors in groups and fourfold table
         */
        function updateConstellationSelectors() {
            // Update fourfold table selectors
            const fourfoldSelectors = ['fourfold-constellation-1', 'fourfold-constellation-2'];
            fourfoldSelectors.forEach(selectorId => {
                const selector = document.getElementById(selectorId);
                if (selector) {
                    const currentValue = selector.value;
                    selector.innerHTML = '<option value="">Select constellation</option>';

                    globalState.parameterConstellations.forEach((constellation) => {
                        const option = document.createElement('option');
                        option.value = constellation.name;
                        option.textContent = constellation.name;
                        selector.appendChild(option);
                    });

                    // Restore selection if still valid
                    if (currentValue && Array.from(selector.options).some(opt => opt.value === currentValue)) {
                        selector.value = currentValue;
                    }
                }
            });
        }

        /**
         * Add a new parameter group
         */
        function addNewGroup() {
            const container = document.getElementById('parameter-groups');
            const groupIndex = container.children.length;

            const groupDiv = document.createElement('div');
            groupDiv.className = 'parameter-group';
            groupDiv.dataset.groupIndex = groupIndex;

            // Group header
            const header = document.createElement('div');
            header.className = 'parameter-group-title';

            // Editable group name input
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'group-name-input';
            nameInput.value = `Subgroup ${groupIndex + 1}`;
            nameInput.placeholder = 'Enter group name';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', () => {
                if (container.children.length > 1) {
                    container.removeChild(groupDiv);
                    updateGroupNumbers();
                } else {
                    utils.showError("At least one subgroup must be defined.");
                }
            });

            header.appendChild(nameInput);
            header.appendChild(removeBtn);
            groupDiv.appendChild(header);

            // Group controls (color and inclusion)
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'group-controls';

            // Color control
            const colorControl = document.createElement('div');
            colorControl.className = 'group-color-control';

            const colorLabel = document.createElement('label');
            colorLabel.textContent = 'Color:';
            colorControl.appendChild(colorLabel);

            const colorSelect = document.createElement('select');
            colorSelect.className = 'color-preset-selector';

            // Add preset colors
            groupColors.forEach((color, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = color.name;
                colorSelect.appendChild(option);
            });

            // Add custom option
            const customOption = document.createElement('option');
            customOption.value = 'custom';
            customOption.textContent = 'Custom';
            colorSelect.appendChild(customOption);

            // Set default color based on group index
            colorSelect.value = groupIndex % groupColors.length;

            colorControl.appendChild(colorSelect);

            // Color preview
            const colorPreview = document.createElement('div');
            colorPreview.className = 'color-preview';
            colorPreview.style.backgroundColor = groupColors[groupIndex % groupColors.length].bg;
            colorControl.appendChild(colorPreview);

            // Custom color input
            const customColorInput = document.createElement('input');
            customColorInput.type = 'text';
            customColorInput.className = 'custom-color-input';
            customColorInput.placeholder = '#RRGGBB';
            customColorInput.style.display = 'none';
            colorControl.appendChild(customColorInput);

            // Color change handler
            colorSelect.addEventListener('change', () => {
                if (colorSelect.value === 'custom') {
                    customColorInput.style.display = 'block';
                    customColorInput.focus();
                } else {
                    customColorInput.style.display = 'none';
                    const colorIndex = parseInt(colorSelect.value);
                    colorPreview.style.backgroundColor = groupColors[colorIndex].bg;
                }
            });

            customColorInput.addEventListener('input', () => {
                const hexRegex = /^#[0-9A-F]{6}$/i;
                if (hexRegex.test(customColorInput.value)) {
                    colorPreview.style.backgroundColor = customColorInput.value + 'B3'; // Add transparency
                }
            });

            controlsDiv.appendChild(colorControl);

            // Include in analysis checkbox
            const includeCheckbox = document.createElement('input');
            includeCheckbox.type = 'checkbox';
            includeCheckbox.id = `include-group-${groupIndex}`;
            includeCheckbox.checked = true;
            includeCheckbox.addEventListener('change', () => {
                groupDiv.classList.toggle('excluded', !includeCheckbox.checked);
            });

            const includeLabel = document.createElement('label');
            includeLabel.htmlFor = `include-group-${groupIndex}`;
            includeLabel.textContent = 'Include in analysis';

            const includeContainer = document.createElement('div');
            includeContainer.className = 'checkbox-container';
            includeContainer.appendChild(includeCheckbox);
            includeContainer.appendChild(includeLabel);

            controlsDiv.appendChild(includeContainer);

            groupDiv.appendChild(controlsDiv);

            // Not in previous groups checkbox
            const notInPreviousDiv = document.createElement('div');
            notInPreviousDiv.className = 'not-in-previous-checkbox';

            const notInPreviousCheckbox = document.createElement('input');
            notInPreviousCheckbox.type = 'checkbox';
            notInPreviousCheckbox.id = `not-in-previous-${groupIndex}`;
            notInPreviousCheckbox.checked = groupIndex > 0;

            const notInPreviousLabel = document.createElement('label');
            notInPreviousLabel.htmlFor = `not-in-previous-${groupIndex}`;
            notInPreviousLabel.textContent = 'Exclude records that are in previous groups';

            notInPreviousDiv.appendChild(notInPreviousCheckbox);
            notInPreviousDiv.appendChild(notInPreviousLabel);

            if (groupIndex === 0) {
                notInPreviousDiv.style.display = 'none';
            }

            groupDiv.appendChild(notInPreviousDiv);

            // Condition type selector
            const conditionTypeDiv = document.createElement('div');
            conditionTypeDiv.className = 'condition-type-selector';

            const individualBtn = document.createElement('button');
            individualBtn.textContent = 'Add Individual Condition';
            individualBtn.className = 'active';
            individualBtn.addEventListener('click', () => {
                addParameterControl(paramContainer);
            });

            const constellationBtn = document.createElement('button');
            constellationBtn.textContent = 'Add Constellation';
            constellationBtn.addEventListener('click', () => {
                addConstellationToGroup(paramContainer);
            });

            conditionTypeDiv.appendChild(individualBtn);
            conditionTypeDiv.appendChild(constellationBtn);
            groupDiv.appendChild(conditionTypeDiv);

            // Parameter container
            const paramContainer = document.createElement('div');
            paramContainer.className = 'parameter-controls';
            groupDiv.appendChild(paramContainer);

            // Add first parameter control with "All Data" selected by default
            addParameterControl(paramContainer, true);

            container.appendChild(groupDiv);
        }

        /**
         * Add a constellation selector to a group
         */
        function addConstellationToGroup(container) {
            if (globalState.parameterConstellations.length === 0) {
                utils.showError("Please define at least one parameter constellation first.");
                return;
            }

            const controlDiv = document.createElement('div');
            controlDiv.className = 'parameter-control constellation-reference';

            const label = document.createElement('label');
            label.textContent = 'Constellation:';
            controlDiv.appendChild(label);

            // Negation checkbox
            const negationCheckbox = document.createElement('input');
            negationCheckbox.type = 'checkbox';
            negationCheckbox.className = 'negation-checkbox';
            negationCheckbox.addEventListener('change', () => {
                controlDiv.classList.toggle('negated', negationCheckbox.checked);
                updateConstellationDisplay();
            });

            const negationLabel = document.createElement('label');
            negationLabel.textContent = 'NOT';
            negationLabel.style.marginRight = '10px';

            const negationContainer = document.createElement('span');
            negationContainer.appendChild(negationCheckbox);
            negationContainer.appendChild(negationLabel);
            controlDiv.appendChild(negationContainer);

            const constellationSelect = document.createElement('select');
            constellationSelect.className = 'constellation-select';

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select constellation...';
            constellationSelect.appendChild(defaultOption);

            globalState.parameterConstellations.forEach((constellation, index) => {
                const option = document.createElement('option');
                option.value = constellation.name;
                option.textContent = constellation.name;
                constellationSelect.appendChild(option);
            });

            controlDiv.appendChild(constellationSelect);

            // Display constellation conditions
            const conditionsDisplay = document.createElement('div');
            conditionsDisplay.className = 'constellation-conditions';
            conditionsDisplay.style.marginTop = '10px';
            conditionsDisplay.style.fontSize = '0.9em';
            conditionsDisplay.style.color = '#666';
            controlDiv.appendChild(conditionsDisplay);

            const updateConstellationDisplay = () => {
                const selectedConstellation = globalState.parameterConstellations.find(
                    c => c.name === constellationSelect.value
                );

                if (selectedConstellation) {
                    const conditionsText = selectedConstellation.conditions.map(c => {
                        if (c.parameter === '__all_data__') {
                            return 'All Data';
                        }
                        return `${c.parameter} ${c.operator} ${c.value}`;
                    }).join(' AND ');

                    const prefix = negationCheckbox.checked ? '<strong>NOT</strong> (' : '';
                    const suffix = negationCheckbox.checked ? ')' : '';
                    conditionsDisplay.innerHTML = `<strong>Conditions:</strong> ${prefix}${conditionsText}${suffix}`;
                } else {
                    conditionsDisplay.innerHTML = '';
                }
            };

            constellationSelect.addEventListener('change', updateConstellationDisplay);

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove Constellation';
            removeBtn.style.marginTop = '10px';
            removeBtn.addEventListener('click', () => {
                container.removeChild(controlDiv);
            });
            controlDiv.appendChild(removeBtn);

            container.appendChild(controlDiv);
        }

        /**
         * Add a parameter control to a group
         */
        function addParameterControl(container, selectAllData = false) {
            const controlDiv = document.createElement('div');
            controlDiv.className = 'parameter-control';

            // Parameter select
            const paramLabel = document.createElement('label');
            paramLabel.textContent = 'Parameter:';
            controlDiv.appendChild(paramLabel);

            const paramSelect = document.createElement('select');
            paramSelect.className = 'param-select';

            // Add "All Data" option
            const allDataOption = document.createElement('option');
            allDataOption.value = '__all_data__';
            allDataOption.textContent = 'All Data';
            if (selectAllData) {
                allDataOption.selected = true;
            }
            paramSelect.appendChild(allDataOption);

            // Default "no parameter" option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select parameter...';
            paramSelect.appendChild(defaultOption);

            // Add available parameters
            globalState.columnNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                const scaleInfo = utils.getScaleInfo(globalState.columnTypes[name]);
                option.textContent = `${name} (${scaleInfo.name})`;
                paramSelect.appendChild(option);
            });

            controlDiv.appendChild(paramSelect);

            // Condition container
            const conditionContainer = document.createElement('div');
            conditionContainer.className = 'condition-controls';
            controlDiv.appendChild(conditionContainer);

            // Distribution info container
            const groupDistribution = document.createElement('div');
            groupDistribution.className = 'group-distribution';
            groupDistribution.style.display = 'none';
            controlDiv.appendChild(groupDistribution);

            // Info container
            const infoDiv = document.createElement('div');
            infoDiv.className = 'parameter-info';
            controlDiv.appendChild(infoDiv);

            // Set up condition controls for "All Data" if selected
            if (selectAllData) {
                updateConditionControls(conditionContainer, infoDiv, groupDistribution, '__all_data__');
            }

            // Event listener for parameter change
            paramSelect.addEventListener('change', () => {
                const selectedParam = paramSelect.value;
                updateConditionControls(conditionContainer, infoDiv, groupDistribution, selectedParam);
            });

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove Parameter';
            removeBtn.style.marginTop = '10px';
            removeBtn.addEventListener('click', () => {
                container.removeChild(controlDiv);
            });
            controlDiv.appendChild(removeBtn);

            container.appendChild(controlDiv);
        }

        /**
         * Update condition controls based on selected parameter
         */
        function updateConditionControls(container, infoDiv, distributionDiv, paramName) {
            container.innerHTML = '';
            infoDiv.innerHTML = '';
            distributionDiv.innerHTML = '';
            distributionDiv.style.display = 'none';

            if (!paramName) return;

            // Handle "All Data" selection
            if (paramName === '__all_data__') {
                infoDiv.innerHTML = '<strong>All Data Selected:</strong><br>This condition will include all records in the dataset.';
                distributionDiv.innerHTML = `
                    <div><strong>Distribution:</strong></div>
                    <div>All records: ${globalState.rawData.length} (100%)</div>
                    <div class="distribution-bar">
                        <div class="distribution-fill" style="width: 100%"></div>
                    </div>
                `;
                distributionDiv.style.display = 'block';
                return;
            }

            const paramType = globalState.columnTypes[paramName];
            const scaleInfo = scaleTypes[paramType];

            if (scaleInfo.numeric) {
                // Numeric parameter
                const operatorSelect = document.createElement('select');
                operatorSelect.className = 'condition-operator';

                ['<', '<=', '=', '>=', '>', '!='].forEach(op => {
                    const option = document.createElement('option');
                    option.value = op;
                    option.textContent = op;
                    operatorSelect.appendChild(option);
                });

                const valueInput = document.createElement('input');
                valueInput.type = 'number';
                valueInput.className = 'condition-value';
                valueInput.step = 'any';
                valueInput.placeholder = 'Enter value';

                container.appendChild(operatorSelect);
                container.appendChild(valueInput);

                operatorSelect.addEventListener('change', updateConstellationState);
                valueInput.addEventListener('change', updateConstellationState);

                // Calculate statistics and show info
                const values = globalState.rawData
                    .map(row => utils.parseNumericValue(row[paramName]))
                    .filter(val => !isNaN(val));

                if (values.length > 0) {
                    const stats = statistics.calculate(values);

                    // Set median as default value
                    if (paramType === 'o') {
                        valueInput.value = Math.round(stats.median);
                    } else {
                        valueInput.value = stats.median.toFixed(2);
                    }

                    let infoText = `<strong>Statistics for ${paramName} (${scaleInfo.name}):</strong><br>`;

                    if (paramType === 'o') {
                        infoText += `Min: ${stats.min} | Max: ${stats.max}<br>`;
                        infoText += `Median: ${stats.median.toFixed(2)}`;
                    } else {
                        infoText += `Min: ${stats.min.toFixed(2)} | Max: ${stats.max.toFixed(2)}<br>`;
                        infoText += `Median: ${stats.median.toFixed(2)} | Mean: ${stats.mean.toFixed(2)}`;
                        if (paramType === 'r' && stats.cv !== null) {
                            infoText += ` | CV: ${stats.cv.toFixed(1)}%`;
                        }
                    }

                    infoDiv.innerHTML = infoText;

                    // Setup threshold distribution update
                    valueInput.addEventListener('input', () => {
                        updateNumericDistribution(paramName, operatorSelect.value, utils.parseNumericValue(valueInput.value), distributionDiv);
                    });

                    operatorSelect.addEventListener('change', () => {
                        updateNumericDistribution(paramName, operatorSelect.value, utils.parseNumericValue(valueInput.value), distributionDiv);
                    });

                    // Initial distribution update
                    updateNumericDistribution(paramName, operatorSelect.value, utils.parseNumericValue(valueInput.value), distributionDiv);
                }
            } else if (paramType === 'k') {
                // Categorical parameter
                const operatorSelect = document.createElement('select');
                operatorSelect.className = 'condition-operator';

                const equalOption = document.createElement('option');
                equalOption.value = '=';
                equalOption.textContent = 'is';
                operatorSelect.appendChild(equalOption);

                const notEqualOption = document.createElement('option');
                notEqualOption.value = '!=';
                notEqualOption.textContent = 'is not';
                operatorSelect.appendChild(notEqualOption);

                const valueSelect = document.createElement('select');
                valueSelect.className = 'condition-value';

                // Collect unique values
                const uniqueValues = [...new Set(globalState.rawData
                    .map(row => row[paramName])
                    .filter(val => val !== null && val !== undefined && val !== ''))];

                uniqueValues.sort().forEach(value => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    valueSelect.appendChild(option);
                });

                container.appendChild(operatorSelect);
                container.appendChild(valueSelect);

                operatorSelect.addEventListener('change', updateConstellationState);
                valueSelect.addEventListener('change', updateConstellationState);

                infoDiv.innerHTML = `
                    <strong>Categories for ${paramName} (${scaleInfo.name}):</strong><br>
                    ${uniqueValues.length} unique values: ${uniqueValues.slice(0, 5).join(', ')}${uniqueValues.length > 5 ? '...' : ''}
                `;

                // Setup category distribution update
                valueSelect.addEventListener('change', () => {
                    updateCategoryDistribution(paramName, operatorSelect.value, valueSelect.value, distributionDiv);
                });

                operatorSelect.addEventListener('change', () => {
                    updateCategoryDistribution(paramName, operatorSelect.value, valueSelect.value, distributionDiv);
                });

                // Initial distribution update
                if (uniqueValues.length > 0) {
                    updateCategoryDistribution(paramName, operatorSelect.value, uniqueValues[0], distributionDiv);
                }
            }
        }

        /**
         * Update distribution info for numeric parameter
         */
        function updateNumericDistribution(paramName, operator, threshold, container) {
            if (isNaN(threshold)) {
                container.style.display = 'none';
                return;
            }

            const values = globalState.rawData
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            if (values.length === 0) {
                container.style.display = 'none';
                return;
            }

            // Count values matching the condition
            let matchCount = 0;

            values.forEach(v => {
                if (utils.compareNumbers(v, threshold, operator)) {
                    matchCount++;
                }
            });

            const totalCount = values.length;
            const matchPercent = (matchCount / totalCount * 100).toFixed(1);
            const inversePercent = (100 - parseFloat(matchPercent)).toFixed(1);

            container.innerHTML = `
                <div><strong>Distribution for ${paramName} ${operator} ${threshold}:</strong></div>
                <div>Matching: ${matchCount} records (${matchPercent}%)</div>
                <div class="distribution-bar">
                    <div class="distribution-fill" style="width: ${matchPercent}%"></div>
                </div>
                <div>Non-matching: ${totalCount - matchCount} records (${inversePercent}%)</div>
            `;

            container.style.display = 'block';
        }

        /**
         * Update distribution info for categorical parameter
         */
        function updateCategoryDistribution(paramName, operator, category, container) {
            if (!category) {
                container.style.display = 'none';
                return;
            }

            const values = globalState.rawData
                .map(row => row[paramName])
                .filter(val => val !== null && val !== undefined);

            if (values.length === 0) {
                container.style.display = 'none';
                return;
            }

            // Count values matching the condition
            let matchCount = 0;

            switch (operator) {
                case '=': matchCount = values.filter(v => String(v) === String(category)).length; break;
                case '!=': matchCount = values.filter(v => String(v) !== String(category)).length; break;
            }

            const totalCount = values.length;
            const matchPercent = (matchCount / totalCount * 100).toFixed(1);
            const inversePercent = (100 - parseFloat(matchPercent)).toFixed(1);

            container.innerHTML = `
                <div><strong>Distribution for ${paramName} ${operator} "${category}":</strong></div>
                <div>Matching: ${matchCount} records (${matchPercent}%)</div>
                <div class="distribution-bar">
                    <div class="distribution-fill" style="width: ${matchPercent}%"></div>
                </div>
                <div>Non-matching: ${totalCount - matchCount} records (${inversePercent}%)</div>
            `;

            container.style.display = 'block';
        }

        /**
         * Update group numbers after removing a group
         */
        function updateGroupNumbers() {
            const groups = document.querySelectorAll('.parameter-group');
            groups.forEach((group, index) => {
                group.dataset.groupIndex = index;
                const nameInput = group.querySelector('.group-name-input');
                // Only update if it still has the default name pattern
                if (nameInput.value.match(/^Subgroup \d+$/)) {
                    nameInput.value = `Subgroup ${index + 1}`;
                }

                // Update not-in-previous checkbox
                const notInPreviousDiv = group.querySelector('.not-in-previous-checkbox');
                const notInPreviousCheckbox = group.querySelector('input[type="checkbox"][id^="not-in-previous"]');
                if (notInPreviousCheckbox) {
                    notInPreviousCheckbox.id = `not-in-previous-${index}`;
                }
                if (notInPreviousDiv) {
                    notInPreviousDiv.style.display = index === 0 ? 'none' : 'block';
                }

                // Update include checkbox
                const includeCheckbox = group.querySelector('input[type="checkbox"][id^="include-group"]');
                if (includeCheckbox) {
                    includeCheckbox.id = `include-group-${index}`;
                    const includeLabel = group.querySelector(`label[for^="include-group"]`);
                    if (includeLabel) {
                        includeLabel.htmlFor = `include-group-${index}`;
                    }
                }
            });
        }

        /**
         * Apply groups and analyze data
         */
        function applyGroupsAndAnalyze() {
            if (globalState.isProcessing) {
                utils.showError("An analysis is already in progress. Please wait.");
                return;
            }

            utils.setLoading(true);

            setTimeout(() => {
                try {
                    // FORCE UPDATE CONSTELLATION STATE
                    updateConstellationState();

                    // Collect group definitions
                    collectGroupDefinitions();

                    if (globalState.groupDefinitions.length === 0) {
                        throw new Error("Please define at least one group with at least one parameter or constellation.");
                    }

                    // Filter data into groups
                    filterDataIntoGroups();

                    // Update analysis results
                    updateAnalysisResults();

                    // Show results
                    document.getElementById('analysis-results').style.display = 'block';

                    utils.showSuccess(`Analysis complete! ${Object.keys(globalState.currentGroups).length} groups created.`);

                    // Scroll to results
                    document.getElementById('analysis-results').scrollIntoView({ behavior: 'smooth' });

                } catch (error) {
                    utils.showError("Error in group analysis: " + error.message);
                } finally {
                    utils.setLoading(false);
                }
            }, 100);
        }

        /**
         * Collect group definitions from the UI
         */
        function collectGroupDefinitions() {
            globalState.groupDefinitions = [];

            const groups = document.querySelectorAll('.parameter-group');

            groups.forEach((groupElement, index) => {
                const nameInput = groupElement.querySelector('.group-name-input');
                const groupName = nameInput.value.trim() || `Group ${index + 1}`;

                const notInPreviousCheckbox = groupElement.querySelector('input[type="checkbox"][id^="not-in-previous"]');
                const notInPrevious = notInPreviousCheckbox ? notInPreviousCheckbox.checked : false;

                const includeCheckbox = groupElement.querySelector('input[type="checkbox"][id^="include-group"]');
                const includeInAnalysis = includeCheckbox ? includeCheckbox.checked : true;

                // Get color settings
                const colorSelect = groupElement.querySelector('.color-preset-selector');
                const customColorInput = groupElement.querySelector('.custom-color-input');
                let customColor = null;

                if (colorSelect.value === 'custom' && customColorInput.value) {
                    customColor = customColorInput.value;
                    if (!customColor.includes('rgba')) {
                        customColor += 'B3'; // Add transparency
                    }
                }

                const conditions = [];
                const constellations = [];

                // Collect individual conditions
                const paramControls = groupElement.querySelectorAll('.parameter-control:not(.constellation-reference)');
                paramControls.forEach(control => {
                    const paramSelect = control.querySelector('.param-select');
                    const operatorSelect = control.querySelector('.condition-operator');

                    if (!paramSelect || !paramSelect.value) return;

                    const paramName = paramSelect.value;

                    // Handle "All Data" selection
                    if (paramName === '__all_data__') {
                        conditions.push({
                            parameter: '__all_data__',
                            operator: '=',
                            value: true,
                            type: 'special'
                        });
                        return;
                    }

                    if (!operatorSelect) return;

                    const operator = operatorSelect.value;
                    const paramType = globalState.columnTypes[paramName];

                    let conditionValue;

                    const valueElement = control.querySelector('.condition-value');
                    if (valueElement) {
                        if (scaleTypes[paramType].numeric) {
                            conditionValue = utils.parseNumericValue(valueElement.value);
                        } else {
                            conditionValue = valueElement.value;
                        }
                    }

                    if (conditionValue !== undefined && conditionValue !== null && (typeof conditionValue === 'string' || !isNaN(conditionValue))) {
                        conditions.push({
                            parameter: paramName,
                            operator: operator,
                            value: conditionValue,
                            type: paramType
                        });
                    }
                });

                // Collect constellation references
                const constellationControls = groupElement.querySelectorAll('.parameter-control.constellation-reference');
                constellationControls.forEach(control => {
                    const constellationSelect = control.querySelector('.constellation-select');
                    const negationCheckbox = control.querySelector('.negation-checkbox');

                    if (constellationSelect && constellationSelect.value) {
                        constellations.push({
                            name: constellationSelect.value,
                            negated: negationCheckbox ? negationCheckbox.checked : false
                        });
                    }
                });

                if (conditions.length > 0 || constellations.length > 0) {
                    globalState.groupDefinitions.push({
                        id: `group_${index}`,
                        name: groupName,
                        conditions: conditions,
                        constellations: constellations,
                        notInPrevious: notInPrevious,
                        includeInAnalysis: includeInAnalysis,
                        customColor: customColor,
                        colorIndex: colorSelect.value !== 'custom' ? parseInt(colorSelect.value) : index % groupColors.length
                    });
                }
            });

            // ADD THIS VALIDATION CODE HERE:
            // Validate group definitions
            globalState.groupDefinitions.forEach(group => {
                if (group.conditions.length === 0 && group.constellations.length === 0) {
                    console.warn(`Group "${group.name}" has no conditions or constellations`);
utils.showError(`Group "${group.name}" has no conditions or constellations`);
                }

                // Check if referenced constellations exist
                group.constellations.forEach(constRef => {
                    const exists = globalState.parameterConstellations.find(c => c.name === constRef.name);
                    if (!exists) {
                        console.error(`Group "${group.name}" references non-existent constellation "${constRef.name}"`);
utils.showError(`Group "${group.name}" references non-existent constellation "${constRef.name}"`);
                    }
                });
            });
        }

        /**
         * Filter data into defined groups
         */
        function filterDataIntoGroups() {
            globalState.processedData = {};
            globalState.currentGroups = {};
            globalState.recordAssignments = [];

            for (let i = 0; i < globalState.rawData.length; i++) {
                globalState.recordAssignments.push([]);
            }

            globalState.groupDefinitions.forEach(group => {
                if (!group.includeInAnalysis) {
                    return;
                }

                globalState.processedData[group.id] = [];
                globalState.currentGroups[group.id] = {
                    name: group.name,
                    count: 0,
                    customColor: group.customColor,
                    colorIndex: group.colorIndex
                };

                for (let rowIndex = 0; rowIndex < globalState.rawData.length; rowIndex++) {
                    const row = globalState.rawData[rowIndex];

                    if (group.notInPrevious && globalState.recordAssignments[rowIndex].length > 0) {
                        continue;
                    }

                    if (checkRowAgainstGroupDefinition(row, group)) {
                        globalState.processedData[group.id].push(row);
                        globalState.recordAssignments[rowIndex].push(group.id);
                    }
                }

                globalState.currentGroups[group.id].count = globalState.processedData[group.id].length;
            });
        }

        /**
         * Check if a row matches a group definition
         */
        function checkRowAgainstGroupDefinition(row, group) {
            let hasAnyConditions = false;

            if (group.conditions && group.conditions.length > 0) {
                hasAnyConditions = true;
                if (!checkRowAgainstConditions(row, group.conditions)) {
                    return false;
                }
            }

            if (group.constellations && group.constellations.length > 0) {
                for (let i = 0; i < group.constellations.length; i++) {
                    const constellationRef = group.constellations[i];
                    const constellation = globalState.parameterConstellations.find(c => c.name === constellationRef.name);

                    if (!constellation || !constellation.conditions) {
                        continue;
                    }

                    hasAnyConditions = true;

                    if (constellationRef.negated) {
                        if (checkRowAgainstConditions(row, constellation.conditions)) {
                            return false;
                        }
                    } else {
                        if (!checkRowAgainstConditions(row, constellation.conditions)) {
                            return false;
                        }
                    }
                }
            }

            return hasAnyConditions;
        }


        /**
         * Check if a row matches all conditions in a group
         */
        function checkRowAgainstConditions(row, conditions) {
            if (!conditions || conditions.length === 0) {
                return true;
            }

            for (let i = 0; i < conditions.length; i++) {
                const condition = conditions[i];

                if (condition.parameter === '__all_data__') {
                    continue;
                }

                const value = row[condition.parameter];
                const operator = condition.operator;
                const conditionValue = condition.value;
                const type = condition.type;

                if (scaleTypes[type] && scaleTypes[type].numeric) {
                    const numValue = utils.parseNumericValue(value);
                    const numConditionValue = utils.parseNumericValue(conditionValue);

                    if (isNaN(numValue) || isNaN(numConditionValue)) {
                        return false;
                    }

                    let matches = false;
                    switch (operator) {
                        case '=':
                            matches = Math.abs(numValue - numConditionValue) < 0.0001;
                            break;
                        case '!=':
                            matches = Math.abs(numValue - numConditionValue) >= 0.0001;
                            break;
                        case '<':
                            matches = numValue < numConditionValue;
                            break;
                        case '<=':
                            matches = numValue <= numConditionValue;
                            break;
                        case '>':
                            matches = numValue > numConditionValue;
                            break;
                        case '>=':
                            matches = numValue >= numConditionValue;
                            break;
                        default:
                            return false;
                    }

                    if (!matches) {
                        return false;
                    }
                } else {
                    if (value === null || value === undefined || value === '') {
                        return false;
                    }

                    const stringValue = String(value).trim();
                    const stringConditionValue = String(conditionValue).trim();

                    let matches = false;
                    switch (operator) {
                        case '=':
                            matches = stringValue === stringConditionValue;
                            break;
                        case '!=':
                            matches = stringValue !== stringConditionValue;
                            break;
                        default:
                            return false;
                    }

                    if (!matches) {
                        return false;
                    }
                }
            }

            return true;
        }

        /**
         * Update analysis results
         */
        function updateAnalysisResults() {
            updateOverviewTab();
            updateParameterDropdowns();
            updateSignificanceGroupSelection();

            // Automatically select first numeric parameter for detailed analysis
            const numericParams = globalState.columnNames.filter(name =>
                scaleTypes[globalState.columnTypes[name]].numeric
            );
            if (numericParams.length > 0) {
                document.getElementById('detail-parameter-select').value = numericParams[0];
                updateDetailAnalysis();
            }
        }

        /**
         * Update overview tab with summary statistics
         */
        function updateOverviewTab() {
            // Group summary table
            const summaryContainer = document.getElementById('group-summary-table');
            let html = '<table style="width: 100%;"><thead><tr><th>Group</th><th>Count</th><th>Percent</th></tr></thead><tbody>';

            const totalPatients = globalState.rawData.length;

            Object.entries(globalState.currentGroups).forEach(([groupId, group], index) => {
                const percentage = ((group.count / totalPatients) * 100).toFixed(1);
                const color = group.customColor || groupColors[group.colorIndex];
                const bgColor = typeof color === 'string' ? color : color.bg;

                html += `
                    <tr>
                        <td>
                            <span class="group-badge" style="background-color: ${bgColor};">
                                ${group.name}
                            </span>
                        </td>
                        <td><strong>${group.count}</strong></td>
                        <td>${percentage}%</td>
                    </tr>
                `;
            });

            html += `
                <tr style="border-top: 2px solid #666; font-weight: bold;">
                    <td>Total</td>
                    <td>${totalPatients}</td>
                    <td>100%</td>
                </tr>
            `;
            html += '</tbody></table>';
            summaryContainer.innerHTML = html;

            // Group distribution chart
            updateGroupDistributionChart();

            // Overview statistics table
            updateOverviewStatsTable();
        }

        /**
         * Update group distribution chart
         */
        function updateGroupDistributionChart() {
            const ctx = document.getElementById('group-distribution-chart').getContext('2d');

            const labels = Object.values(globalState.currentGroups).map(group => group.name);
            const data = Object.values(globalState.currentGroups).map(group => group.count);

            const backgroundColors = Object.values(globalState.currentGroups).map(group => {
                if (group.customColor) {
                    return group.customColor;
                }
                return groupColors[group.colorIndex].bg;
            });

            const borderColors = Object.values(globalState.currentGroups).map(group => {
                if (group.customColor) {
                    // Convert custom color to border (remove transparency)
                    return group.customColor.replace('B3', '');
                }
                return groupColors[group.colorIndex].border;
            });

            utils.destroyChart('group-distribution-chart');

            globalState.charts['group-distribution-chart'] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Distribution of Records',
                            font: { size: 16 },
                            color: '#e0e0e0'
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#e0e0e0'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.label || '';
                                    const value = context.parsed;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        /**
         * Update overview statistics table
         */
        function updateOverviewStatsTable() {
            const table = document.getElementById('overview-stats-table');
            let html = '<thead><tr><th>Parameter</th><th>Scale</th><th>Group</th><th>N</th><th>Mean/Median</th><th>SD/IQR</th><th>Min</th><th>Max</th></tr></thead><tbody>';

// Add explanation about statistics used
            const explanationDiv = document.createElement('div');
            explanationDiv.style.cssText = 'margin-bottom: 15px; padding: 15px; background-color: var(--background-light); border-radius: 8px; border: 1px solid var(--border-color);';
            explanationDiv.innerHTML = `
                <p style="font-size: 14px; color: var(--text-light);">
                    <strong>📊 Statistical Measures Used:</strong><br>
                    • <strong>Ordinal data (o):</strong> Median and IQR (Interquartile Range) - appropriate for ranked data without equal intervals<br>
                    • <strong>Interval/Ratio data (i/r):</strong> Mean and SD (Standard Deviation) - appropriate for continuous data with meaningful intervals<br>
                    • <strong>Categorical data (k):</strong> Mode and frequency counts - appropriate for nominal categories
                </p>
            `;
            document.getElementById('overview-stats-table').parentNode.insertBefore(explanationDiv, document.getElementById('overview-stats-table'));
            
            // All parameters
            globalState.columnNames.forEach(paramName => {
                const paramType = globalState.columnTypes[paramName];
                const scaleInfo = utils.getScaleInfo(paramType);

                Object.entries(globalState.currentGroups).forEach(([groupId, group], index) => {
                    const color = group.customColor || groupColors[group.colorIndex];
                    const bgColor = typeof color === 'string' ? color : color.bg;

                    if (scaleTypes[paramType].numeric) {
                        // Numeric parameters
                        const groupData = globalState.processedData[groupId]
                            .map(row => utils.parseNumericValue(row[paramName]))
                            .filter(val => !isNaN(val));

                        const stats = statistics.calculate(groupData);

                        let centralTendency = '-';
                        let dispersion = '-';

                        if (stats.count > 0) {
                            if (paramType === 'o') {
                                // Ordinal: use median and IQR
                                centralTendency = utils.formatNumber(stats.median, 2);
                                dispersion = utils.formatNumber(stats.iqr, 2);
                            } else {
                                // Interval/Ratio: use mean and SD
                                centralTendency = utils.formatNumber(stats.mean, 2);
                                dispersion = utils.formatNumber(stats.stdDev, 2);
                            }
                        }

                        html += `
                            <tr>
                                <td><strong>${paramName}</strong></td>
                                <td><span class="scale-badge ${scaleInfo.class}">${paramType.toUpperCase()}</span></td>
                                <td>
                                    <span class="group-badge" style="background-color: ${bgColor};">
                                        ${group.name}
                                    </span>
                                </td>
                                <td>${stats.count}</td>
                                <td>${centralTendency}</td>
                                <td>${dispersion}</td>
                                <td>${stats.min !== null ? utils.formatNumber(stats.min, 2) : '-'}</td>
                                <td>${stats.max !== null ? utils.formatNumber(stats.max, 2) : '-'}</td>
                            </tr>
                        `;
                    } else {
                        // Categorical parameters
                        const groupData = globalState.processedData[groupId]
                            .map(row => row[paramName])
                            .filter(val => val !== null && val !== undefined && val !== '');

                        const uniqueValues = [...new Set(groupData)];
                        const mode = uniqueValues.length > 0 ?
                            uniqueValues.reduce((a, b) =>
                                groupData.filter(v => v === a).length >= groupData.filter(v => v === b).length ? a : b
                            ) : '-';

                        html += `
                            <tr>
                                <td><strong>${paramName}</strong></td>
                                <td><span class="scale-badge ${scaleInfo.class}">${paramType.toUpperCase()}</span></td>
                                <td>
                                    <span class="group-badge" style="background-color: ${bgColor};">
                                        ${group.name}
                                    </span>
                                </td>
                                <td>${groupData.length}</td>
                                <td colspan="2">Mode: ${mode}</td>
                                <td colspan="2">${uniqueValues.length} categories</td>
                            </tr>
                        `;
                    }
                });
            });

            html += '</tbody>';
            table.innerHTML = html;
        }

        /**
 * Update significance test group selection
 */
function updateSignificanceGroupSelection() {
    const container = document.getElementById('sig-group-selection');
    container.innerHTML = '';

    Object.entries(globalState.currentGroups).forEach(([groupId, group], index) => {
        const color = group.customColor || groupColors[group.colorIndex];
        const bgColor = typeof color === 'string' ? color : color.bg;

        const checkboxDiv = document.createElement('div');
        checkboxDiv.className = 'checkbox-container';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `sig-group-${groupId}`;
        checkbox.value = groupId;
        checkbox.checked = true;
        
        // Add change listener
        checkbox.addEventListener('change', updateTestSelectionUI);

        const label = document.createElement('label');
        label.htmlFor = `sig-group-${groupId}`;
        label.innerHTML = `
            <span class="group-badge" style="background-color: ${bgColor};">
                ${group.name}
            </span> (n=${group.count})
        `;

        checkboxDiv.appendChild(checkbox);
        checkboxDiv.appendChild(label);
        container.appendChild(checkboxDiv);
    });
    
    // Update UI state after rendering
    updateTestSelectionUI();
}

        /**
         * Update parameter dropdowns across the application
         */
        function updateParameterDropdowns() {
            // Detailed analysis
            const detailSelect = document.getElementById('detail-parameter-select');
            detailSelect.innerHTML = '<option value="">Select parameter</option>';

            // Significance test
            const sigSelect = document.getElementById('sig-parameter-select');
            sigSelect.innerHTML = '<option value="">Select parameter</option>';

            // Visualization
            const vizXSelect = document.getElementById('viz-parameter-x');
            const vizYSelect = document.getElementById('viz-parameter-y');
            vizXSelect.innerHTML = '<option value="">Select parameter</option>';
            vizYSelect.innerHTML = '<option value="">Select parameter</option>';

            // Add all parameters
            globalState.columnNames.forEach(name => {
                const type = globalState.columnTypes[name];
                const scaleInfo = utils.getScaleInfo(type);

                // Add parameter to all dropdowns with scale info
                const optionText = `${name} (${scaleInfo.name})`;

                const vizXOption = new Option(optionText, name);
                vizXSelect.add(vizXOption);

                const sigOption = new Option(optionText, name);
                sigSelect.add(sigOption);

                // Detailed analysis and Y-axis: numeric parameters only
                if (scaleTypes[type].numeric) {
                    const detailOption = new Option(optionText, name);
                    detailSelect.add(detailOption);

                    const vizYOption = new Option(optionText, name);
                    vizYSelect.add(vizYOption);
                }
            });

            // Update significance test groups
            //updateSignificanceGroupSelection();
        }

        /**
         * Update detailed analysis based on selected parameter
         */
        function updateDetailAnalysis() {
            const paramName = document.getElementById('detail-parameter-select').value;

            if (!paramName || !scaleTypes[globalState.columnTypes[paramName]].numeric) {
                // Show empty content
                document.getElementById('detail-analysis-content').innerHTML =
                    '<p style="text-align: center; color: #666; margin: 40px 0;">Please select a numeric parameter (ordinal, interval, or ratio scale).</p>';
                return;
            }

            // Collect data for each group
            const groupData = {};
            Object.keys(globalState.currentGroups).forEach(groupId => {
                groupData[groupId] = globalState.processedData[groupId]
                    .map(row => utils.parseNumericValue(row[paramName]))
                    .filter(val => !isNaN(val));
            });

            // Mean chart
            updateDetailMeanChart(paramName, groupData);

            // Distribution chart
            updateDetailDistributionChart(paramName, groupData);

            // Detailed statistics table
            updateDetailStatsTable(paramName, groupData);

            // Initialize histogram group selection
            initializeHistogramGroupSelection(paramName, groupData);

            // Create histogram with all groups selected initially
            updateDetailHistogram(paramName, groupData);
        }

        /**
         * Update mean value chart with error bars
         */
        function updateDetailMeanChart(paramName, groupData) {
            const ctx = document.getElementById('detail-mean-chart').getContext('2d');
            const paramType = globalState.columnTypes[paramName];

            const labels = Object.values(globalState.currentGroups).map(group => group.name);
            const means = Object.entries(groupData).map(([groupId, data]) => {
                if (data.length === 0) return 0;
                const stats = statistics.calculate(data);
                // Use median for ordinal, mean for interval/ratio
                return paramType === 'o' ? stats.median : stats.mean;
            });

            const stdDevs = Object.entries(groupData).map(([groupId, data]) => {
                if (data.length <= 1) return 0;
                const stats = statistics.calculate(data);
                // Use IQR for ordinal, SD for interval/ratio
                return paramType === 'o' ? stats.iqr / 2 : stats.stdDev;
            });

            const backgroundColors = Object.values(globalState.currentGroups).map(group => {
                if (group.customColor) {
                    return group.customColor;
                }
                return groupColors[group.colorIndex].bg;
            });

            const borderColors = Object.values(globalState.currentGroups).map(group => {
                if (group.customColor) {
                    return group.customColor.replace('B3', '');
                }
                return groupColors[group.colorIndex].border;
            });

            // Calculate Y-axis range
            const allValues = Object.values(groupData).flat();
            const yRange = utils.calculateYAxisRange(allValues, paramType);

            utils.destroyChart('detail-mean-chart');

            const chartLabel = paramType === 'o' ? 'Median' : 'Mean';

            globalState.charts['detail-mean-chart'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: chartLabel,
                        data: means,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            min: yRange.min,
                            max: yRange.max,
                            title: {
                                display: true,
                                text: paramName,
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        },
                        x: {
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `${chartLabel} Values: ${paramName}`,
                            font: { size: 14 },
                            color: '#e0e0e0'
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const index = context.dataIndex;
                                    const value = means[index];
                                    const error = stdDevs[index];
                                    const errorLabel = paramType === 'o' ? 'IQR/2' : 'Std Dev';
                                    return [
                                        `${chartLabel}: ${utils.formatNumber(value, 2)}`,
                                        `${errorLabel}: ${utils.formatNumber(error, 2)}`,
                                        `N: ${Object.values(groupData)[index].length}`
                                    ];
                                }
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'errorBars',
                    afterDraw: function (chart) {
                        const ctx = chart.ctx;
                        chart.data.datasets.forEach((dataset, datasetIndex) => {
                            const meta = chart.getDatasetMeta(datasetIndex);

                            meta.data.forEach((element, index) => {
                                const stdDev = stdDevs[index];
                                const mean = means[index];

                                if (stdDev > 0) {
                                    const centerX = element.x;
                                    const scale = chart.scales.y;
                                    const topY = scale.getPixelForValue(mean + stdDev);
                                    const bottomY = scale.getPixelForValue(mean - stdDev);
                                    const barWidth = 10;

                                    ctx.save();
                                    ctx.strokeStyle = borderColors[index];
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();

                                    // Vertical line
                                    ctx.moveTo(centerX, topY);
                                    ctx.lineTo(centerX, bottomY);

                                    // Top cap
                                    ctx.moveTo(centerX - barWidth / 2, topY);
                                    ctx.lineTo(centerX + barWidth / 2, topY);

                                    // Bottom cap
                                    ctx.moveTo(centerX - barWidth / 2, bottomY);
                                    ctx.lineTo(centerX + barWidth / 2, bottomY);

                                    ctx.stroke();
                                    ctx.restore();
                                }
                            });
                        });
                    }
                }]
            });
        }

        /**
         * Update distribution comparison chart
         */
        function updateDetailDistributionChart(paramName, groupData) {
            const ctx = document.getElementById('detail-distribution-chart').getContext('2d');
            const paramType = globalState.columnTypes[paramName];

            // Create histogram-like representation for each group
            const labels = Object.values(globalState.currentGroups).map(group => group.name);

            // Quartiles as stacked bars
            const q1Data = [], medianData = [], q3Data = [], minData = [], maxData = [];

            Object.entries(groupData).forEach(([groupId, data]) => {
                const stats = statistics.calculate(data);
                minData.push(stats.min || 0);
                q1Data.push(stats.q1 || 0);
                medianData.push(stats.median || 0);
                q3Data.push(stats.q3 || 0);
                maxData.push(stats.max || 0);
            });

            const backgroundColors = Object.values(globalState.currentGroups).map(group => {
                if (group.customColor) {
                    return group.customColor;
                }
                return groupColors[group.colorIndex].bg;
            });

            // Calculate Y-axis range
            const allValues = [...minData, ...maxData];
            const yRange = utils.calculateYAxisRange(allValues, paramType);

            utils.destroyChart('detail-distribution-chart');

            globalState.charts['detail-distribution-chart'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Minimum',
                            data: minData,
                            backgroundColor: backgroundColors.map(color => color.replace('0.7', '0.3')),
                            borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                            borderWidth: 1
                        },
                        {
                            label: 'Q1',
                            data: q1Data,
                            backgroundColor: backgroundColors.map(color => color.replace('0.7', '0.5')),
                            borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                            borderWidth: 1
                        },
                        {
                            label: 'Median',
                            data: medianData,
                            backgroundColor: backgroundColors,
                            borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                            borderWidth: 2
                        },
                        {
                            label: 'Q3',
                            data: q3Data,
                            backgroundColor: backgroundColors.map(color => color.replace('0.7', '0.5')),
                            borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                            borderWidth: 1
                        },
                        {
                            label: 'Maximum',
                            data: maxData,
                            backgroundColor: backgroundColors.map(color => color.replace('0.7', '0.3')),
                            borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            min: yRange.min,
                            max: yRange.max,
                            title: {
                                display: true,
                                text: paramName,
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        },
                        x: {
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Distribution: ${paramName}`,
                            font: { size: 14 },
                            color: '#e0e0e0'
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#e0e0e0'
                            }
                        }
                    }
                }
            });
        }

        /**
         * Update detailed statistics table
         */
        function updateDetailStatsTable(paramName, groupData) {
            const table = document.getElementById('detail-stats-table');
            const paramType = globalState.columnTypes[paramName];

            let html = '<thead><tr><th>Group</th><th>N</th>';

            if (paramType === 'o') {
                // Ordinal: focus on median and quartiles
                html += '<th>Median</th><th>Q1</th><th>Q3</th><th>IQR</th><th>Min</th><th>Max</th><th>Range</th>';
            } else {
                // Interval/Ratio: full statistics
                html += '<th>Mean</th><th>Median</th><th>Std Dev</th><th>Min</th><th>Max</th><th>Q1</th><th>Q3</th><th>IQR</th>';
                if (paramType === 'r') {
                    html += '<th>CV (%)</th>';
                }
            }

            html += '</tr></thead><tbody>';

            Object.entries(groupData).forEach(([groupId, data], index) => {
                const stats = statistics.calculate(data);
                const group = globalState.currentGroups[groupId];
                const color = group.customColor || groupColors[group.colorIndex];
                const bgColor = typeof color === 'string' ? color : color.bg;

                html += `
                    <tr>
                        <td>
                            <span class="group-badge" style="background-color: ${bgColor};">
                                ${group.name}
                            </span>
                        </td>
                        <td>${stats.count}</td>
                `;

                if (paramType === 'o') {
                    // Ordinal statistics
                    html += `
                        <td>${stats.median !== null ? utils.formatNumber(stats.median, 2) : '-'}</td>
                        <td>${stats.q1 !== null ? utils.formatNumber(stats.q1, 2) : '-'}</td>
                        <td>${stats.q3 !== null ? utils.formatNumber(stats.q3, 2) : '-'}</td>
                        <td>${stats.iqr !== null ? utils.formatNumber(stats.iqr, 2) : '-'}</td>
                        <td>${stats.min !== null ? utils.formatNumber(stats.min, 2) : '-'}</td>
                        <td>${stats.max !== null ? utils.formatNumber(stats.max, 2) : '-'}</td>
                        <td>${stats.range !== null ? utils.formatNumber(stats.range, 2) : '-'}</td>
                    `;
                } else {
                    // Interval/Ratio statistics
                    html += `
                        <td>${stats.mean !== null ? utils.formatNumber(stats.mean, 3) : '-'}</td>
                        <td>${stats.median !== null ? utils.formatNumber(stats.median, 3) : '-'}</td>
                        <td>${stats.stdDev !== null ? utils.formatNumber(stats.stdDev, 3) : '-'}</td>
                        <td>${stats.min !== null ? utils.formatNumber(stats.min, 3) : '-'}</td>
                        <td>${stats.max !== null ? utils.formatNumber(stats.max, 3) : '-'}</td>
                        <td>${stats.q1 !== null ? utils.formatNumber(stats.q1, 3) : '-'}</td>
                        <td>${stats.q3 !== null ? utils.formatNumber(stats.q3, 3) : '-'}</td>
                        <td>${stats.iqr !== null ? utils.formatNumber(stats.iqr, 3) : '-'}</td>
                    `;

                    if (paramType === 'r') {
                        html += `<td>${stats.cv !== null ? utils.formatNumber(stats.cv, 1) : '-'}</td>`;
                    }
                }

                html += '</tr>';
            });

            html += '</tbody>';
            table.innerHTML = html;
        }

        /**
         * Initialize group selection checkboxes for histogram
         */
        function initializeHistogramGroupSelection(paramName, groupData) {
            const container = document.getElementById('histogram-group-selection');
            container.innerHTML = '';

            // Create checkboxes for each group
            Object.entries(globalState.currentGroups).forEach(([groupId, group]) => {
                const color = group.customColor || groupColors[group.colorIndex];
                const bgColor = typeof color === 'string' ? color : color.bg;

                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'checkbox-container';
                checkboxDiv.style.marginBottom = '0';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `histogram-group-${groupId}`;
                checkbox.value = groupId;
                checkbox.checked = true; // All selected by default

                // Add change listener
                checkbox.addEventListener('change', () => {
                    updateDetailHistogram(paramName, groupData);
                });

                const label = document.createElement('label');
                label.htmlFor = `histogram-group-${groupId}`;
                label.innerHTML = `
            <span class="group-badge" style="background-color: ${bgColor};">
                ${group.name}
            </span> (n=${groupData[groupId].length})
        `;

                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                container.appendChild(checkboxDiv);
            });

            // Set up select all/none buttons
            document.getElementById('histogram-select-all').addEventListener('click', () => {
                document.querySelectorAll('#histogram-group-selection input[type="checkbox"]').forEach(cb => {
                    cb.checked = true;
                });
                updateDetailHistogram(paramName, groupData);
            });

            document.getElementById('histogram-select-none').addEventListener('click', () => {
                document.querySelectorAll('#histogram-group-selection input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                updateDetailHistogram(paramName, groupData);
            });
        }

        /**
         * Update histogram chart for distribution analysis
         */
        function updateDetailHistogram(paramName, groupData) {
            const ctx = document.getElementById('detail-histogram-chart').getContext('2d');
            const paramType = globalState.columnTypes[paramName];

            // Destroy existing chart
            utils.destroyChart('detail-histogram-chart');

            // Get selected groups
            const selectedGroups = [];
            document.querySelectorAll('#histogram-group-selection input:checked').forEach(checkbox => {
                selectedGroups.push(checkbox.value);
            });

            if (selectedGroups.length === 0) {
                // Show message when no groups selected
                ctx.font = '16px Arial';
                ctx.fillStyle = '#666';
                ctx.textAlign = 'center';
                ctx.fillText('Please select at least one group to display', ctx.canvas.width / 2, ctx.canvas.height / 2);
                return;
            }

            // Collect data from selected groups
            const allData = [];
            const groupDataMap = {};

            selectedGroups.forEach(groupId => {
                const data = groupData[groupId] || [];
                groupDataMap[groupId] = data;
                allData.push(...data);
            });

            if (allData.length === 0) {
                return;
            }

            // Sort data
            allData.sort((a, b) => a - b);

            // Calculate number of bins using Sturges' rule
            const numBins = Math.max(5, Math.ceil(Math.log2(allData.length) + 1));
            const min = allData[0];
            const max = allData[allData.length - 1];
            const binWidth = (max - min) / numBins;

            // Create bins
            const bins = [];
            const binLabels = [];

            for (let i = 0; i < numBins; i++) {
                const binStart = min + i * binWidth;
                const binEnd = binStart + binWidth;
                bins.push({
                    start: binStart,
                    end: binEnd,
                    midpoint: (binStart + binEnd) / 2
                });

                // Format bin labels
                if (paramType === 'o') {
                    binLabels.push(`${Math.round(binStart)}-${Math.round(binEnd)}`);
                } else {
                    binLabels.push(`${binStart.toFixed(1)}-${binEnd.toFixed(1)}`);
                }
            }

            // Create datasets
            const datasets = [];

            // Add histogram for each selected group
            selectedGroups.forEach(groupId => {
                const group = globalState.currentGroups[groupId];
                const color = group.customColor || groupColors[group.colorIndex];
                const bgColor = typeof color === 'string' ? color : color.bg;
                const borderColor = typeof color === 'string' ? color.replace('B3', '') : color.border;

                // Count data points in each bin for this group
                const binCounts = new Array(numBins).fill(0);
                groupDataMap[groupId].forEach(value => {
                    const binIndex = Math.min(Math.floor((value - min) / binWidth), numBins - 1);
                    if (binIndex >= 0 && binIndex < numBins) {
                        binCounts[binIndex]++;
                    }
                });

                datasets.push({
                    label: group.name,
                    data: binCounts,
                    backgroundColor: bgColor.replace('0.7', '0.5'),
                    borderColor: borderColor,
                    borderWidth: 1,
                    type: 'bar'
                });
            });

            // Add overall distribution line if multiple groups selected
            if (selectedGroups.length > 1) {
                const overallBinCounts = new Array(numBins).fill(0);
                allData.forEach(value => {
                    const binIndex = Math.min(Math.floor((value - min) / binWidth), numBins - 1);
                    if (binIndex >= 0 && binIndex < numBins) {
                        overallBinCounts[binIndex]++;
                    }
                });

                datasets.push({
                    label: 'Combined Distribution',
                    data: overallBinCounts,
                    borderColor: 'rgba(255, 255, 255, 0.8)',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    borderDash: [10, 5],
                    type: 'line',
                    fill: false,
                    tension: 0.1,
                    pointRadius: 3
                });
            }

            // Calculate and add normal distribution curve for overall data
            const mean = allData.reduce((sum, val) => sum + val, 0) / allData.length;
            const variance = allData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (allData.length - 1);
            const stdDev = Math.sqrt(variance);

            // Generate normal distribution curve
            const curveData = bins.map(bin => {
                const z = (bin.midpoint - mean) / stdDev;
                const y = (1 / (stdDev * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * z * z);
                return y * allData.length * binWidth;
            });

            datasets.push({
                label: 'Normal Distribution',
                data: curveData,
                borderColor: 'rgba(255, 99, 132, 1)',
                backgroundColor: 'transparent',
                borderWidth: 2,
                borderDash: [5, 5],
                type: 'line',
                fill: false,
                tension: 0.4,
                pointRadius: 0
            });

            // Create the chart
            globalState.charts['detail-histogram-chart'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: paramName + ' (Bins)',
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0',
                                maxRotation: 45,
                                minRotation: 0
                            },
                            grid: {
                                color: '#444'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency',
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Distribution of ${paramName} (n=${allData.length})`,
                            font: { size: 14 },
                            color: '#e0e0e0'
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#e0e0e0',
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function (context) {
                                    const label = context.dataset.label || '';
                                    if (context.dataset.type === 'bar') {
                                        const count = context.parsed.y;
                                        const total = context.dataset.data.reduce((sum, val) => sum + val, 0);
                                        const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : '0';
                                        return `${label}: ${count} (${percentage}%)`;
                                    } else if (label === 'Normal Distribution') {
                                        return `Expected: ${context.parsed.y.toFixed(1)}`;
                                    } else {
                                        return `${label}: ${context.parsed.y}`;
                                    }
                                }
                            }
                        }
                    }
                }
            });

            // Add normality test results for selected groups
            let subtitleText = '';
            if (selectedGroups.length === 1) {
                // Single group - show Shapiro-Wilk test
                const data = groupDataMap[selectedGroups[0]];
                const shapiroResult = statistics.shapiroWilkTest(data);
                if (!shapiroResult.error) {
                    subtitleText = shapiroResult.normal ?
                        `Shapiro-Wilk: W=${shapiroResult.W.toFixed(4)}, p=${shapiroResult.pValue.toFixed(4)} (Normal)` :
                        `Shapiro-Wilk: W=${shapiroResult.W.toFixed(4)}, p=${shapiroResult.pValue.toFixed(4)} (Not Normal)`;
                }
            } else {
                // Multiple groups - show overall statistics
                subtitleText = `Combined: μ=${mean.toFixed(2)}, σ=${stdDev.toFixed(2)}`;
            }

            if (subtitleText) {
                globalState.charts['detail-histogram-chart'].options.plugins.subtitle = {
                    display: true,
                    text: subtitleText,
                    color: '#e0e0e0',
                    font: { size: 12 }
                };
                globalState.charts['detail-histogram-chart'].update();
            }
        }

        /**
         * Clear significance test results
         */
        function clearSignificanceResults() {
            document.getElementById('significance-results').innerHTML = '';
            document.getElementById('prerequisite-results').innerHTML = '';
            globalState.prerequisiteResults = {};
        }

        /**
         * Check test requirements and generate violations list
         */
        function checkTestRequirements(testType, paramName, selectedGroups) {
            const violations = [];
            const paramType = globalState.columnTypes[paramName];
            const scaleInfo = scaleTypes[paramType];

            // Check scale type requirements
            switch (testType) {
                case 'ttest':
                case 'welch':
                case 'anova':
                    if (!scaleInfo.numeric || paramType === 'o') {
                        violations.push('Test requires interval or ratio scale data (currently: ' + scaleInfo.name + ')');
                    }
                    break;
                case 'chi-square':
                case 'fisher':
                    if (scaleInfo.numeric) {
                        violations.push('Test requires categorical (nominal) data');
                    }
                    break;
                case 'pearson':
                    if (!scaleInfo.numeric || paramType === 'o') {
                        violations.push('Pearson correlation requires interval or ratio scale data');
                    }
                    break;
            }

            // Check group count requirements
            if ((testType === 'ttest' || testType === 'welch' || testType === 'mann-whitney' || testType === 'fisher') && selectedGroups.length !== 2) {
                violations.push(`Test requires exactly 2 groups (selected: ${selectedGroups.length})`);
            }

            if ((testType === 'anova' || testType === 'kruskal-wallis') && selectedGroups.length < 2) {
                violations.push('Test requires at least 2 groups');
            }

            // Check normality if results exist
            if ((testType === 'ttest' || testType === 'welch' || testType === 'anova') && globalState.prerequisiteResults[paramName]) {
                selectedGroups.forEach(groupId => {
                    const prereq = globalState.prerequisiteResults[paramName][groupId];
                    if (prereq && prereq.normality && !prereq.normality.normal) {
                        const groupName = globalState.currentGroups[groupId].name;
                        violations.push(`Group "${groupName}" is not normally distributed (required for parametric tests)`);
                    }
                });
            }

            // Check variance homogeneity for t-test
            if (testType === 'ttest' && globalState.prerequisiteResults[paramName] && globalState.prerequisiteResults[paramName].varianceTest) {
                const varianceTest = globalState.prerequisiteResults[paramName].varianceTest;
                if (!varianceTest.equalVariances) {
                    violations.push('Groups have unequal variances (consider using Welch\'s t-test instead)');
                }
            }

            // Check sample size
            selectedGroups.forEach(groupId => {
                const groupData = globalState.processedData[groupId]
                    .map(row => scaleInfo.numeric ? utils.parseNumericValue(row[paramName]) : row[paramName])
                    .filter(val => val !== null && val !== undefined && (scaleInfo.numeric ? !isNaN(val) : val !== ''));

                if (groupData.length < 3 && (testType === 'ttest' || testType === 'welch' || testType === 'anova')) {
                    const groupName = globalState.currentGroups[groupId].name;
                    violations.push(`Group "${groupName}" has less than 3 observations (n=${groupData.length})`);
                }
            });

            return violations;
        }

        /**
         * Automatically selects the appropriate test based on parameter and group selection
         */
        function selectAppropriateTest(paramName, selectedGroups) {
            const paramType = globalState.columnTypes[paramName];
            const scaleInfo = scaleTypes[paramType];

            if (!scaleInfo.numeric) {
                // Categorical data
                if (selectedGroups.length === 2 && is2x2Table(paramName, selectedGroups)) {
                    return 'fisher';
                }
                return 'chi-square';
            }

            // Numeric data
            if (selectedGroups.length === 2) {
                // Check for normality if results exist
                const prereqs = globalState.prerequisiteResults[paramName];
                let isNormal = true;
                let equalVariances = true;

                if (prereqs) {
                    selectedGroups.forEach(groupId => {
                        if (prereqs[groupId] && prereqs[groupId].normality) {
                            isNormal = isNormal && prereqs[groupId].normality.normal;
                        }
                    });

                    if (prereqs.varianceTest) {
                        equalVariances = prereqs.varianceTest.equalVariances;
                    }
                }

                if (paramType === 'o') {
                    // Ordinal data - use non-parametric
                    return 'mann-whitney';
                } else if (isNormal && equalVariances) {
                    return 'ttest';
                } else if (isNormal && !equalVariances) {
                    return 'welch';
                } else {
                    return 'mann-whitney';
                }
            } else if (selectedGroups.length > 2) {
                // Check for normality
                const prereqs = globalState.prerequisiteResults[paramName];
                let isNormal = true;

                if (prereqs) {
                    selectedGroups.forEach(groupId => {
                        if (prereqs[groupId] && prereqs[groupId].normality) {
                            isNormal = isNormal && prereqs[groupId].normality.normal;
                        }
                    });
                }

                if (paramType === 'o' || !isNormal) {
                    return 'kruskal-wallis';
                } else {
                    return 'anova';
                }
            }

            return 'auto';
        }

        /**
         * Check if data forms a 2x2 table for Fisher's exact test
         */
        function is2x2Table(paramName, selectedGroups) {
            if (selectedGroups.length !== 2) return false;

            const allValues = [];
            selectedGroups.forEach(groupId => {
                const values = globalState.processedData[groupId]
                    .map(row => row[paramName])
                    .filter(val => val !== null && val !== undefined && val !== '');
                allValues.push(...values);
            });

            const uniqueValues = [...new Set(allValues)];
            return uniqueValues.length === 2;
        }

        /**
         * Run statistical significance test
         */
        function runSignificanceTest() {
    const paramName = document.getElementById('sig-parameter-select').value;
    if (!paramName) {
        utils.showError("Please select a parameter for significance testing.");
        return;
    }

    // Get selected groups early
    const selectedGroups = [];
    document.querySelectorAll('#sig-group-selection input:checked').forEach(checkbox => {
        selectedGroups.push(checkbox.value);
    });

    if (selectedGroups.length < 1) {
        utils.showError("Please select at least one group for comparison.");
        return;
    }

    let testType = document.getElementById('sig-test-type').value;
    const forceExecution = true; // Always force execution

    // Get alpha level
            let alpha = 0.05;
            const alphaSelect = document.getElementById('sig-alpha');
            if (alphaSelect.value === 'custom') {
                alpha = parseFloat(document.getElementById('sig-custom-alpha').value);
                if (isNaN(alpha) || alpha <= 0 || alpha >= 1) {
                    utils.showError("Custom alpha must be between 0 and 1.");
                    return;
                }
            } else {
                alpha = parseFloat(alphaSelect.value);
            }

            // Get test direction
            const direction = document.getElementById('sig-direction').value;

            if (selectedGroups.length < 1) {
                utils.showError("Please select at least one group for comparison.");
                return;
            }

            // Auto-select appropriate test if needed
            if (testType === 'auto') {
                testType = selectAppropriateTest(paramName, selectedGroups);
            }

            // Check test requirements
            const violations = checkTestRequirements(testType, paramName, selectedGroups);

            // If violations exist and force execution is not enabled, show error
            if (violations.length > 0 && !forceExecution) {
                utils.showError(`Test requirements not met:\n• ${violations.join('\n• ')}\n\nEnable "Force test execution" to run anyway.`);
                return;
            }

            // Run the appropriate test
            let result;
            const testOptions = { alpha, direction };

            try {
                switch (testType) {
                    case 'ttest':
                        result = runTTest(paramName, selectedGroups, testOptions);
                        break;
                    case 'welch':
                        result = runWelchTest(paramName, selectedGroups, testOptions);
                        break;
                    case 'anova':
                        result = runANOVA(paramName, selectedGroups, testOptions);
                        break;
                    case 'mann-whitney':
                        result = runMannWhitney(paramName, selectedGroups, testOptions);
                        break;
                    case 'kruskal-wallis':
                        result = runKruskalWallis(paramName, selectedGroups, testOptions);
                        break;
                    case 'chi-square':
                        result = runChiSquare(paramName, selectedGroups, testOptions);
                        break;
                    case 'fisher':
                        result = runFisherExact(paramName, selectedGroups, testOptions);
                        break;
                    default:
                        utils.showError("Unknown test type selected.");
                        return;
                }

                if (!result) {
                    utils.showError("Test could not be performed. Check your data.");
                    return;
                }

                if (result.error) {
                    utils.showError(result.error);
                    return;
                }

                // Add violations to result if forced
                if (violations.length > 0) {
                    result.violations = violations;
                }

                // Store result for export
                globalState.significanceResults.push({
                    paramName: paramName,
                    groupNames: selectedGroups.map(id => globalState.currentGroups[id].name),
                    result: result,
                    timestamp: new Date()
                });

                // Display results
                displaySignificanceResults(result, paramName, selectedGroups.map(id => globalState.currentGroups[id].name), violations);

            } catch (error) {
                console.error('Test execution error:', error);
                utils.showError(`Error running test: ${error.message}`);
            }
        }

        /**
         * Run t-test
         */
        function runTTest(paramName, selectedGroups, options) {
            if (selectedGroups.length !== 2) {
                return { error: "t-test requires exactly 2 groups." };
            }

            const group1Data = globalState.processedData[selectedGroups[0]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            const group2Data = globalState.processedData[selectedGroups[1]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            return statistics.tTest(group1Data, group2Data, options);
        }

        /**
         * Run Welch's t-test
         */
        function runWelchTest(paramName, selectedGroups, options) {
            if (selectedGroups.length !== 2) {
                return { error: "Welch's t-test requires exactly 2 groups." };
            }

            const group1Data = globalState.processedData[selectedGroups[0]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            const group2Data = globalState.processedData[selectedGroups[1]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            return statistics.welchTTest(group1Data, group2Data, options);
        }

        /**
         * Run ANOVA
         */
        function runANOVA(paramName, selectedGroups, options) {
    if (selectedGroups.length < 2) {
        return { error: "ANOVA requires at least 2 groups." };
    }

    const groupDataArrays = selectedGroups.map(groupId => {
        return globalState.processedData[groupId]
            .map(row => utils.parseNumericValue(row[paramName]))
            .filter(val => !isNaN(val) && isFinite(val));
    });

    // Check if all groups have data
    const validGroups = groupDataArrays.filter(group => group.length > 0);
    if (validGroups.length < 2) {
        return { error: "ANOVA requires at least 2 groups with valid data." };
    }

    return statistics.anova(validGroups, options);
}

        /**
         * Run Mann-Whitney U test
         */
        function runMannWhitney(paramName, selectedGroups, options) {
            if (selectedGroups.length !== 2) {
                return { error: "Mann-Whitney U test requires exactly 2 groups." };
            }

            const group1Data = globalState.processedData[selectedGroups[0]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            const group2Data = globalState.processedData[selectedGroups[1]]
                .map(row => utils.parseNumericValue(row[paramName]))
                .filter(val => !isNaN(val));

            return statistics.mannWhitneyU(group1Data, group2Data, options);
        }

        /**
         * Run Kruskal-Wallis test
         */
        function runKruskalWallis(paramName, selectedGroups, options) {
            if (selectedGroups.length < 2) {
                return { error: "Kruskal-Wallis test requires at least 2 groups." };
            }

            const groupDataArrays = selectedGroups.map(groupId => {
                return globalState.processedData[groupId]
                    .map(row => utils.parseNumericValue(row[paramName]))
                    .filter(val => !isNaN(val));
            });

            return statistics.kruskalWallis(groupDataArrays, options);
        }

        /**
         * Run Chi-square test
         */
        function runChiSquare(paramName, selectedGroups, options) {
            const selectedGroupData = {};
            selectedGroups.forEach(groupId => {
                selectedGroupData[groupId] = globalState.processedData[groupId];
            });

            return statistics.chiSquareTest(paramName, selectedGroupData, options);
        }

        /**
         * Run Fisher's exact test
         */
        function runFisherExact(paramName, selectedGroups, options) {
            if (selectedGroups.length !== 2) {
                return { error: "Fisher's exact test requires exactly 2 groups." };
            }

            // Get unique categories
            const allValues = [];
            selectedGroups.forEach(groupId => {
                const values = globalState.processedData[groupId]
                    .map(row => row[paramName])
                    .filter(val => val !== null && val !== undefined && val !== '');
                allValues.push(...values);
            });

            const categories = [...new Set(allValues)];
            if (categories.length !== 2) {
                return { error: "Fisher's exact test requires exactly 2 categories." };
            }

            // Build 2x2 table
            const table = [[0, 0], [0, 0]];

            selectedGroups.forEach((groupId, groupIndex) => {
                globalState.processedData[groupId].forEach(row => {
                    const value = row[paramName];
                    if (value === categories[0]) {
                        table[groupIndex][0]++;
                    } else if (value === categories[1]) {
                        table[groupIndex][1]++;
                    }
                });
            });

            const result = statistics.fisherExactTest(table, options);
            if (result) {
                result.categories = categories;
                result.groups = selectedGroups.map(id => globalState.currentGroups[id].name);
            }

            return result;
        }

        /**
         * Run Pearson correlation
         */
        function runPearsonCorrelation(paramName, selectedGroups, options) {
            // For correlation, we need two numeric parameters
            // This is a simplified version - in practice, you'd select two parameters
            return { error: "Pearson correlation requires selecting two numeric parameters. Please use the visualization tab for correlation analysis." };
        }

        /**
         * Run Spearman correlation
         */
        function runSpearmanCorrelation(paramName, selectedGroups, options) {
            // For correlation, we need two parameters
            // This is a simplified version - in practice, you'd select two parameters
            return { error: "Spearman correlation requires selecting two parameters. Please use the visualization tab for correlation analysis." };
        }

        /**
         * Display significance test results
         */
       function displaySignificanceResults(result, paramName, groupNames, violations = []) {
    const container = document.getElementById('significance-results');

    const resultDiv = document.createElement('div');
    resultDiv.className = `significance-result ${result.significant ? 'significant' : 'not-significant'}`;
    resultDiv.style.marginBottom = '30px';
    resultDiv.style.padding = '20px';
    resultDiv.style.borderRadius = '8px';
    resultDiv.style.border = result.significant ? '2px solid var(--success-color)' : '2px solid var(--danger-color)';

    let html = `
        <h4>${result.test} Results</h4>
        <p><strong>Parameter:</strong> ${paramName}</p>
        <p><strong>Groups:</strong> ${groupNames.join(', ')}</p>
    `;

    // Test-specific results
    if (result.test === 't-Test' || result.test === "Welch's t-Test") {
        html += `
            <div style="margin: 15px 0;">
                <p><strong>Test Statistic:</strong> t = ${utils.formatNumber(result.statistic, 4)}</p>
                <p><strong>Degrees of Freedom:</strong> df = ${utils.formatNumber(result.df, 2)}</p>
                <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)}</p>
                <p><strong>Effect Size (Cohen's d):</strong> ${utils.formatNumber(result.effectSize, 3)}</p>
                <p><strong>Mean Difference:</strong> ${utils.formatNumber(result.meanDifference, 3)}</p>
                <p><strong>${(1 - result.alpha) * 100}% Confidence Interval:</strong> [${utils.formatNumber(result.confidenceInterval[0], 3)}, ${utils.formatNumber(result.confidenceInterval[1], 3)}]</p>
            </div>
            <div style="margin: 15px 0;">
                <p><strong>Group 1:</strong> n=${result.group1Stats.count}, Mean=${utils.formatNumber(result.group1Stats.mean, 2)}, SD=${utils.formatNumber(result.group1Stats.stdDev, 2)}</p>
                <p><strong>Group 2:</strong> n=${result.group2Stats.count}, Mean=${utils.formatNumber(result.group2Stats.mean, 2)}, SD=${utils.formatNumber(result.group2Stats.stdDev, 2)}</p>
            </div>
        `;
    } else if (result.test === 'ANOVA') {
        html += `
            <div style="margin: 15px 0;">
                <p><strong>F-value:</strong> F(${result.dfBetween}, ${result.dfWithin}) = ${utils.formatNumber(result.statistic, 4)}</p>
                <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)}</p>
                <p><strong>Effect Size (η²):</strong> ${utils.formatNumber(result.etaSquared, 3)}</p>
            </div>
            <div style="background-color: rgba(255,255,255,0.05); padding: 10px; border-radius: 5px; margin: 10px 0;">
                <p><strong>Sum of Squares:</strong></p>
                <p>Between Groups: ${utils.formatNumber(result.ssb, 2)}</p>
                <p>Within Groups: ${utils.formatNumber(result.ssw, 2)}</p>
                <p>Mean Squares: MSB=${utils.formatNumber(result.msb, 2)}, MSW=${utils.formatNumber(result.msw, 2)}</p>
            </div>
        `;
        
        if (result.postHoc) {
            html += `
                <div style="margin-top: 20px; padding: 15px; background-color: var(--background-medium); border-radius: 6px;">
                    <h5>Post-hoc Analysis (${result.postHoc.method})</h5>
                    <table style="width: 100%; margin-top: 10px;">
                        <thead>
                            <tr>
                                <th>Comparison</th>
                                <th>Mean Difference</th>
                                <th>95% CI</th>
                                <th>Significant</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            result.postHoc.comparisons.forEach(comp => {
                html += `
                    <tr>
                        <td>Group ${comp.group1} vs Group ${comp.group2}</td>
                        <td>${utils.formatNumber(comp.meanDiff, 3)}</td>
                        <td>[${utils.formatNumber(comp.lowerCI, 3)}, ${utils.formatNumber(comp.upperCI, 3)}]</td>
                        <td>${comp.significant ? '✓ Yes' : '✗ No'}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
        }
    } else if (result.test === 'Mann-Whitney U') {
        html += `
            <div style="margin: 15px 0;">
                <p><strong>U Statistic:</strong> U = ${utils.formatNumber(result.U, 0)}</p>
                <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)}</p>
                <p><strong>Effect Size (r):</strong> ${utils.formatNumber(result.effectSize, 3)}</p>
                <p><strong>Sample Sizes:</strong> n₁ = ${result.n1}, n₂ = ${result.n2}</p>
                <p><strong>Rank Sums:</strong> R₁ = ${utils.formatNumber(result.rankSum1, 1)}, R₂ = ${utils.formatNumber(result.rankSum2, 1)}</p>
                ${result.tieCorrection ? '<p><em>Note: Tie correction was applied</em></p>' : ''}
            </div>
        `;
    } else if (result.test === 'Kruskal-Wallis') {
        html += `
            <div style="margin: 15px 0;">
                <p><strong>H Statistic:</strong> H = ${utils.formatNumber(result.H, 4)}</p>
                <p><strong>Degrees of Freedom:</strong> df = ${result.df}</p>
                <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)}</p>
                <p><strong>Effect Size (η²):</strong> ${utils.formatNumber(result.etaSquared, 3)}</p>
                <p><strong>Total N:</strong> ${result.N}</p>
                ${result.tieCorrection ? '<p><em>Note: Tie correction was applied</em></p>' : ''}
            </div>
        `;
        
        if (result.postHoc) {
            html += `
                <div style="margin-top: 20px; padding: 15px; background-color: var(--background-medium); border-radius: 6px;">
                    <h5>Post-hoc Analysis (${result.postHoc.method})</h5>
                    <p style="font-size: 12px; color: var(--text-light);">Adjusted α = ${result.postHoc.adjustedAlpha.toFixed(4)}</p>
                    <table style="width: 100%; margin-top: 10px;">
                        <thead>
                            <tr>
                                <th>Comparison</th>
                                <th>Mean Rank Diff</th>
                                <th>Z</th>
                                <th>p-value</th>
                                <th>Adjusted p</th>
                                <th>Significant</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            result.postHoc.comparisons.forEach(comp => {
                html += `
                    <tr>
                        <td>Group ${comp.group1} vs ${comp.group2}</td>
                        <td>${utils.formatNumber(comp.rankDiff, 2)}</td>
                        <td>${utils.formatNumber(comp.z, 3)}</td>
                        <td>${utils.formatNumber(comp.pValue, 4)}</td>
                        <td>${utils.formatNumber(comp.adjustedPValue, 4)}</td>
                        <td>${comp.significant ? '✓ Yes' : '✗ No'}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
        }
    } else if (result.test === 'Chi-Square') {
        html += `
            <div style="margin: 15px 0;">
                <p><strong>Chi-Square (χ²):</strong> ${utils.formatNumber(result.statistic, 4)}</p>
                <p><strong>Degrees of Freedom:</strong> df = ${result.df}</p>
                <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)}</p>
                <p><strong>Effect Size (Cramer's V):</strong> ${utils.formatNumber(result.cramersV, 3)}</p>
            </div>
        `;

        if (result.observed && result.categories && result.groups) {
            html += `
                <div style="margin: 15px 0;">
                    <p><strong>Contingency Table (Observed Frequencies):</strong></p>
                    <div style="overflow-x: auto; margin-top: 10px;">
                        <table style="width: auto;">
                            <thead>
                                <tr>
                                    <th>${paramName}</th>
                                    ${result.groups.map(group => `<th>${group}</th>`).join('')}
                                </tr>
                            </thead>
                            <tbody>
            `;

            result.categories.forEach((category, i) => {
                html += `<tr><td>${category}</td>`;
                result.observed[i].forEach(count => {
                    html += `<td>${count}</td>`;
                });
                html += `</tr>`;
            });

            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }
        
        if (result.postHoc) {
            html += `
                <div style="margin-top: 20px; padding: 15px; background-color: var(--background-medium); border-radius: 6px;">
                    <h5>Post-hoc Analysis (${result.postHoc.method})</h5>
                    <p style="font-size: 12px; color: var(--text-light);">Adjusted α = ${result.postHoc.adjustedAlpha.toFixed(4)}</p>
                    <table style="width: 100%; margin-top: 10px;">
                        <thead>
                            <tr>
                                <th>Comparison</th>
                                <th>χ²</th>
                                <th>df</th>
                                <th>p-value</th>
                                <th>Adjusted p</th>
                                <th>Significant</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            result.postHoc.comparisons.forEach(comp => {
                html += `
                    <tr>
                        <td>${comp.group1} vs ${comp.group2}</td>
                        <td>${utils.formatNumber(comp.chiSquare, 3)}</td>
                        <td>${comp.df}</td>
                        <td>${utils.formatNumber(comp.pValue, 4)}</td>
                        <td>${utils.formatNumber(comp.adjustedPValue, 4)}</td>
                        <td>${comp.significant ? '✓ Yes' : '✗ No'}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
        }

        if (result.warning) {
            html += `<p style="color: #e74c3c;"><strong>Warning:</strong> ${result.warning}</p>`;
        }
    } else if (result.test === "Fisher's Exact Test") {
        html += `
            <div style="margin: 15px 0;">
                <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)}</p>
                <p><strong>Odds Ratio:</strong> ${utils.formatNumber(result.oddsRatio, 3)}</p>
            </div>
        `;

        if (result.table && result.categories && result.groups) {
            html += `
                <div style="margin: 15px 0;">
                    <p><strong>2x2 Contingency Table:</strong></p>
                    <div style="overflow-x: auto; margin-top: 10px;">
                        <table style="width: auto;">
                            <thead>
                                <tr>
                                    <th>${paramName}</th>
                                    <th>${result.groups[0]}</th>
                                    <th>${result.groups[1]}</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>${result.categories[0]}</td>
                                    <td>${result.table[0][0]}</td>
                                    <td>${result.table[1][0]}</td>
                                </tr>
                                <tr>
                                    <td>${result.categories[1]}</td>
                                    <td>${result.table[0][1]}</td>
                                    <td>${result.table[1][1]}</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }
    } else if (result.test === 'Spearman Correlation' || result.test === 'Pearson Correlation') {
        html += `
            <div style="margin: 15px 0;">
                <p><strong>Correlation Coefficient:</strong> ${result.test === 'Spearman' ? 'ρ' : 'r'} = ${utils.formatNumber(result.rho || result.r, 4)}</p>
                <p><strong>p-value:</strong> ${utils.formatNumber(result.pValue, 6)}</p>
                <p><strong>Sample Size:</strong> n = ${result.n}</p>
                <p><strong>Interpretation:</strong> ${result.interpretation}</p>
            </div>
        `;
    }

    // Simple result summary
    html += `
        <div style="margin-top: 20px; padding: 15px; border-radius: 5px; ${result.significant ? 'background-color: rgba(82, 163, 115, 0.1);' : 'background-color: rgba(200, 84, 80, 0.1);'}">
            <p><strong>Result:</strong> ${result.significant ? 
                `🟢 <strong>Significant</strong> (p = ${utils.formatNumber(result.pValue, 6)} < α = ${result.alpha})` :
                `🔴 <strong>Not Significant</strong> (p = ${utils.formatNumber(result.pValue, 6)} ≥ α = ${result.alpha})`
            }</p>
        </div>
    `;

    resultDiv.innerHTML = html;

    if (container.firstChild) {
        container.insertBefore(resultDiv, container.firstChild);
    } else {
        container.appendChild(resultDiv);
    }
}



        /**
         * Generate custom visualization
         */
        function generateCustomVisualization() {
            const paramX = document.getElementById('viz-parameter-x').value;
            const paramY = document.getElementById('viz-parameter-y').value;
            const chartType = document.getElementById('viz-chart-type').value;

            if (!paramX) {
                utils.showError("Please select a parameter for the X-axis.");
                return;
            }

            if (!paramY && chartType !== 'bar') {
                utils.showError("Please select a parameter for the Y-axis.");
                return;
            }

            // Get selected groups for visualization
const selectedGroups = [];
const allGroups = Object.keys(globalState.currentGroups);

// Create group selection dialog if not exists
if (!document.getElementById('viz-group-selection-container')) {
    const vizControls = document.querySelector('.regression-controls') || document.querySelector('#visualization .flex-container');
    const selectionDiv = document.createElement('div');
    selectionDiv.id = 'viz-group-selection-container';
    selectionDiv.style.cssText = 'margin-bottom: 20px; padding: 15px; background-color: var(--background-medium); border-radius: 8px; border: 1px solid var(--border-color);';
    selectionDiv.innerHTML = `
        <div style="margin-bottom: 10px;">
            <strong>Select Groups to Display:</strong>
            <button id="viz-select-all" class="btn btn-small btn-primary" style="margin-left: 10px;">Select All</button>
            <button id="viz-select-none" class="btn btn-small btn-accent">Select None</button>
        </div>
        <div id="viz-group-selection" style="display: flex; flex-wrap: wrap; gap: 10px;"></div>
    `;
    vizControls.parentNode.insertBefore(selectionDiv, vizControls.nextSibling);
    
    // Populate group checkboxes
    const groupContainer = document.getElementById('viz-group-selection');
    Object.entries(globalState.currentGroups).forEach(([groupId, group]) => {
        const color = group.customColor || groupColors[group.colorIndex];
        const bgColor = typeof color === 'string' ? color : color.bg;
        
        const checkboxDiv = document.createElement('div');
        checkboxDiv.className = 'checkbox-container';
        checkboxDiv.style.marginBottom = '0';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `viz-group-${groupId}`;
        checkbox.value = groupId;
        checkbox.checked = true;
        
        const label = document.createElement('label');
        label.htmlFor = `viz-group-${groupId}`;
        label.innerHTML = `<span class="group-badge" style="background-color: ${bgColor};">${group.name}</span>`;
        
        checkboxDiv.appendChild(checkbox);
        checkboxDiv.appendChild(label);
        groupContainer.appendChild(checkboxDiv);
    });
    
    // Add event listeners
    document.getElementById('viz-select-all').addEventListener('click', () => {
        document.querySelectorAll('#viz-group-selection input[type="checkbox"]').forEach(cb => cb.checked = true);
    });
    
    document.getElementById('viz-select-none').addEventListener('click', () => {
        document.querySelectorAll('#viz-group-selection input[type="checkbox"]').forEach(cb => cb.checked = false);
    });
}

// Get selected groups
document.querySelectorAll('#viz-group-selection input:checked').forEach(checkbox => {
    selectedGroups.push(checkbox.value);
});

if (selectedGroups.length === 0) {
    utils.showError("Please select at least one group to visualize.");
    return;
}

            const ctx = document.getElementById('custom-visualization-chart').getContext('2d');
            utils.destroyChart('custom-visualization-chart');

            if (chartType === 'scatter') {
                createScatterPlot(ctx, paramX, paramY);
            } else if (chartType === 'bar' || chartType === 'line') {
                createBarOrLinePlot(ctx, paramX, paramY, chartType);
            }
        }

        function createCorrelationMatrix(ctx) {
    // Get all numeric parameters
    const numericParams = globalState.columnNames.filter(name =>
        scaleTypes[globalState.columnTypes[name]].numeric
    );
    
    if (numericParams.length < 2) {
        utils.showError("Need at least 2 numeric parameters for correlation matrix.");
        return;
    }
    
    // Calculate correlations for each group
    const correlationData = {};
    
    Object.entries(globalState.currentGroups).forEach(([groupId, group]) => {
        const correlations = [];
        
        for (let i = 0; i < numericParams.length; i++) {
            correlations[i] = [];
            for (let j = 0; j < numericParams.length; j++) {
                if (i === j) {
                    correlations[i][j] = 1;
                } else {
                    const data1 = globalState.processedData[groupId]
                        .map(row => utils.parseNumericValue(row[numericParams[i]]))
                        .filter(val => !isNaN(val));
                    const data2 = globalState.processedData[groupId]
                        .map(row => utils.parseNumericValue(row[numericParams[j]]))
                        .filter(val => !isNaN(val));
                    
                    // Calculate correlation
                    const pairs = [];
                    for (let k = 0; k < Math.min(data1.length, data2.length); k++) {
                        if (!isNaN(data1[k]) && !isNaN(data2[k])) {
                            pairs.push({ x: data1[k], y: data2[k] });
                        }
                    }
                    
                    if (pairs.length >= 3) {
                        const r = statistics.ss.sampleCorrelation(
                            pairs.map(p => p.x),
                            pairs.map(p => p.y)
                        );
                        correlations[i][j] = r;
                        
                        // Test significance
                        const n = pairs.length;
                        const t = r * Math.sqrt((n - 2) / (1 - r * r));
                        const df = n - 2;
                        const pValue = 2 * (1 - statistics.jstat.studentt.cdf(Math.abs(t), df));
                        correlations[i][j] = { r: r, p: pValue, n: n };
                    } else {
                        correlations[i][j] = { r: null, p: null, n: 0 };
                    }
                }
            }
        }
        
        correlationData[groupId] = correlations;
    });
    
    // Create heatmap visualization
    const groupIds = Object.keys(globalState.currentGroups);
    const datasets = [];
    
    // For simplicity, show first group's correlations as heatmap
    const firstGroupId = groupIds[0];
    const correlations = correlationData[firstGroupId];
    
    // Flatten correlation matrix for heatmap
    const data = [];
    for (let i = 0; i < numericParams.length; i++) {
        for (let j = 0; j < numericParams.length; j++) {
            const corr = correlations[i][j];
            if (typeof corr === 'object') {
                data.push({
                    x: numericParams[j],
                    y: numericParams[i],
                    v: corr.r !== null ? corr.r : 0,
                    p: corr.p,
                    n: corr.n
                });
            } else {
                data.push({
                    x: numericParams[j],
                    y: numericParams[i],
                    v: corr
                });
            }
        }
    }
    
    // Create heatmap chart
    utils.destroyChart('custom-visualization-chart');
    
    globalState.charts['custom-visualization-chart'] = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                label: globalState.currentGroups[firstGroupId].name,
                data: data.map(d => ({ x: d.x, y: d.y })),
                backgroundColor: data.map(d => {
                    const r = d.v;
                    if (r === null || r === undefined) return 'rgba(128, 128, 128, 0.5)';
                    const intensity = Math.abs(r);
                    if (r > 0) {
                        return `rgba(90, 159, 212, ${intensity})`;
                    } else {
                        return `rgba(200, 84, 80, ${intensity})`;
                    }
                }),
                pointRadius: 30,
                pointHoverRadius: 35
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'category',
                    position: 'bottom',
                    ticks: {
                        color: '#e0e0e0'
                    },
                    grid: {
                        color: '#444'
                    }
                },
                y: {
                    type: 'category',
                    ticks: {
                        color: '#e0e0e0'
                    },
                    grid: {
                        color: '#444'
                    }
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: `Correlation Matrix - ${globalState.currentGroups[firstGroupId].name}`,
                    font: { size: 16 },
                    color: '#e0e0e0'
                },
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const dataPoint = data.find(d => 
                                d.x === context.label && 
                                d.y === context.dataset.data[context.dataIndex].y
                            );
                            
                            if (!dataPoint || dataPoint.v === null) {
                                return 'No data';
                            }
                            
                            const lines = [
                                `r = ${dataPoint.v.toFixed(3)}`
                            ];
                            
                            if (dataPoint.p !== undefined && dataPoint.p !== null) {
                                lines.push(`p = ${dataPoint.p.toFixed(4)}`);
                                lines.push(dataPoint.p < 0.05 ? 'Significant' : 'Not significant');
                            }
                            
                            if (dataPoint.n !== undefined) {
                                lines.push(`n = ${dataPoint.n}`);
                            }
                            
                            // Add interpretation
                            const interp = interpretationEngine.effectSize.correlation(dataPoint.v);
                            lines.push(interp.description);
                            
                            return lines;
                        }
                    }
                }
            }
        },
        plugins: [{
            id: 'correlationLabels',
            afterDatasetsDraw: function(chart) {
                const ctx = chart.ctx;
                ctx.save();
                
                chart.data.datasets.forEach((dataset, i) => {
                    chart.getDatasetMeta(i).data.forEach((element, index) => {
                        const dataPoint = data[index];
                        if (dataPoint && dataPoint.v !== null && dataPoint.v !== undefined) {
                            const x = element.x;
                            const y = element.y;
                            
                            ctx.fillStyle = Math.abs(dataPoint.v) > 0.5 ? 'white' : '#e0e0e0';
                            ctx.font = 'bold 12px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(dataPoint.v.toFixed(2), x, y);
                            
                            // Add significance indicator
                            if (dataPoint.p !== undefined && dataPoint.p < 0.05) {
                                ctx.font = '10px Arial';
                                ctx.fillText('*', x, y + 10);
                            }
                        }
                    });
                });
                
                ctx.restore();
            }
        }]
    });
}

        /**
         * Create scatter plot with optional regression lines
         */
        function createScatterPlot(ctx, paramX, paramY) {
            const datasets = [];
            const showRegression = document.getElementById('show-regression').checked;
            const regressionType = document.getElementById('regression-type').value;
            let alpha = 0.05;
const alphaSelect = document.getElementById('regression-alpha');
if (alphaSelect.value === 'custom') {
    alpha = parseFloat(document.getElementById('regression-custom-alpha').value);
    if (isNaN(alpha) || alpha <= 0 || alpha >= 1) {
        alpha = 0.05;
    }
} else {
    alpha = parseFloat(alphaSelect.value);
}
            let regressionInfo = '';

            // Check if both parameters are numeric for scatter plot
            const xIsNumeric = scaleTypes[globalState.columnTypes[paramX]].numeric;
            const yIsNumeric = scaleTypes[globalState.columnTypes[paramY]].numeric;

            if (!xIsNumeric || !yIsNumeric) {
                utils.showError("Scatter plot requires both X and Y axes to be numeric parameters (ordinal, interval, or ratio scale).");
                return;
            }

            // Get scale types for proper Y-axis range calculation
            const yScaleType = globalState.columnTypes[paramY];

            // Process each group
            // Get selected groups from visualization controls
const vizSelectedGroups = [];
document.querySelectorAll('#viz-group-selection input:checked').forEach(checkbox => {
    vizSelectedGroups.push(checkbox.value);
});

Object.entries(globalState.currentGroups).forEach(([groupId, group], index) => {
    // Skip if group not selected
    if (vizSelectedGroups.length > 0 && !vizSelectedGroups.includes(groupId)) {
        return;
    }
                const color = group.customColor || groupColors[group.colorIndex];
                const bgColor = typeof color === 'string' ? color : color.bg;
                const borderColor = typeof color === 'string' ? color.replace('B3', '') : color.border;

                const points = globalState.processedData[groupId].map(row => {
                    const x = utils.parseNumericValue(row[paramX]);
                    const y = utils.parseNumericValue(row[paramY]);
                    return { x, y };
                }).filter(point => !isNaN(point.x) && !isNaN(point.y) && isFinite(point.x) && isFinite(point.y));

                if (points.length > 0) {
                    // Add scatter points
                    datasets.push({
                        label: group.name,
                        data: points,
                        backgroundColor: bgColor,
                        borderColor: borderColor,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        showLine: false
                    });

                    // Add regression line if requested
                    if (showRegression && points.length >= regressionTypes[regressionType].minPoints) {
                        let regression = null;

                        // Check if regression type is valid for the data
                        if (regressionTypes[regressionType].validate) {
                            if (!regressionTypes[regressionType].validate(points)) {
                                regressionInfo += `
                                    <div style="margin-bottom: 10px; color: ${borderColor};">
                                        <strong>${group.name}:</strong> Invalid data for ${regressionTypes[regressionType].name} regression
                                    </div>
                                `;
                                return;
                            }
                        }

                        // Calculate regression based on type
                        switch (regressionType) {
                            case 'linear':
                                regression = statistics.linearRegression(points);
                                break;
                            case 'polynomial2':
                                regression = statistics.polynomialRegression(points, 2);
                                break;
                            case 'polynomial3':
                                regression = statistics.polynomialRegression(points, 3);
                                break;
                            case 'logarithmic':
                                regression = statistics.logarithmicRegression(points);
                                break;
                            case 'exponential':
                                regression = statistics.exponentialRegression(points);
                                break;
                        }

                        if (regression && regression.predict) {
                            // Test regression significance
                            const sigTest = statistics.testRegressionSignificance(regression, regressionType, alpha);

                            // Calculate line points
                            const xValues = points.map(p => p.x);
                            const minX = Math.min(...xValues);
                            const maxX = Math.max(...xValues);

                            // Generate smooth curve for non-linear regressions
                            const numPoints = regressionType === 'linear' ? 2 : 100;
                            const linePoints = [];

                            for (let i = 0; i < numPoints; i++) {
                                const x = minX + (maxX - minX) * i / (numPoints - 1);
                                const y = regression.predict(x);
                                if (isFinite(y)) {
                                    linePoints.push({ x, y });
                                }
                            }

                            // Add regression line dataset
                            datasets.push({
                                label: `${group.name} Regression`,
                                data: linePoints,
                                backgroundColor: 'transparent',
                                borderColor: borderColor,
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                showLine: true,
                                fill: false
                            });

                            // Add to regression info with significance
                            const sigClass = sigTest.significant ? 'significant' : 'not-significant';
                            regressionInfo += `
                                <div class="regression-significance ${sigClass}" style="margin-bottom: 10px;">
                                    <div style="color: ${borderColor};">
                                        <strong>${group.name}:</strong> ${regression.equation}<br>
                                        R² = ${utils.formatNumber(regression.r2, 4)}, n = ${regression.n}
                                        ${regression.conditionNumber ? `<br><small>Condition number: ${utils.formatNumber(regression.conditionNumber, 2)}</small>` : ''}
                                    </div>
                            `;

                            if (sigTest.error) {
                                regressionInfo += `<div style="font-size: 0.85em; margin-top: 5px;">${sigTest.error}</div>`;
                            } else {
                                regressionInfo += `
                                    <div style="font-size: 0.85em; margin-top: 5px;">
                                        ${sigTest.fStatistic ? `F(${sigTest.df1},${sigTest.df2}) = ${utils.formatNumber(sigTest.fStatistic, 3)}, ` : ''}
                                        p = ${utils.formatNumber(sigTest.pValue, 4)}
                                        ${sigTest.significant ?
                                        `<span style="color: var(--secondary-color); font-weight: bold;"> ✓ Significant</span>` :
                                        `<span style="color: var(--danger-color);"> Not significant</span>`}
                                    </div>
                                `;
                            }

                            regressionInfo += `</div>`;
                        }
                    }
                }
            });

            if (datasets.length === 0) {
                utils.showError("No valid data points to display.");
                return;
            }

            // Update regression info display
            document.getElementById('regression-info').innerHTML = regressionInfo;

            // Y-axis range
            const allYValues = datasets
                .filter(ds => !ds.label.includes('Regression'))
                .flatMap(ds => ds.data.map(point => point.y));
            const yRange = utils.calculateYAxisRange(allYValues, yScaleType);

            // X-axis range
            const allXValues = datasets
                .filter(ds => !ds.label.includes('Regression'))
                .flatMap(ds => ds.data.map(point => point.x));
            const xMin = Math.min(...allXValues);
            const xMax = Math.max(...allXValues);
            const xPadding = (xMax - xMin) * 0.05;

            globalState.charts['custom-visualization-chart'] = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            min: xMin - xPadding,
                            max: xMax + xPadding,
                            title: {
                                display: true,
                                text: paramX,
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        },
                        y: {
                            min: yRange.min,
                            max: yRange.max,
                            title: {
                                display: true,
                                text: paramY,
                                color: '#e0e0e0'
                            },
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: {
                                color: '#444'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `${paramY} vs ${paramX}`,
                            font: { size: 16 },
                            color: '#e0e0e0'
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                filter: function (item) {
                                    // Hide regression labels from legend
                                    return !item.text.includes('Regression');
                                },
                                color: '#e0e0e0'
                            }
                        }
                    }
                }
            });
        }

        /**
         * Create bar or line plot
         */
        function createBarOrLinePlot(ctx, paramX, paramY, chartType) {
            // For categorical X-axis, aggregate data
            if (!scaleTypes[globalState.columnTypes[paramX]].numeric) {
                const categories = [...new Set(globalState.rawData.map(row => row[paramX]).filter(val => val))];

                const datasets = [];

                // Get selected groups from visualization controls
const vizSelectedGroups = [];
document.querySelectorAll('#viz-group-selection input:checked').forEach(checkbox => {
    vizSelectedGroups.push(checkbox.value);
});

Object.entries(globalState.currentGroups).forEach(([groupId, group], index) => {
    // Skip if group not selected
    if (vizSelectedGroups.length > 0 && !vizSelectedGroups.includes(groupId)) {
        return;
    }
                    const color = group.customColor || groupColors[group.colorIndex];
                    const bgColor = typeof color === 'string' ? color : color.bg;
                    const borderColor = typeof color === 'string' ? color.replace('B3', '') : color.border;

                    const categoryMeans = categories.map(category => {
                        const categoryValues = globalState.processedData[groupId]
                            .filter(row => row[paramX] === category)
                            .map(row => utils.parseNumericValue(row[paramY]))
                            .filter(val => !isNaN(val));

                        return categoryValues.length > 0 ?
                            categoryValues.reduce((sum, val) => sum + val, 0) / categoryValues.length : 0;
                    });

                    datasets.push({
                        label: group.name,
                        data: categoryMeans,
                        backgroundColor: chartType === 'bar' ? bgColor : 'transparent',
                        borderColor: borderColor,
                        borderWidth: 2,
                        fill: false
                    });
                });

                // Y-axis range
                const allYValues = datasets.flatMap(ds => ds.data);
                const yScaleType = globalState.columnTypes[paramY];
                const yRange = utils.calculateYAxisRange(allYValues, yScaleType);

                globalState.charts['custom-visualization-chart'] = new Chart(ctx, {
                    type: chartType,
                    data: {
                        labels: categories,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: paramX,
                                    color: '#e0e0e0'
                                },
                                ticks: {
                                    color: '#e0e0e0'
                                },
                                grid: {
                                    color: '#444'
                                }
                            },
                            y: {
                                min: yRange.min,
                                max: yRange.max,
                                title: {
                                    display: true,
                                    text: paramY,
                                    color: '#e0e0e0'
                                },
                                ticks: {
                                    color: '#e0e0e0'
                                },
                                grid: {
                                    color: '#444'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `${paramY} by ${paramX}`,
                                font: { size: 16 },
                                color: '#e0e0e0'
                            },
                            legend: {
                                position: 'top',
                                labels: {
                                    color: '#e0e0e0'
                                }
                            }
                        }
                    }
                });
            } else {
                utils.showError("Bar and line plots require a categorical parameter for the X-axis.");
            }
        }

        /**
         * Generate fourfold table analysis
         */
        function generateFourfoldTable() {
            const testConstellationName = document.getElementById('fourfold-constellation-1').value;
            const trueConditionConstellationName = document.getElementById('fourfold-constellation-2').value;
            const not1 = document.getElementById('fourfold-not-1').checked;
            const not2 = document.getElementById('fourfold-not-2').checked;

            if (!testConstellationName || !trueConditionConstellationName) {
                utils.showError("Please select both test and true condition constellations.");
                return;
            }

            // Find constellations by name
            const testConstellation = globalState.parameterConstellations.find(c => c.name === testConstellationName);
            const trueConditionConstellation = globalState.parameterConstellations.find(c => c.name === trueConditionConstellationName);

            if (!testConstellation || !trueConditionConstellation) {
                utils.showError("Invalid constellation selection.");
                return;
            }

            // Create 2x2 table
            const table = [[0, 0], [0, 0]];

            globalState.rawData.forEach(row => {
                let matchesTest = checkRowAgainstConditions(row, testConstellation.conditions);
                let matchesTrueCondition = checkRowAgainstConditions(row, trueConditionConstellation.conditions);

                // Apply NOT if selected
                if (not1) matchesTest = !matchesTest;
                if (not2) matchesTrueCondition = !matchesTrueCondition;

                if (matchesTest && matchesTrueCondition) {
                    table[0][0]++; // True Positive
                } else if (matchesTest && !matchesTrueCondition) {
                    table[0][1]++; // False Positive
                } else if (!matchesTest && matchesTrueCondition) {
                    table[1][0]++; // False Negative
                } else {
                    table[1][1]++; // True Negative
                }
            });

            // Calculate comprehensive statistics
            const stats = statistics.calculateFourfoldStatistics(table);
            const diagnosticMetrics = statistics.calculateDiagnosticMetrics(table);
            const validation = statistics.validateDiagnosticTestData(table);

            // Store for export
            globalState.fourfoldResults = {
                testConstellation: testConstellation.name,
                trueConditionConstellation: trueConditionConstellation.name,
                not1: not1,
                not2: not2,
                table: table,
                stats: stats,
                diagnosticMetrics: diagnosticMetrics,
                validation: validation
            };

            // Display results
            const resultsDiv = document.getElementById('fourfold-results');

            const testName = not1 ? `NOT ${testConstellation.name}` : testConstellation.name;
            const conditionName = not2 ? `NOT ${trueConditionConstellation.name}` : trueConditionConstellation.name;

            let html = `
        <h4>Diagnostic Test Analysis</h4>
        <p><strong>Test:</strong> ${testName} | <strong>True Condition:</strong> ${conditionName}</p>
    `;

            // Add validation warnings/errors if any
            if (!validation.isValid || validation.warnings.length > 0) {
                html += '<div class="validation-warnings" style="margin: 16px 0;">';
                html += '<h4>⚠️ Data Validation Issues</h4>';

                if (validation.errors.length > 0) {
                    html += '<div style="color: var(--danger-color); margin-bottom: 10px;"><strong>Errors:</strong><ul>';
                    validation.errors.forEach(error => {
                        html += `<li>${error}</li>`;
                    });
                    html += '</ul></div>';
                }

                if (validation.warnings.length > 0) {
                    html += '<div style="color: var(--warning-color);"><strong>Warnings:</strong><ul>';
                    validation.warnings.forEach(warning => {
                        html += `<li>${warning}</li>`;
                    });
                    html += '</ul></div>';
                }

                html += '</div>';
            }

            // Display the contingency table
            html += `
        <div class="fourfold-grid">
            <div class="fourfold-cell fourfold-header"></div>
            <div class="fourfold-cell fourfold-header">${conditionName} (+)</div>
            <div class="fourfold-cell fourfold-header">${conditionName} (−)</div>
            
            <div class="fourfold-cell fourfold-header">${testName} (+)</div>
            <div class="fourfold-cell">
                <span class="fourfold-value">${table[0][0]}</span>
                <div style="font-size: 0.8em; color: #888;">TP</div>
            </div>
            <div class="fourfold-cell">
                <span class="fourfold-value">${table[0][1]}</span>
                <div style="font-size: 0.8em; color: #888;">FP</div>
            </div>
            
            <div class="fourfold-cell fourfold-header">${testName} (−)</div>
            <div class="fourfold-cell">
                <span class="fourfold-value">${table[1][0]}</span>
                <div style="font-size: 0.8em; color: #888;">FN</div>
            </div>
            <div class="fourfold-cell">
                <span class="fourfold-value">${table[1][1]}</span>
                <div style="font-size: 0.8em; color: #888;">TN</div>
            </div>
        </div>
    `;

            // Only show diagnostic metrics if data is valid
            if (validation.isValid) {
                html += `
            <h5 style="margin-top: 24px;">Diagnostic Test Metrics</h5>
            <div class="fourfold-statistics">
        `;

                // Helper function to add metric cards
                const addMetricCard = (title, value, ci = null, suffix = '%', decimals = 1) => {
                    if (!isNaN(value) && isFinite(value)) {
                        let cardHtml = `
                    <div class="fourfold-stat-card">
                        <h5>${title}</h5>
                        <div class="fourfold-stat-value">${utils.formatNumber(value * (suffix === '%' ? 100 : 1), decimals)}${suffix}</div>
                `;
                        if (ci && !isNaN(ci[0]) && !isNaN(ci[1])) {
                            cardHtml += `
                        <div style="font-size: 0.9em; color: #666;">
                            95% CI: [${utils.formatNumber(ci[0] * 100, decimals)}${suffix}, ${utils.formatNumber(ci[1] * 100, decimals)}${suffix}]
                        </div>
                    `;
                        }
                        cardHtml += '</div>';
                        return cardHtml;
                    } else {
                        return `
                    <div class="fourfold-stat-card">
                        <h5>${title}</h5>
                        <div class="fourfold-stat-value" style="color: #666;">N/A</div>
                        <div style="font-size: 0.9em; color: #666;">Cannot calculate</div>
                    </div>
                `;
                    }
                };

                // Add all diagnostic metrics
                html += addMetricCard('Sensitivity', diagnosticMetrics.sensitivity, diagnosticMetrics.sensitivityCI);
                html += addMetricCard('Specificity', diagnosticMetrics.specificity, diagnosticMetrics.specificityCI);
                html += addMetricCard('PPV', diagnosticMetrics.ppv, diagnosticMetrics.ppvCI);
                html += addMetricCard('NPV', diagnosticMetrics.npv, diagnosticMetrics.npvCI);
                html += addMetricCard('Accuracy', diagnosticMetrics.accuracy);
                html += addMetricCard('Prevalence', diagnosticMetrics.prevalence);

                // Likelihood ratios (no percentage)
                if (!isNaN(diagnosticMetrics.lrPositive) && isFinite(diagnosticMetrics.lrPositive)) {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>LR+</h5>
                    <div class="fourfold-stat-value">${utils.formatNumber(diagnosticMetrics.lrPositive, 2)}</div>
                    <div style="font-size: 0.9em; color: #666;">Positive Likelihood Ratio</div>
                </div>
            `;
                } else {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>LR+</h5>
                    <div class="fourfold-stat-value" style="color: #666;">${diagnosticMetrics.lrPositive === Infinity ? '∞' : 'N/A'}</div>
                    <div style="font-size: 0.9em; color: #666;">Positive Likelihood Ratio</div>
                </div>
            `;
                }

                if (!isNaN(diagnosticMetrics.lrNegative) && isFinite(diagnosticMetrics.lrNegative)) {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>LR−</h5>
                    <div class="fourfold-stat-value">${utils.formatNumber(diagnosticMetrics.lrNegative, 2)}</div>
                    <div style="font-size: 0.9em; color: #666;">Negative Likelihood Ratio</div>
                </div>
            `;
                } else {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>LR−</h5>
                    <div class="fourfold-stat-value" style="color: #666;">${diagnosticMetrics.lrNegative === Infinity ? '∞' : 'N/A'}</div>
                    <div style="font-size: 0.9em; color: #666;">Negative Likelihood Ratio</div>
                </div>
            `;
                }

                // Additional metrics
                html += addMetricCard('Youden\'s Index', diagnosticMetrics.youdenIndex, null, '', 3);
                html += addMetricCard('F1 Score', diagnosticMetrics.f1Score, null, '', 3);

                // DOR with special handling for infinity
                if (!isNaN(diagnosticMetrics.dor) && isFinite(diagnosticMetrics.dor)) {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>DOR</h5>
                    <div class="fourfold-stat-value">${utils.formatNumber(diagnosticMetrics.dor, 2)}</div>
                    <div style="font-size: 0.9em; color: #666;">Diagnostic Odds Ratio</div>
                </div>
            `;
                } else {
                    html += `
                <div class="fourfold-stat-card">
                    <h5>DOR</h5>
                    <div class="fourfold-stat-value" style="color: #666;">${diagnosticMetrics.dor === Infinity ? '∞' : 'N/A'}</div>
                    <div style="font-size: 0.9em; color: #666;">Diagnostic Odds Ratio</div>
                </div>
            `;
                }

                html += addMetricCard('MCC', diagnosticMetrics.mcc, null, '', 3);

                html += '</div>';
            } else {
                html += `
            <div class="error" style="margin-top: 20px;">
                <strong>Diagnostic test metrics cannot be calculated due to data issues.</strong>
                <p>Please review the validation errors above and ensure your data has cases in all necessary categories.</p>
            </div>
        `;
            }

            // Always show association measures
            html += `
        <h5 style="margin-top: 24px;">Association Measures</h5>
        <div class="fourfold-statistics">
            <div class="fourfold-stat-card">
                <h5>Sample Size</h5>
                <div class="fourfold-stat-value">${stats.n}</div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Odds Ratio</h5>
                <div class="fourfold-stat-value">${utils.formatNumber(stats.odds.oddsRatio, 3)}</div>
                <div style="font-size: 0.9em; color: #666;">
                    95% CI: [${utils.formatNumber(stats.odds.oddsRatioCI[0], 3)}, ${utils.formatNumber(stats.odds.oddsRatioCI[1], 3)}]
                </div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Risk Difference</h5>
                <div class="fourfold-stat-value">${utils.formatNumber(stats.risk.riskDifference, 3)}</div>
                <div style="font-size: 0.9em; color: #666;">
                    95% CI: [${utils.formatNumber(stats.risk.riskDifferenceCI[0], 3)}, ${utils.formatNumber(stats.risk.riskDifferenceCI[1], 3)}]
                </div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Risk Ratio</h5>
                <div class="fourfold-stat-value">${utils.formatNumber(stats.risk.riskRatio, 3)}</div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Number Needed to Treat</h5>
                <div class="fourfold-stat-value">${utils.formatNumber(stats.risk.nnt, 1)}</div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Chi-Square Test</h5>
                <div class="fourfold-stat-value">χ² = ${utils.formatNumber(stats.chiSquare.statistic, 3)}</div>
                <div style="font-size: 0.9em; color: #666;">
                    p = ${utils.formatNumber(stats.chiSquare.pValue, 4)}
                    ${stats.chiSquare.pValue < 0.05 ?
                    '<span style="color: var(--secondary-color); font-weight: bold;"> ✓ Significant</span>' :
                    '<span style="color: var(--danger-color);"> Not significant</span>'}
                </div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Fisher's Exact Test</h5>
                <div class="fourfold-stat-value">p = ${utils.formatNumber(stats.fisherExact.pValue, 4)}</div>
                <div style="font-size: 0.9em; color: #666;">
                    ${stats.fisherExact.pValue < 0.05 ?
                    '<span style="color: var(--secondary-color); font-weight: bold;"> ✓ Significant</span>' :
                    '<span style="color: var(--danger-color);"> Not significant</span>'}
                </div>
            </div>
            
            <div class="fourfold-stat-card">
                <h5>Phi Coefficient</h5>
                <div class="fourfold-stat-value">${utils.formatNumber(stats.phi, 3)}</div>
                <div style="font-size: 0.9em; color: #666;">Effect size</div>
            </div>
        </div>
    `;

            resultsDiv.innerHTML = html;

            // Show export button
            document.getElementById('fourfold-export').style.display = 'block';
        }

        /**
         * Export chart as image
         */
        function exportChartAsImage(chartId) {
    const canvas = document.getElementById(chartId);
    if (!canvas) {
        utils.showError(`Chart with ID "${chartId}" not found.`);
        return;
    }

    // Create container with styling
    const container = document.createElement('div');
    container.style.backgroundColor = '#1a1a1a';
    container.style.padding = '20px';
    container.style.width = canvas.width + 'px';

    const title = document.createElement('h3');
    title.textContent = chartId.replace(/-/g, ' ').replace(/chart/g, 'Chart');
    title.style.textAlign = 'center';
    title.style.fontFamily = 'Arial, sans-serif';
    title.style.marginBottom = '10px';
    title.style.color = '#e0e0e0';
    container.appendChild(title);

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(canvas, 0, 0);
    container.appendChild(tempCanvas);

    const dateText = document.createElement('div');
    dateText.textContent = `Generated: ${new Date().toLocaleDateString()}`;
    dateText.style.textAlign = 'right';
    dateText.style.fontFamily = 'Arial, sans-serif';
    dateText.style.fontSize = '12px';
    dateText.style.marginTop = '10px';
    dateText.style.color = '#e0e0e0';
    container.appendChild(dateText);

    document.body.appendChild(container);

    html2canvas(container).then(resultCanvas => {
        const image = resultCanvas.toDataURL('image/png', 1.0);
        const timestamp = utils.getTimestamp();
        const link = document.createElement('a');
        link.href = image;
        link.download = `sra-${timestamp}-${chartId}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        document.body.removeChild(container);
        utils.showSuccess('Chart successfully exported as PNG!');
    });
}

        /**
         * Export analysis results as CSV
         */
        function exportAnalysisResults() {
            const includeRawData = document.getElementById('export-raw-data').checked;
            const includeStatistics = document.getElementById('export-statistics').checked;
            const includeDefinitions = document.getElementById('export-group-definitions').checked;

            let csvContent = '\uFEFF'; // UTF-8 BOM for Excel

            // Group definitions and constellations
            if (includeDefinitions) {
                csvContent += 'PARAMETER CONSTELLATIONS\n';
                csvContent += 'Constellation Name' + globalState.csvDelimiter + 'Conditions\n';

                globalState.parameterConstellations.forEach(constellation => {
                    const conditions = constellation.conditions.map(condition => {
                        if (condition.parameter === '__all_data__') {
                            return 'All Data';
                        }
                        return `"${condition.parameter}" ${condition.operator} ${condition.value}`;
                    }).join(' AND ');

                    csvContent += constellation.name + globalState.csvDelimiter + '"' + conditions + '"\n';
                });

                csvContent += '\n';

                csvContent += 'GROUP DEFINITIONS\n';
                csvContent += 'Group' + globalState.csvDelimiter + 'Conditions' + globalState.csvDelimiter + 'Constellations' + globalState.csvDelimiter + 'Not In Previous' + globalState.csvDelimiter + 'Included\n';

                globalState.groupDefinitions.forEach(group => {
                    const conditions = group.conditions.map(condition => {
                        if (condition.parameter === '__all_data__') {
                            return 'All Data';
                        }
                        return `"${condition.parameter}" ${condition.operator} ${condition.value}`;
                    }).join(' AND ');

                    const constellations = group.constellations.map(c => c.negated ? `NOT ${c.name}` : c.name).join(', ');

                    csvContent += group.name + globalState.csvDelimiter;
                    csvContent += '"' + conditions + '"' + globalState.csvDelimiter;
                    csvContent += '"' + constellations + '"' + globalState.csvDelimiter;
                    csvContent += group.notInPrevious + globalState.csvDelimiter;
                    csvContent += group.includeInAnalysis + '\n';
                });

                csvContent += '\n';
            }

            // Statistical metrics
            if (includeStatistics) {
                csvContent += 'STATISTICAL METRICS\n';

                globalState.columnNames.forEach(paramName => {
                    const paramType = globalState.columnTypes[paramName];

                    if (scaleTypes[paramType].numeric) {
                        csvContent += `\nParameter: ${paramName} (${scaleTypes[paramType].name})\n`;

                        if (paramType === 'o') {
                            csvContent += 'Group' + globalState.csvDelimiter + 'Count' + globalState.csvDelimiter + 'Median' + globalState.csvDelimiter + 'Q1' + globalState.csvDelimiter + 'Q3' + globalState.csvDelimiter + 'IQR' + globalState.csvDelimiter + 'Min' + globalState.csvDelimiter + 'Max' + globalState.csvDelimiter + 'Range\n';
                        } else {
                            csvContent += 'Group' + globalState.csvDelimiter + 'Count' + globalState.csvDelimiter + 'Mean' + globalState.csvDelimiter + 'Median' + globalState.csvDelimiter + 'Std Dev' + globalState.csvDelimiter + 'Min' + globalState.csvDelimiter + 'Max' + globalState.csvDelimiter + 'Q1' + globalState.csvDelimiter + 'Q3' + globalState.csvDelimiter + 'IQR';
                            if (paramType === 'r') {
                                csvContent += globalState.csvDelimiter + 'CV (%)';
                            }
                            csvContent += '\n';
                        }

                        Object.entries(globalState.currentGroups).forEach(([groupId, group]) => {
                            const groupData = globalState.processedData[groupId]
                                .map(row => utils.parseNumericValue(row[paramName]))
                                .filter(val => !isNaN(val));

                            const stats = statistics.calculate(groupData);

                            csvContent += group.name + globalState.csvDelimiter + stats.count + globalState.csvDelimiter;

                            if (paramType === 'o') {
                                csvContent += utils.formatNumberForCSV(stats.median) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.q1) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.q3) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.iqr) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.min) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.max) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.range) + '\n';
                            } else {
                                csvContent += utils.formatNumberForCSV(stats.mean) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.median) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.stdDev) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.min) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.max) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.q1) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.q3) + globalState.csvDelimiter;
                                csvContent += utils.formatNumberForCSV(stats.iqr);
                                if (paramType === 'r' && stats.cv !== null) {
                                    csvContent += globalState.csvDelimiter + utils.formatNumberForCSV(stats.cv);
                                }
                                csvContent += '\n';
                            }
                        });
                    }
                });

                csvContent += '\n';
            }

            // Raw data with grouping
            if (includeRawData) {
                csvContent += 'RAW DATA WITH GROUPING\n';
                csvContent += 'Groups' + globalState.csvDelimiter + globalState.columnNames.join(globalState.csvDelimiter) + '\n';

                globalState.rawData.forEach((row, rowIndex) => {
                    // Get all groups this row belongs to
                    const rowGroups = [];
                    if (globalState.recordAssignments && globalState.recordAssignments[rowIndex]) {
                        globalState.recordAssignments[rowIndex].forEach(groupId => {
                            rowGroups.push(globalState.currentGroups[groupId].name);
                        });
                    }

                    const groupsText = rowGroups.length > 0 ? rowGroups.join('; ') : 'None';

                    let rowData = '"' + groupsText + '"' + globalState.csvDelimiter;

                    globalState.columnNames.forEach(columnName => {
                        let cellValue = '';
                        const value = row[columnName];
                        const columnType = globalState.columnTypes[columnName];

                        if (value !== undefined && value !== null) {
                            if (scaleTypes[columnType].numeric && !isNaN(value)) {
                                cellValue = utils.formatNumberForCSV(value);
                            } else {
                                cellValue = String(value);
                            }

                            // Escape delimiter in data
                            if (cellValue.includes(globalState.csvDelimiter) || cellValue.includes('"')) {
                                cellValue = '"' + cellValue.replace(/"/g, '""') + '"';
                            }
                        }

                        rowData += cellValue + globalState.csvDelimiter;
                    });

                    csvContent += rowData.slice(0, -1) + '\n';
                });
            }

            // Create download with timestamp
            const timestamp = utils.getTimestamp();
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `sra-${timestamp}-analysis-results.csv`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            URL.revokeObjectURL(url);
            utils.showSuccess('Analysis results successfully exported!');
        }

        /**
         * Export table as CSV
         */
        function exportTableAsCSV(tableId, filename) {
            utils.exportTableToCSV(tableId, filename);
        }

        /**
         * Export group definitions
         */
        function exportGroupDefinitions() {
            collectGroupDefinitions();

            if (globalState.groupDefinitions.length === 0 && globalState.parameterConstellations.length === 0) {
                utils.showError("No group definitions or constellations to export.");
                return;
            }

            // Create text representation
            let textContent = "# Statistical Research Analyzer - Group Definitions\n";
            textContent += `# Created: ${new Date().toISOString()}\n`;
            textContent += `# Format Version: 1.0\n\n`;

            // Export constellations first
            if (globalState.parameterConstellations.length > 0) {
                textContent += "# PARAMETER CONSTELLATIONS\n\n";
                globalState.parameterConstellations.forEach(constellation => {
                    textContent += utils.constellationToText(constellation);
                });
            }

            // Export group definitions
            if (globalState.groupDefinitions.length > 0) {
                textContent += "# GROUP DEFINITIONS\n\n";
                globalState.groupDefinitions.forEach(group => {
                    textContent += utils.groupDefinitionToText(group);
                });
            }

            textContent += "[SETTINGS]\n";
            textContent += `ExportDate: ${new Date().toISOString()}\n`;
            textContent += `TotalRecords: ${globalState.rawData.length}\n`;
            textContent += `Parameters: ${globalState.columnNames.length}\n`;
            textContent += `Constellations: ${globalState.parameterConstellations.length}\n`;
            textContent += `Groups: ${globalState.groupDefinitions.length}\n\n`;

            // Create download with timestamp
            const timestamp = utils.getTimestamp();
            const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `sra-${timestamp}-group-definitions.txt`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            URL.revokeObjectURL(url);
            utils.showSuccess('Group definitions successfully exported!');
        }

        /**
         * Import group definitions
         */
        function importGroupDefinitions() {
            // Create file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';

            input.addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        parseGroupDefinitionFile(e.target.result);
                    } catch (error) {
                        utils.showError("Error parsing group definition file: " + error.message);
                    }
                };

                reader.readAsText(file);
            });

            input.click();
        }

        /**
         * Parse group definition file
         */
        function parseGroupDefinitionFile(content) {
            const lines = content.split('\n');
            let currentSection = null;
            let currentItem = null;
            const importedGroups = [];
            const importedConstellations = [];

            lines.forEach(line => {
                line = line.trim();

                // Skip comments and empty lines
                if (line.startsWith('#') || line === '') return;

                // Check for section headers
                if (line === '# PARAMETER CONSTELLATIONS') {
                    currentSection = 'constellations';
                    return;
                } else if (line === '# GROUP DEFINITIONS') {
                    currentSection = 'groups';
                    return;
                }

                // New item
                if (line.startsWith('[') && line.endsWith(']')) {
                    // Save previous item if exists
                    if (currentItem) {
                        if (currentSection === 'constellations' && currentItem.conditions.length > 0) {
                            importedConstellations.push(currentItem);
                        } else if (currentSection === 'groups' && (currentItem.conditions.length > 0 || currentItem.constellations.length > 0)) {
                            importedGroups.push(currentItem);
                        }
                    }

                    const itemName = line.substring(1, line.length - 1);

                    if (itemName.startsWith('CONSTELLATION:')) {
                        currentSection = 'constellations';
                        currentItem = {
                            name: itemName.substring('CONSTELLATION:'.length),
                            conditions: []
                        };
                    } else if (itemName !== 'SETTINGS') {
                        currentSection = 'groups';
                        currentItem = {
                            name: itemName,
                            conditions: [],
                            constellations: [],
                            notInPrevious: false,
                            includeInAnalysis: true,
                            customColor: null
                        };
                    } else {
                        currentItem = null;
                    }
                    return;
                }

                // Parse attributes
                if (currentItem && line.includes(':')) {
                    const colonIndex = line.indexOf(':');
                    const key = line.substring(0, colonIndex).trim();
                    const value = line.substring(colonIndex + 1).trim();

                    if (key.startsWith('Condition_')) {
                        // Parsing for conditions
                        let match;
                        let parameter, operator, conditionValue;

                        // Check for "All Data" condition
                        if (value === '"__all_data__" = true' || value === 'All Data') {
                            currentItem.conditions.push({
                                parameter: '__all_data__',
                                operator: '=',
                                value: true,
                                type: 'special'
                            });
                            return;
                        }

                        // Try quoted parameter first
                        match = value.match(/^"([^"]+)"\s*([<>=!]+)\s*(.+)$/);
                        if (match) {
                            parameter = match[1];
                            operator = match[2];
                            conditionValue = match[3];
                        } else {
                            // Try unquoted parameter
                            match = value.match(/^(\S+)\s*([<>=!]+)\s*(.+)$/);
                            if (match) {
                                parameter = match[1];
                                operator = match[2];
                                conditionValue = match[3];
                            } else {
                                console.warn(`Could not parse condition: ${value}`);
utils.showError(`Could not parse condition: ${value}`);
                                return;
                            }
                        }

                        // Remove quotes from value if present
                        if (conditionValue.startsWith('"') && conditionValue.endsWith('"')) {
                            conditionValue = conditionValue.slice(1, -1);
                        }

                        // Skip if parameter doesn't exist
                        if (!globalState.columnNames.includes(parameter)) {
                            utils.showError(`Parameter '${parameter}' not found in current data.`);
                            return;
                        }

                        const paramType = globalState.columnTypes[parameter];
                        let parsedValue;

                        if (scaleTypes[paramType].numeric) {
                            parsedValue = utils.parseNumericValue(conditionValue);
                            if (isNaN(parsedValue)) {
                                console.warn(`Invalid numeric value for parameter '${parameter}': ${conditionValue}`);
utils.showError(`Invalid numeric value for parameter '${parameter}': ${conditionValue}`);
                                return;
                            }
                        } else {
                            parsedValue = conditionValue;
                        }

                        currentItem.conditions.push({
                            parameter: parameter,
                            operator: operator,
                            value: parsedValue,
                            type: paramType
                        });
                    } else if (key.startsWith('Constellation_')) {
                        // Parse constellation reference
                        const negated = value.includes('[NOT]');
                        const constellationName = value.replace(' [NOT]', '');
                        currentItem.constellations.push({
                            name: constellationName,
                            negated: negated
                        });
                    } else if (key === 'NotInPrevious') {
                        currentItem.notInPrevious = value.toLowerCase() === 'true';
                    } else if (key === 'IncludeInAnalysis') {
                        currentItem.includeInAnalysis = value.toLowerCase() === 'true';
                    } else if (key === 'Color') {
                        currentItem.customColor = value;
                    } else if (key === 'ColorIndex') {
                        currentItem.colorIndex = parseInt(value);
                    }
                }
            });

            // Add the last item if any
            if (currentItem) {
                if (currentSection === 'constellations' && currentItem.conditions.length > 0) {
                    importedConstellations.push(currentItem);
                } else if (currentSection === 'groups' && (currentItem.conditions.length > 0 || currentItem.constellations.length > 0)) {
                    importedGroups.push(currentItem);
                }
            }

            if (importedGroups.length === 0 && importedConstellations.length === 0) {
                utils.showError("No valid definitions found in the file.");
                return;
            }

            // Apply imported definitions to the UI
            applyImportedDefinitions(importedGroups, importedConstellations);
            utils.showSuccess(`Successfully imported ${importedConstellations.length} constellation(s) and ${importedGroups.length} group definition(s).`);
        }

        /**
         * Apply imported definitions to the UI
         */
        function applyImportedDefinitions(importedGroups, importedConstellations) {
            // Reset current definitions without confirmation
            utils.destroyAllCharts();
            initializeGroupDefinition();
            document.getElementById('analysis-results').style.display = 'none';

            // First, create constellations
            const constellationList = document.getElementById('constellation-list');
            constellationList.innerHTML = '';

            importedConstellations.forEach((constellation, index) => {
                const constellationDiv = document.createElement('div');
                constellationDiv.className = 'constellation-item';
                constellationDiv.dataset.constellationIndex = index;

                // Constellation header
                const header = document.createElement('div');
                header.className = 'constellation-header';

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'constellation-name';
                nameInput.value = constellation.name;
                nameInput.placeholder = 'Enter constellation name';

                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn btn-danger btn-small';
                removeBtn.textContent = 'Remove';
                removeBtn.addEventListener('click', () => {
                    constellationList.removeChild(constellationDiv);
                    updateConstellationIndices();
                });

                header.appendChild(nameInput);
                header.appendChild(removeBtn);
                constellationDiv.appendChild(header);

                // Parameter container
                const paramContainer = document.createElement('div');
                paramContainer.className = 'parameter-controls';
                constellationDiv.appendChild(paramContainer);

                // Add conditions
                constellation.conditions.forEach(condition => {
                    addParameterControlWithValues(paramContainer, condition);
                });

                // Add parameter button
                const addParamBtn = document.createElement('button');
                addParamBtn.className = 'btn btn-accent btn-small';
                addParamBtn.textContent = 'Add Parameter';
                addParamBtn.addEventListener('click', () => {
                    addConstellationParameterControl(paramContainer, false);
                });
                constellationDiv.appendChild(addParamBtn);

                constellationList.appendChild(constellationDiv);
            });

            // Update constellation state
            updateConstellationState();

            // Then create groups
            const container = document.getElementById('parameter-groups');
            container.innerHTML = '';

            importedGroups.forEach((group, index) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'parameter-group';
                groupDiv.dataset.groupIndex = index;

                if (!group.includeInAnalysis) {
                    groupDiv.classList.add('excluded');
                }

                // Group header
                const header = document.createElement('div');
                header.className = 'parameter-group-title';

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'group-name-input';
                nameInput.value = group.name;
                nameInput.placeholder = 'Enter group name';

                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn btn-danger btn-small';
                removeBtn.textContent = 'Remove';
                removeBtn.addEventListener('click', () => {
                    if (container.children.length > 1) {
                        container.removeChild(groupDiv);
                        updateGroupNumbers();
                    } else {
                        utils.showError("At least one subgroup must be defined.");
                    }
                });

                header.appendChild(nameInput);
                header.appendChild(removeBtn);
                groupDiv.appendChild(header);

                // Group controls (color and inclusion)
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'group-controls';

                // Color control
                const colorControl = document.createElement('div');
                colorControl.className = 'group-color-control';

                const colorLabel = document.createElement('label');
                colorLabel.textContent = 'Color:';
                colorControl.appendChild(colorLabel);

                const colorSelect = document.createElement('select');
                colorSelect.className = 'color-preset-selector';

                // Add preset colors
                groupColors.forEach((color, idx) => {
                    const option = document.createElement('option');
                    option.value = idx;
                    option.textContent = color.name;
                    colorSelect.appendChild(option);
                });

                // Add custom option
                const customOption = document.createElement('option');
                customOption.value = 'custom';
                customOption.textContent = 'Custom';
                colorSelect.appendChild(customOption);

                colorControl.appendChild(colorSelect);

                // Color preview
                const colorPreview = document.createElement('div');
                colorPreview.className = 'color-preview';
                colorControl.appendChild(colorPreview);

                // Custom color input
                const customColorInput = document.createElement('input');
                customColorInput.type = 'text';
                customColorInput.className = 'custom-color-input';
                customColorInput.placeholder = '#RRGGBB';
                customColorInput.style.display = 'none';
                colorControl.appendChild(customColorInput);

                // Set color based on imported data (AFTER creating all elements)
                if (group.customColor) {
                    colorSelect.value = 'custom';
                    customColorInput.value = group.customColor.replace('B3', '');
                    customColorInput.style.display = 'block';
                    colorPreview.style.backgroundColor = group.customColor;
                } else if (group.colorIndex !== undefined && group.colorIndex < groupColors.length) {
                    colorSelect.value = group.colorIndex;
                    colorPreview.style.backgroundColor = groupColors[group.colorIndex].bg;
                } else {
                    colorSelect.value = index % groupColors.length;
                    colorPreview.style.backgroundColor = groupColors[index % groupColors.length].bg;
                }

                // Color change handler
                colorSelect.addEventListener('change', () => {
                    if (colorSelect.value === 'custom') {
                        customColorInput.style.display = 'block';
                        customColorInput.focus();
                    } else {
                        customColorInput.style.display = 'none';
                        const colorIndex = parseInt(colorSelect.value);
                        colorPreview.style.backgroundColor = groupColors[colorIndex].bg;
                    }
                });

                customColorInput.addEventListener('input', () => {
                    const hexRegex = /^#[0-9A-F]{6}$/i;
                    if (hexRegex.test(customColorInput.value)) {
                        colorPreview.style.backgroundColor = customColorInput.value + 'B3';
                    }
                });

                controlsDiv.appendChild(colorControl);

                // Include in analysis checkbox
                const includeCheckbox = document.createElement('input');
                includeCheckbox.type = 'checkbox';
                includeCheckbox.id = `include-group-${index}`;
                includeCheckbox.checked = group.includeInAnalysis;
                includeCheckbox.addEventListener('change', () => {
                    groupDiv.classList.toggle('excluded', !includeCheckbox.checked);
                });

                const includeLabel = document.createElement('label');
                includeLabel.htmlFor = `include-group-${index}`;
                includeLabel.textContent = 'Include in analysis';

                const includeContainer = document.createElement('div');
                includeContainer.className = 'checkbox-container';
                includeContainer.appendChild(includeCheckbox);
                includeContainer.appendChild(includeLabel);

                controlsDiv.appendChild(includeContainer);

                groupDiv.appendChild(controlsDiv);

                // Not in previous groups checkbox
                const notInPreviousDiv = document.createElement('div');
                notInPreviousDiv.className = 'not-in-previous-checkbox';

                const notInPreviousCheckbox = document.createElement('input');
                notInPreviousCheckbox.type = 'checkbox';
                notInPreviousCheckbox.id = `not-in-previous-${index}`;
                notInPreviousCheckbox.checked = group.notInPrevious;

                const notInPreviousLabel = document.createElement('label');
                notInPreviousLabel.htmlFor = `not-in-previous-${index}`;
                notInPreviousLabel.textContent = 'Exclude records that are in previous groups';

                notInPreviousDiv.appendChild(notInPreviousCheckbox);
                notInPreviousDiv.appendChild(notInPreviousLabel);

                if (index === 0) {
                    notInPreviousDiv.style.display = 'none';
                }

                groupDiv.appendChild(notInPreviousDiv);

                // Condition type selector
                const conditionTypeDiv = document.createElement('div');
                conditionTypeDiv.className = 'condition-type-selector';

                const individualBtn = document.createElement('button');
                individualBtn.textContent = 'Add Individual Condition';
                individualBtn.className = 'active';
                individualBtn.addEventListener('click', () => {
                    addParameterControl(paramContainer);
                });

                const constellationBtn = document.createElement('button');
                constellationBtn.textContent = 'Add Constellation';
                constellationBtn.addEventListener('click', () => {
                    addConstellationToGroup(paramContainer);
                });

                conditionTypeDiv.appendChild(individualBtn);
                conditionTypeDiv.appendChild(constellationBtn);
                groupDiv.appendChild(conditionTypeDiv);

                // Parameter container
                const paramContainer = document.createElement('div');
                paramContainer.className = 'parameter-controls';
                groupDiv.appendChild(paramContainer);

                // Add individual conditions
                group.conditions.forEach(condition => {
                    addParameterControlWithValues(paramContainer, condition);
                });

                // Add constellations
                group.constellations.forEach(constellationRef => {
                    addConstellationToGroupWithValue(paramContainer, constellationRef);
                });

                container.appendChild(groupDiv);
            });

            // Add button for new group if none exists
            if (importedGroups.length === 0) {
                addNewGroup();
            }
        }

        /**
         * Add parameter control with pre-defined values
         */
        function addParameterControlWithValues(container, condition) {
            const controlDiv = document.createElement('div');
            controlDiv.className = 'parameter-control';

            // Parameter select
            const paramLabel = document.createElement('label');
            paramLabel.textContent = 'Parameter:';
            controlDiv.appendChild(paramLabel);

            const paramSelect = document.createElement('select');
            paramSelect.className = 'param-select';

            // Handle "All Data" condition
            if (condition.parameter === '__all_data__') {
                const allDataOption = document.createElement('option');
                allDataOption.value = '__all_data__';
                allDataOption.textContent = 'All Data';
                allDataOption.selected = true;
                paramSelect.appendChild(allDataOption);
            }

            // Default "no parameter" option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select parameter...';
            paramSelect.appendChild(defaultOption);

            // Add available parameters
            globalState.columnNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                const scaleInfo = utils.getScaleInfo(globalState.columnTypes[name]);
                option.textContent = `${name} (${scaleInfo.name})`;
                if (name === condition.parameter) {
                    option.selected = true;
                }
                paramSelect.appendChild(option);
            });

            controlDiv.appendChild(paramSelect);

            // Condition container
            const conditionContainer = document.createElement('div');
            conditionContainer.className = 'condition-controls';
            controlDiv.appendChild(conditionContainer);

            // Distribution info container
            const groupDistribution = document.createElement('div');
            groupDistribution.className = 'group-distribution';
            groupDistribution.style.display = 'none';
            controlDiv.appendChild(groupDistribution);

            // Info container
            const infoDiv = document.createElement('div');
            infoDiv.className = 'parameter-info';
            controlDiv.appendChild(infoDiv);

            // Set up condition controls
            updateConditionControls(conditionContainer, infoDiv, groupDistribution, condition.parameter);

            // Set operator and value after controls are created
            requestAnimationFrame(() => {
                const operatorSelect = conditionContainer.querySelector('.condition-operator');
                if (operatorSelect && condition.parameter !== '__all_data__') {
                    operatorSelect.value = condition.operator;

                    const valueInput = conditionContainer.querySelector('.condition-value');
                    if (valueInput) {
                        valueInput.value = condition.value;

                        // Trigger distribution update
                        if (scaleTypes[condition.type].numeric) {
                            updateNumericDistribution(condition.parameter, condition.operator, condition.value, groupDistribution);
                        } else {
                            updateCategoryDistribution(condition.parameter, condition.operator, condition.value, groupDistribution);
                        }
                    }
                }
            });

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove Parameter';
            removeBtn.style.marginTop = '10px';
            removeBtn.addEventListener('click', () => {
                container.removeChild(controlDiv);
            });
            controlDiv.appendChild(removeBtn);

            container.appendChild(controlDiv);
        }

        /**
         * Add constellation to group with pre-selected value
         */
        function addConstellationToGroupWithValue(container, constellationRef) {
            const controlDiv = document.createElement('div');
            controlDiv.className = 'parameter-control constellation-reference';
            if (constellationRef.negated) {
                controlDiv.classList.add('negated');
            }

            const label = document.createElement('label');
            label.textContent = 'Constellation:';
            controlDiv.appendChild(label);

            // Negation checkbox
            const negationCheckbox = document.createElement('input');
            negationCheckbox.type = 'checkbox';
            negationCheckbox.className = 'negation-checkbox';
            negationCheckbox.checked = constellationRef.negated;
            negationCheckbox.addEventListener('change', () => {
                controlDiv.classList.toggle('negated', negationCheckbox.checked);
                updateConstellationDisplay();
            });

            const negationLabel = document.createElement('label');
            negationLabel.textContent = 'NOT';
            negationLabel.style.marginRight = '10px';

            const negationContainer = document.createElement('span');
            negationContainer.appendChild(negationCheckbox);
            negationContainer.appendChild(negationLabel);
            controlDiv.appendChild(negationContainer);

            const constellationSelect = document.createElement('select');
            constellationSelect.className = 'constellation-select';

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select constellation...';
            constellationSelect.appendChild(defaultOption);

            globalState.parameterConstellations.forEach((constellation, index) => {
                const option = document.createElement('option');
                option.value = constellation.name;
                option.textContent = constellation.name;
                if (constellation.name === constellationRef.name) {
                    option.selected = true;
                }
                constellationSelect.appendChild(option);
            });

            controlDiv.appendChild(constellationSelect);

            // Display constellation conditions
            const conditionsDisplay = document.createElement('div');
            conditionsDisplay.className = 'constellation-conditions';
            conditionsDisplay.style.marginTop = '10px';
            conditionsDisplay.style.fontSize = '0.9em';
            conditionsDisplay.style.color = '#666';
            controlDiv.appendChild(conditionsDisplay);

            const updateConstellationDisplay = () => {
                const selectedConstellation = globalState.parameterConstellations.find(
                    c => c.name === constellationSelect.value
                );

                if (selectedConstellation) {
                    const conditionsText = selectedConstellation.conditions.map(c => {
                        if (c.parameter === '__all_data__') {
                            return 'All Data';
                        }
                        return `${c.parameter} ${c.operator} ${c.value}`;
                    }).join(' AND ');

                    const prefix = negationCheckbox.checked ? '<strong>NOT</strong> (' : '';
                    const suffix = negationCheckbox.checked ? ')' : '';
                    conditionsDisplay.innerHTML = `<strong>Conditions:</strong> ${prefix}${conditionsText}${suffix}`;
                } else {
                    conditionsDisplay.innerHTML = '';
                }
            };

            // Initial display update
            updateConstellationDisplay();

            constellationSelect.addEventListener('change', updateConstellationDisplay);

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'btn btn-danger btn-small';
            removeBtn.textContent = 'Remove Constellation';
            removeBtn.style.marginTop = '10px';
            removeBtn.addEventListener('click', () => {
                container.removeChild(controlDiv);
            });
            controlDiv.appendChild(removeBtn);

            container.appendChild(controlDiv);
        }

        /**
         * Reset groups
         */
        function resetGroups() {
            if (confirm('Are you sure you want to reset all groups and constellations?')) {
                utils.destroyAllCharts();
                initializeGroupDefinition();
                document.getElementById('analysis-results').style.display = 'none';
                utils.showSuccess('Groups and constellations have been reset.');
            }
        }

        /**
         * Export group overview
         */
        function exportGroupOverview() {
            let content = 'GROUP OVERVIEW REPORT\n';
            content += `Generated: ${new Date().toLocaleDateString()}\n\n`;

            content += 'GROUP SUMMARY\n';
            content += 'Group' + globalState.csvDelimiter + 'Count' + globalState.csvDelimiter + 'Percentage\n';

            const totalRecords = globalState.rawData.length;
            Object.entries(globalState.currentGroups).forEach(([groupId, group]) => {
                const percentage = ((group.count / totalRecords) * 100).toFixed(1);
                content += group.name + globalState.csvDelimiter + group.count + globalState.csvDelimiter + percentage + '%\n';
            });

            content += 'Total' + globalState.csvDelimiter + totalRecords + globalState.csvDelimiter + '100%\n\n';

            // Create download
            const timestamp = utils.getTimestamp();
            const blob = new Blob(['\uFEFF' + content], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `sra-${timestamp}-group-overview.csv`);
            link.click();

            URL.revokeObjectURL(url);
            utils.showSuccess('Group overview exported successfully!');
        }

        /**
         * Export significance test results
         */
        function exportSignificanceTests() {
    if (globalState.significanceResults.length === 0) {
        utils.showError("No significance test results to export.");
        return;
    }

    const lines = ['STATISTICAL SIGNIFICANCE TEST RESULTS'];
    lines.push('=' .repeat(60));
    lines.push(`Generated: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`);
    lines.push(`Total Tests Performed: ${globalState.significanceResults.length}`);
    lines.push('');

    globalState.significanceResults.forEach((testResult, index) => {
        const result = testResult.result;
        
        // Test header with test type
        lines.push('-'.repeat(60));
        lines.push(`${result.test.toUpperCase()}`);
        lines.push('-'.repeat(60));
        
        // Basic information
        lines.push(`Parameter: ${testResult.paramName}`);
        lines.push(`Groups Compared: ${testResult.groupNames.join(' vs ')}`);
        lines.push(`Test Performed: ${new Date(testResult.timestamp).toLocaleString()}`);
        lines.push('');
        
        // Main result
        lines.push('RESULT:');
        lines.push(`Status: ${result.significant ? 'STATISTICALLY SIGNIFICANT' : 'NOT STATISTICALLY SIGNIFICANT'}`);
        lines.push(`p-value: ${result.pValue?.toFixed(6) || 'N/A'}`);
        lines.push(`Significance Level (α): ${result.alpha}`);
        lines.push('');
        
        // Test-specific statistics
        lines.push('TEST STATISTICS:');
        
        if (result.test === 't-Test' || result.test === "Welch's t-Test") {
            lines.push(`t-statistic: ${result.statistic?.toFixed(4)}`);
            lines.push(`Degrees of Freedom: ${result.df?.toFixed(2)}`);
            lines.push(`Effect Size (Cohen's d): ${result.effectSize?.toFixed(3)}`);
            lines.push(`Mean Difference: ${result.meanDifference?.toFixed(3)}`);
            lines.push(`${(1 - result.alpha) * 100}% Confidence Interval: [${result.confidenceInterval[0].toFixed(3)}, ${result.confidenceInterval[1].toFixed(3)}]`);
            lines.push(`Statistical Power: ${result.power?.toFixed(3)}`);
            lines.push('');
            lines.push('GROUP STATISTICS:');
            lines.push(`Group 1 (${testResult.groupNames[0]}): n=${result.group1Stats.count}, Mean=${result.group1Stats.mean?.toFixed(3)}, SD=${result.group1Stats.stdDev?.toFixed(3)}`);
            lines.push(`Group 2 (${testResult.groupNames[1]}): n=${result.group2Stats.count}, Mean=${result.group2Stats.mean?.toFixed(3)}, SD=${result.group2Stats.stdDev?.toFixed(3)}`);
            
        } else if (result.test === 'ANOVA') {
            lines.push(`F-statistic: F(${result.dfBetween}, ${result.dfWithin}) = ${result.statistic?.toFixed(4)}`);
            lines.push(`Effect Size (η²): ${result.etaSquared?.toFixed(3)}`);
            lines.push(`Statistical Power: ${result.power?.toFixed(3)}`);
            lines.push('');
            lines.push('SUM OF SQUARES:');
            lines.push(`Between Groups: ${result.ssb?.toFixed(3)}`);
            lines.push(`Within Groups: ${result.ssw?.toFixed(3)}`);
            lines.push(`Mean Square Between: ${result.msb?.toFixed(3)}`);
            lines.push(`Mean Square Within: ${result.msw?.toFixed(3)}`);
            
            if (result.groupStats) {
                lines.push('');
                lines.push('GROUP STATISTICS:');
                result.groupStats.forEach((stat, idx) => {
                    lines.push(`${testResult.groupNames[idx]}: n=${stat.n}, Mean=${stat.mean?.toFixed(3)}, SD=${stat.stdDev?.toFixed(3)}`);
                });
            }
            
        } else if (result.test === 'Mann-Whitney U') {
            lines.push(`U Statistic: ${result.U}`);
            lines.push(`Effect Size (r): ${result.effectSize?.toFixed(3)}`);
            lines.push(`Sample Sizes: n₁=${result.n1}, n₂=${result.n2}`);
            lines.push(`Rank Sums: R₁=${result.rankSum1?.toFixed(1)}, R₂=${result.rankSum2?.toFixed(1)}`);
            lines.push(`Mean U: ${result.meanU?.toFixed(2)}`);
            lines.push(`Standard Deviation U: ${result.sdU?.toFixed(2)}`);
            if (result.tieCorrection) {
                lines.push('Note: Tie correction was applied');
            }
            
        } else if (result.test === 'Kruskal-Wallis') {
            lines.push(`H Statistic: ${result.H?.toFixed(4)}`);
            lines.push(`Degrees of Freedom: ${result.df}`);
            lines.push(`Effect Size (η²): ${result.etaSquared?.toFixed(3)}`);
            lines.push(`Total Sample Size: ${result.N}`);
            if (result.groupSizes) {
                lines.push(`Group Sizes: ${result.groupSizes.join(', ')}`);
            }
            if (result.groupRankSums) {
                lines.push(`Group Rank Sums: ${result.groupRankSums.map(r => r.toFixed(1)).join(', ')}`);
            }
            if (result.tieCorrection) {
                lines.push('Note: Tie correction was applied');
            }
            
        } else if (result.test === 'Chi-Square') {
            lines.push(`Chi-Square (χ²): ${result.statistic?.toFixed(4)}`);
            lines.push(`Degrees of Freedom: ${result.df}`);
            lines.push(`Effect Size (Cramer's V): ${result.cramersV?.toFixed(3)}`);
            lines.push(`Statistical Power: ${result.power?.toFixed(3)}`);
            
            if (result.observed && result.categories && result.groups) {
                lines.push('');
                lines.push('CONTINGENCY TABLE:');
                // Header
                lines.push(`\t${result.groups.join('\t')}`);
                // Data rows
                result.categories.forEach((cat, i) => {
                    lines.push(`${cat}\t${result.observed[i].join('\t')}`);
                });
            }
            
            if (result.warning) {
                lines.push('');
                lines.push(`Warning: ${result.warning}`);
            }
            
        } else if (result.test === "Fisher's Exact Test") {
            lines.push(`Odds Ratio: ${result.oddsRatio?.toFixed(3)}`);
            
            if (result.table && result.categories && result.groups) {
                lines.push('');
                lines.push('2x2 CONTINGENCY TABLE:');
                lines.push(`\t${result.groups[0]}\t${result.groups[1]}`);
                lines.push(`${result.categories[0]}\t${result.table[0][0]}\t${result.table[1][0]}`);
                lines.push(`${result.categories[1]}\t${result.table[0][1]}\t${result.table[1][1]}`);
            }
        }
        
        // Post-hoc analysis if present
        if (result.postHoc && result.postHoc.comparisons) {
            lines.push('');
            lines.push(`POST-HOC ANALYSIS (${result.postHoc.method}):`);
            if (result.postHoc.adjustedAlpha) {
                lines.push(`Adjusted Alpha: ${result.postHoc.adjustedAlpha.toFixed(4)}`);
            }
            lines.push('');
            
            result.postHoc.comparisons.forEach(comp => {
                lines.push(`${testResult.groupNames[comp.group1 - 1]} vs ${testResult.groupNames[comp.group2 - 1]}:`);
                
                if (comp.meanDiff !== undefined) {
                    lines.push(`  Mean Difference: ${comp.meanDiff.toFixed(3)}`);
                }
                if (comp.rankDiff !== undefined) {
                    lines.push(`  Mean Rank Difference: ${comp.rankDiff.toFixed(2)}`);
                }
                if (comp.z !== undefined) {
                    lines.push(`  Z-statistic: ${comp.z.toFixed(3)}`);
                }
                if (comp.chiSquare !== undefined) {
                    lines.push(`  Chi-Square: ${comp.chiSquare.toFixed(3)}`);
                }
                
                const pVal = comp.adjustedPValue || comp.pValue;
                lines.push(`  p-value: ${pVal?.toFixed(4)}`);
                lines.push(`  Significant: ${comp.significant ? 'Yes' : 'No'}`);
                
                if (comp.lowerCI !== undefined && comp.upperCI !== undefined) {
                    lines.push(`  95% CI: [${comp.lowerCI.toFixed(3)}, ${comp.upperCI.toFixed(3)}]`);
                }
                lines.push('');
            });
        }
        
        // Test violations if any
        if (result.violations && result.violations.length > 0) {
            lines.push('');
            lines.push('TEST REQUIREMENT VIOLATIONS:');
            result.violations.forEach(v => lines.push(`- ${v}`));
        }
        
        lines.push('');
    });

    // Create and download file
    const content = lines.join('\n');
    const timestamp = utils.getTimestamp();
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);

    link.setAttribute('href', url);
    link.setAttribute('download', `sra-${timestamp}-significance-tests.txt`);
    link.click();

    URL.revokeObjectURL(url);
    utils.showSuccess('Significance test results exported successfully!');
}


        /**
         * Export fourfold table results
         */
        function exportFourfoldTable() {
    if (!globalState.fourfoldResults) {
        utils.showError("No fourfold table results to export.");
        return;
    }

    const results = globalState.fourfoldResults;
    const lines = [];

    lines.push('DIAGNOSTIC TEST ANALYSIS - FOURFOLD TABLE');
    lines.push('=' .repeat(60));
    lines.push(`Generated: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`);
    lines.push('');

    // Test configuration
    const testName = results.not1 ? `NOT ${results.testConstellation}` : results.testConstellation;
    const conditionName = results.not2 ? `NOT ${results.trueConditionConstellation}` : results.trueConditionConstellation;

    lines.push('TEST CONFIGURATION:');
    lines.push(`Test (What is being tested): ${testName}`);
    lines.push(`True Condition (Gold Standard): ${conditionName}`);
    lines.push('');

    // Validation status
    if (results.validation) {
        lines.push('DATA VALIDATION:');
        if (results.validation.isValid) {
            lines.push('Status: ✓ Valid - All requirements met');
        } else {
            lines.push('Status: ✗ Invalid - Critical errors present');
            if (results.validation.errors.length > 0) {
                lines.push('Errors:');
                results.validation.errors.forEach(error => lines.push(`  - ${error}`));
            }
        }
        
        if (results.validation.warnings.length > 0) {
            lines.push('Warnings:');
            results.validation.warnings.forEach(warning => lines.push(`  - ${warning}`));
        }
        lines.push('');
    }

    // Contingency table
    lines.push('CONTINGENCY TABLE:');
    lines.push('-'.repeat(40));
    lines.push(`\t\t${conditionName} (+)\t${conditionName} (−)`);
    lines.push(`${testName} (+)\t${results.table[0][0]} (TP)\t\t${results.table[0][1]} (FP)`);
    lines.push(`${testName} (−)\t${results.table[1][0]} (FN)\t\t${results.table[1][1]} (TN)`);
    lines.push('-'.repeat(40));
    lines.push(`Total Sample Size: ${results.stats.n}`);
    lines.push('');

    // Diagnostic metrics (if valid)
    if (results.validation.isValid && results.diagnosticMetrics) {
        const dm = results.diagnosticMetrics;
        lines.push('DIAGNOSTIC TEST METRICS:');
        lines.push('-'.repeat(40));
        
         // Performance metrics
        lines.push('Test Performance:');
        if (dm.sensitivity !== undefined && dm.sensitivityCI) {
            lines.push(`  Sensitivity: ${(dm.sensitivity * 100).toFixed(1)}% [95% CI: ${(dm.sensitivityCI[0] * 100).toFixed(1)}%-${(dm.sensitivityCI[1] * 100).toFixed(1)}%]`);
        }
        if (dm.specificity !== undefined && dm.specificityCI) {
            lines.push(`  Specificity: ${(dm.specificity * 100).toFixed(1)}% [95% CI: ${(dm.specificityCI[0] * 100).toFixed(1)}%-${(dm.specificityCI[1] * 100).toFixed(1)}%]`);
        }
        if (dm.accuracy !== undefined) {
            lines.push(`  Accuracy: ${(dm.accuracy * 100).toFixed(1)}%`);
        }
        lines.push('');
        
        // Predictive values
        lines.push('Predictive Values:');
        if (dm.ppv !== undefined && dm.ppvCI) {
            lines.push(`  Positive Predictive Value (PPV): ${(dm.ppv * 100).toFixed(1)}% [95% CI: ${(dm.ppvCI[0] * 100).toFixed(1)}%-${(dm.ppvCI[1] * 100).toFixed(1)}%]`);
        }
        if (dm.npv !== undefined && dm.npvCI) {
            lines.push(`  Negative Predictive Value (NPV): ${(dm.npv * 100).toFixed(1)}% [95% CI: ${(dm.npvCI[0] * 100).toFixed(1)}%-${(dm.npvCI[1] * 100).toFixed(1)}%]`);
        }
        if (dm.prevalence !== undefined) {
            lines.push(`  Prevalence: ${(dm.prevalence * 100).toFixed(1)}%`);
        }
        lines.push('');
        
        // Likelihood ratios
        lines.push('Likelihood Ratios:');
        if (isFinite(dm.lrPositive)) {
            lines.push(`  Positive Likelihood Ratio (LR+): ${dm.lrPositive.toFixed(2)}`);
        } else {
            lines.push(`  Positive Likelihood Ratio (LR+): ∞ (Perfect specificity)`);
        }
        
        if (isFinite(dm.lrNegative)) {
            lines.push(`  Negative Likelihood Ratio (LR−): ${dm.lrNegative.toFixed(2)}`);
        } else {
            lines.push(`  Negative Likelihood Ratio (LR−): 0 (Perfect sensitivity)`);
        }
        
        if (isFinite(dm.dor)) {
            lines.push(`  Diagnostic Odds Ratio (DOR): ${dm.dor.toFixed(2)}`);
        } else {
            lines.push(`  Diagnostic Odds Ratio (DOR): ∞ (Perfect test)`);
        }
        lines.push('');
        
        // Additional metrics
        lines.push('Additional Metrics:');
        lines.push(`  Youden's Index: ${dm.youdenIndex.toFixed(3)}`);
        lines.push(`  F1 Score: ${dm.f1Score.toFixed(3)}`);
        lines.push(`  Matthews Correlation Coefficient (MCC): ${dm.mcc.toFixed(3)}`);
        lines.push('');
    }

    // Association measures (always available)
    lines.push('ASSOCIATION MEASURES:');
    lines.push('-'.repeat(40));
    
    if (results.stats.odds.oddsRatio !== undefined && isFinite(results.stats.odds.oddsRatio)) {
        lines.push(`Odds Ratio: ${results.stats.odds.oddsRatio.toFixed(3)} [95% CI: ${results.stats.odds.oddsRatioCI[0].toFixed(3)}-${results.stats.odds.oddsRatioCI[1].toFixed(3)}]`);
    }
    
    if (results.stats.risk.riskDifference !== undefined && isFinite(results.stats.risk.riskDifference)) {
        lines.push(`Risk Difference: ${results.stats.risk.riskDifference.toFixed(3)} [95% CI: ${results.stats.risk.riskDifferenceCI[0].toFixed(3)}-${results.stats.risk.riskDifferenceCI[1].toFixed(3)}]`);
    }
    
    if (results.stats.risk.riskRatio !== undefined && isFinite(results.stats.risk.riskRatio)) {
        lines.push(`Risk Ratio: ${results.stats.risk.riskRatio.toFixed(3)}`);
    }
    
    if (results.stats.risk.nnt !== undefined && isFinite(results.stats.risk.nnt)) {
        lines.push(`Number Needed to Treat (NNT): ${Math.abs(results.stats.risk.nnt).toFixed(1)}`);
    }
    
    lines.push(`Phi Coefficient: ${results.stats.phi.toFixed(3)}`);
    lines.push('');
    
    // Statistical tests
    lines.push('STATISTICAL TESTS:');
    lines.push('-'.repeat(40));
    lines.push(`Chi-Square Test:`);
    lines.push(`  χ² = ${results.stats.chiSquare.statistic.toFixed(3)}`);
    lines.push(`  p-value = ${results.stats.chiSquare.pValue.toFixed(4)} ${results.stats.chiSquare.pValue < 0.05 ? '(Significant)' : '(Not significant)'}`);
    lines.push(`  With Yates correction: χ² = ${results.stats.chiSquare.statisticYates.toFixed(3)}, p = ${results.stats.chiSquare.pValueYates.toFixed(4)}`);
    lines.push('');
    
    lines.push(`Fisher's Exact Test:`);
    lines.push(`  p-value = ${results.stats.fisherExact.pValue.toFixed(4)} ${results.stats.fisherExact.pValue < 0.05 ? '(Significant)' : '(Not significant)'}`);
    
    // Create and download file
    const content = lines.join('\n');
    const timestamp = utils.getTimestamp();
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);

    link.setAttribute('href', url);
    link.setAttribute('download', `sra-${timestamp}-fourfold-table-analysis.txt`);
    link.click();

    URL.revokeObjectURL(url);
    utils.showSuccess('Fourfold table analysis exported successfully!');
}
    </script>
</body>

</html>
